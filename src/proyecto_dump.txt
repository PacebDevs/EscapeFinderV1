=== global.scss ===
/*
 * App Global CSS
 * ----------------------------------------------------------------------------
 * Mantengo tu base y a√±ado los estilos necesarios para el mapa.
 */

/* Core CSS required for Ionic components to work properly */
@import "@ionic/angular/css/core.css";

/* Basic CSS for apps built with Ionic */
@import "@ionic/angular/css/normalize.css";
@import "@ionic/angular/css/structure.css";
@import "@ionic/angular/css/typography.css";
@import "@ionic/angular/css/display.css";

/* Optional CSS utils that can be commented out */
@import "@ionic/angular/css/padding.css";
@import "@ionic/angular/css/float-elements.css";
@import "@ionic/angular/css/text-alignment.css";
@import "@ionic/angular/css/text-transformation.css";
@import "@ionic/angular/css/flex-utils.css";

@import 'swiper/css';
@import 'swiper/css/pagination';
@import 'swiper/css/navigation';

/* Dark Mode (si lo usas) */
@import "@ionic/angular/css/palettes/dark.system.css";

/* Fuente */
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@700;800;900&display=swap');

/* Leaflet styles */
@import "leaflet/dist/leaflet.css";

/* Header base (tu estilo) */
ion-header,
ion-toolbar {
  padding-top: var(--safe-area-inset-top, 0px);
  background: #fff;
}

/* Este padding global es √∫til para tabs, pero lo anularemos en la p√°gina de mapa */
ion-content {
  --padding-top: 0px;
  --padding-bottom: calc(var(--safe-area-inset-bottom, 0px) + 80px); // 80px para la barra de tabs
  background: #fff;
}

ion-footer {
  padding-bottom: var(--safe-area-inset-bottom, 0px);
}

/* Vars globales */
:root {
  --ef-title-color: #1F2937;
  --ef-meta-color:  #64748B;
  --ef-font-stack: "Inter", ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI",
                   Roboto, "Helvetica Neue", "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji";
}

html, body, ion-app, ion-router-outlet {
  height: 100%;
}


=== index.html ===
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>Ionic App</title>

  <base href="/" />

  <meta name="color-scheme" content="light dark" />
  <meta name="viewport" content="viewport-fit=cover, width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="format-detection" content="telephone=no" />
  <meta name="msapplication-tap-highlight" content="no" />

  <link rel="icon" type="image/png" href="assets/icon/favicon.png" />

  <!-- add to homescreen for ios -->
  <meta name="mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
</head>

<body>
  <app-root></app-root>
</body>

</html>


=== main.ts ===
import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
import { AppModule } from './app/app.module';

import { register } from 'swiper/element/bundle'; // üëà
register();                                      // üëà

platformBrowserDynamic().bootstrapModule(AppModule)
  .catch(err => console.log(err));


=== polyfills.ts ===
/**
 * This file includes polyfills needed by Angular and is loaded before the app.
 * You can add your own extra polyfills to this file.
 *
 * This file is divided into 2 sections:
 *   1. Browser polyfills. These are applied before loading ZoneJS and are sorted by browsers.
 *   2. Application imports. Files imported after ZoneJS that should be loaded before your main
 *      file.
 *
 * The current setup is for so-called "evergreen" browsers; the last versions of browsers that
 * automatically update themselves. This includes recent versions of Safari, Chrome (including
 * Opera), Edge on the desktop, and iOS and Chrome on mobile.
 *
 * Learn more in https://angular.io/guide/browser-support
 */

/***************************************************************************************************
 * BROWSER POLYFILLS
 */

/**
 * By default, zone.js will patch all possible macroTask and DomEvents
 * user can disable parts of macroTask/DomEvents patch by setting following flags
 * because those flags need to be set before `zone.js` being loaded, and webpack
 * will put import in the top of bundle, so user need to create a separate file
 * in this directory (for example: zone-flags.ts), and put the following flags
 * into that file, and then add the following code before importing zone.js.
 * import './zone-flags';
 *
 * The flags allowed in zone-flags.ts are listed here.
 *
 * The following flags will work for all browsers.
 *
 * (window as any).__Zone_disable_requestAnimationFrame = true; // disable patch requestAnimationFrame
 * (window as any).__Zone_disable_on_property = true; // disable patch onProperty such as onclick
 * (window as any).__zone_symbol__UNPATCHED_EVENTS = ['scroll', 'mousemove']; // disable patch specified eventNames
 *
 *  in IE/Edge developer tools, the addEventListener will also be wrapped by zone.js
 *  with the following flag, it will bypass `zone.js` patch for IE/Edge
 *
 *  (window as any).__Zone_enable_cross_context_check = true;
 *
 */
 
import './zone-flags';

/***************************************************************************************************
 * Zone JS is required by default for Angular itself.
 */
import 'zone.js';  // Included with Angular CLI.


/***************************************************************************************************
 * APPLICATION IMPORTS
 */


=== test.ts ===
// This file is required by karma.conf.js and loads recursively all the .spec and framework files

import 'zone.js/testing';
import { getTestBed } from '@angular/core/testing';
import {
  BrowserDynamicTestingModule,
  platformBrowserDynamicTesting
} from '@angular/platform-browser-dynamic/testing';

// First, initialize the Angular testing environment.
getTestBed().initTestEnvironment(
  BrowserDynamicTestingModule,
  platformBrowserDynamicTesting(),
);


=== zone-flags.ts ===
/**
 * Prevents Angular change detection from
 * running with certain Web Component callbacks
 */
// eslint-disable-next-line no-underscore-dangle
(window as any).__Zone_disable_customElements = true;


=== app/app-routing.module.ts ===
import { NgModule } from '@angular/core';
import { PreloadAllModules, RouterModule, Routes } from '@angular/router';

const routes: Routes = [
  {
    path: '',
    redirectTo: 'tabs/tab2',
    pathMatch: 'full'
  },
  {
    path: 'tabs',
    loadChildren: () => import('./tabs/tabs.module').then(m => m.TabsPageModule)
  },
  {
    path: 'sala/:id',
    loadChildren: () => import('./pages/sala-detalle/sala-detalle.module').then( m => m.SalaDetallePageModule)
  },
  {
    path: 'mapa',
    loadChildren: () => import('./pages/mapa/mapa.module').then( m => m.MapaPageModule)
  }
];

@NgModule({
  imports: [RouterModule.forRoot(routes, { preloadingStrategy: PreloadAllModules })],
  exports: [RouterModule]
})
export class AppRoutingModule {}


=== app/app.component.html ===
<ion-app>
  <ion-router-outlet></ion-router-outlet>
</ion-app>


=== app/app.component.scss ===


=== app/app.component.spec.ts ===
import { CUSTOM_ELEMENTS_SCHEMA } from '@angular/core';
import { TestBed } from '@angular/core/testing';

import { AppComponent } from './app.component';

describe('AppComponent', () => {

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      declarations: [AppComponent],
      schemas: [CUSTOM_ELEMENTS_SCHEMA],
    }).compileComponents();
  });

  it('should create the app', () => {
    const fixture = TestBed.createComponent(AppComponent);
    const app = fixture.componentInstance;
    expect(app).toBeTruthy();
  });

});


=== app/app.component.ts ===
import { Component } from '@angular/core';
import { EdgeToEdge } from '@capawesome/capacitor-android-edge-to-edge-support';
import { StatusBar, Style } from '@capacitor/status-bar';
import { Keyboard } from '@capacitor/keyboard';
import { Capacitor } from '@capacitor/core';


@Component({
  selector: 'app-root',
  templateUrl: 'app.component.html',
  styleUrls: ['app.component.scss'],
  standalone: false
})
export class AppComponent {
  constructor() {
    this.initializeApp();
  }

  async initializeApp() {
    await EdgeToEdge.enable();
    await EdgeToEdge.setBackgroundColor({ color: '#ffffff' });
    await StatusBar.setOverlaysWebView({ overlay: false });
    await StatusBar.setStyle({ style: Style.Dark });
  }

  ngOnInit() {
    try {
      if (Capacitor.isNativePlatform()) {
        // setResizeMode puede no existir en versiones antiguas; usar optional chaining
        (Keyboard as any).setResizeMode?.({ mode: 'ionic' });
      }
    } catch {}
  }
}


=== app/app.module.ts ===
import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { RouteReuseStrategy } from '@angular/router';

import { IonicModule, IonicRouteStrategy } from '@ionic/angular';
import { AppComponent } from './app.component';
import { AppRoutingModule } from './app-routing.module';
import { HttpClientModule } from '@angular/common/http';
import { NgxsModule } from '@ngxs/store';
import { SalaState } from './states/salas/salas.state';
import { UsuarioState } from './states/usuario.state';
import { NgxsStoragePluginModule } from '@ngxs/storage-plugin';

@NgModule({
  declarations: [AppComponent],
  imports: [
    BrowserModule,
    IonicModule.forRoot(),
    HttpClientModule,
    AppRoutingModule,

    NgxsModule.forRoot([SalaState, UsuarioState]),
    NgxsStoragePluginModule.forRoot({
      keys: ['usuario']
    })
  ],
  providers: [{ provide: RouteReuseStrategy, useClass: IonicRouteStrategy }],
  bootstrap: [AppComponent]
})
export class AppModule {}

=== environments/environment.prod.ts ===
export const environment = {
  production: true,
  apiUrl: 'https://skirt-linked-neighborhood-baltimore.trycloudflare.com/api',
  imageURL: 'https://skirt-linked-neighborhood-baltimore.trycloudflare.com/',

/*mapas*/
tilesUrl: 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
tilesAttribution: '¬© OpenStreetMap contributors'
};


=== environments/environment.ts ===
// This file can be replaced during build by using the `fileReplacements` array.
// `ng build` replaces `environment.ts` with `environment.prod.ts`.
// The list of file replacements can be found in `angular.json`.

export const environment = {
  production: true,
  //Piso y casa de padres
 apiUrl: 'http://192.168.1.130:3000/api',
imageURL: 'http://192.168.1.130:3000/', // <-- Add comma here
//Internet
 // apiUrl: 'https://skirt-linked-neighborhood-baltimore.trycloudflare.com/api',
  //imageURL: 'https://skirt-linked-neighborhood-baltimore.trycloudflare.com/',
 //Parcela
//apiUrl: 'http://localhost:3000/api',
//imageURL: 'http://localhost:3000/'
/*PARCELA*/
//apiUrl: 'http://192.168.1.200:3000/api',
//imageURL: 'http://192.168.1.200:3000/'
/* Mapas*/
tilesUrl: 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
tilesAttribution: '¬© OpenStreetMap contributors'

};

/*
 * For easier debugging in development mode, you can import the following file
 * to ignore zone related error stack frames such as `zone.run`, `zoneDelegate.invokeTask`.
 *
 * This import should be commented out in production mode because it will have a negative impact
 * on performance if an error is thrown.
 */
// import 'zone.js/plugins/zone-error';  // Included with Angular CLI.


=== theme/variables.scss ===
// For information on how to create your own theme, please see:
// http://ionicframework.com/docs/theming/


=== app/constants/categorias.const.ts ===
export interface Categoria {
    nombre: string;   // Visible para el usuario
    valor: string;    // Enviado al backend
    icono: string;
  }
  
  export const CATEGORIAS: Categoria[] = [
   // { nombre: 'Filtros',          valor: 'Filtros',          icono: 'assets/categorias/varita-magica.png' },
    { nombre: 'Fantas√≠a',         valor: 'fantasia',         icono: 'assets/categorias/book.png' },
    { nombre: 'Aventuras',        valor: 'aventuras',        icono: 'assets/categorias/map.png' },
    { nombre: 'Terror',           valor: 'terror',           icono: 'assets/categorias/skull.png' },
    { nombre: 'C. Ficci√≥n',       valor: 'Ciencia Ficci√≥n',  icono: 'assets/categorias/ufo.png' },
    { nombre: 'Historia',         valor: 'historia',         icono: 'assets/categorias/greek-pillars.png' },
    { nombre: 'Apocal√≠ptico',     valor: 'apocaliptico',     icono: 'assets/categorias/nuclear-bomb.png' },
    { nombre: 'Misterio',         valor: 'misterio',         icono: 'assets/categorias/footprint.png' },
    { nombre: 'Polic√≠aca',        valor: 'policiaca',        icono: 'assets/categorias/police-car.png' },
    { nombre: 'Criminal',         valor: 'criminal',         icono: 'assets/categorias/money-bag_02.png' },
    { nombre: 'Adultos',          valor: 'adultos',          icono: 'assets/categorias/wine.png' },
    { nombre: 'Ni√±os',            valor: 'ninos',            icono: 'assets/categorias/cubes.png' },
  ];


=== app/constants/storage.keys.ts ===
// src/app/constants/storage.keys.ts
export const STORAGE_KEYS = {
  FAVORITOS_SALAS: 'favoritos_salas',
  TOKEN: 'auth_token',
  USER_DATA: 'user_data'
};


=== app/explore-container/explore-container.component.html ===
<div id="container">
  <strong>{{ name }}</strong>
  <p>Explore <a target="_blank" rel="noopener noreferrer" href="https://ionicframework.com/docs/components">UI Components</a></p>
</div>

=== app/explore-container/explore-container.component.scss ===
#container {
  text-align: center;

  position: absolute;
  left: 0;
  right: 0;
  top: 50%;
  transform: translateY(-50%);
}

#container strong {
  font-size: 20px;
  line-height: 26px;
}

#container p {
  font-size: 16px;
  line-height: 22px;

  color: #8c8c8c;

  margin: 0;
}

#container a {
  text-decoration: none;
}

=== app/explore-container/explore-container.component.spec.ts ===
import { ComponentFixture, TestBed } from '@angular/core/testing';
import { IonicModule } from '@ionic/angular';

import { ExploreContainerComponent } from './explore-container.component';

describe('ExploreContainerComponent', () => {
  let component: ExploreContainerComponent;
  let fixture: ComponentFixture<ExploreContainerComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      declarations: [ExploreContainerComponent],
      imports: [IonicModule.forRoot()]
    }).compileComponents();

    fixture = TestBed.createComponent(ExploreContainerComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});


=== app/explore-container/explore-container.component.ts ===
import { Component, Input } from '@angular/core';

@Component({
  selector: 'app-explore-container',
  templateUrl: './explore-container.component.html',
  styleUrls: ['./explore-container.component.scss'],
  standalone: false,
})
export class ExploreContainerComponent {

  @Input() name?: string;

}


=== app/explore-container/explore-container.module.ts ===
import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';

import { IonicModule } from '@ionic/angular';

import { ExploreContainerComponent } from './explore-container.component';

@NgModule({
  imports: [ CommonModule, FormsModule, IonicModule],
  declarations: [ExploreContainerComponent],
  exports: [ExploreContainerComponent]
})
export class ExploreContainerComponentModule {}


=== app/models/filtros.model.ts ===
// src/app/models/filtros.model.ts
export interface FiltrosBusqueda {
  query?: string;
  ciudad?: string;
  categorias?: string[];
  dificultad?: string[];
  accesibilidad?: string[];
  restricciones_aptas?: string[];
  publico_objetivo?: string[];
  idioma?: string;
  actores?: boolean | 'true' | 'false';

  jugadores?: number | null;
  tipo_sala?: string[];

  precio?: number | null;         // precio por persona
  distancia_km?: number | null;   // usado en Tab1

  // coords pueden venir como number o string via queryParams
  lat?: number | string | null;
  lng?: number | string | null;

  // mapa extra
  bbox?: string;                  // "w,s,e,n"
  radio_km?: number | string;     // opcional si decides usar c√≠rculo
}


=== app/models/sala.model.ts ===
export interface SalaCaracteristica {
  tipo: 'publico_objetivo' | 'restriccion' | 'accesibilidad' | string;
  nombre: string;
  es_apta: boolean;
}

export interface SalaImagen {
  url: string;
  tipo: 'gallery' | 'cover' | string;
}

export interface SalaPrecioPorJugadores {
  jugadores: number;
  total: string; // viene como DECIMAL en string desde la API
  pp: string;    // viene como DECIMAL en string desde la API
}

export interface Sala {
  id_sala: number;
  id_local: number;
  id_tipo_reserva?: number | null;

  nombre: string;
  descripcion?: string | null;
  tiempo?: string | number | null;
  jugadores_min?: number | null;
  jugadores_max?: number | null;
  actores?: boolean | null;
  experiencia_por_jugador?: number | string | null;
  cover_url?: string | null;
  dificultad?: string | null;
  descripcion_corta?: string | null;

  // Datos derivados/relacionados
  distancia_km?: number | null;
  precio_min_pp?: string | null;
  precio_max_pp?: string | null;
  nombre_local?: string | null;

  // Derivados solo en front
  jugadores?: string; // ej. "4 - 20"

  // Direcci√≥n
  id_direccion?: number | null;
  tipo_via?: string | null;
  nombre_via?: string | null;
  numero?: string | null;
  ampliacion?: string | null;
  codigo_postal?: string | null;
  ciudad?: string | null;
  codigo_google?: string | null;
  latitud?: number | null;
  longitud?: number | null;
  // Mapa est√°tico
  mapa_estatico_url?: string; // URL del mapa est√°tico generado en el backend
  // Empresa / reserva
  empresa?: string | null;
  tipo_reserva?: string | null;

  // Listas
  categorias?: string[];
  idiomas?: string[];
  tipo_sala?: string[];

  // Solo en detalle
  caracteristicas?: SalaCaracteristica[];
  imagenes?: SalaImagen[];
  precios_por_jugadores?: SalaPrecioPorJugadores[];
}


=== app/models/usuario.model.ts ===
export interface UsuarioStateModel {
  direccion: string | null;
  ciudad: string | null;
  lat: number | null;
  lng: number | null;
}

=== app/pipes/via-abrev.pipe.ts ===
// src/app/pipes/via-abrev.pipe.ts
import { Pipe, PipeTransform } from '@angular/core';
import { abrevTipoVia } from '../utils/sala.utils';

@Pipe({
  name: 'viaAbrev',
  standalone: true,
  pure: true
})
export class ViaAbrevPipe implements PipeTransform {
  transform(tipoVia?: string | null, fallbackOriginal: boolean = true): string | null {
    const r = abrevTipoVia(tipoVia);
    return r ?? (fallbackOriginal ? (tipoVia ?? null) : null);
  }
}


=== app/services/favoritos.service.ts ===
// src/app/services/favoritos.service.ts
import { Injectable } from '@angular/core';
import { BehaviorSubject, map } from 'rxjs';
import { Preferences } from '@capacitor/preferences';
import { STORAGE_KEYS } from '../constants/storage.keys';

@Injectable({ providedIn: 'root' })
export class FavoritosService {
  private favoritosSubject = new BehaviorSubject<number[]>([]);
  favoritos$ = this.favoritosSubject.asObservable(); // expone solo lectura

  constructor() {
    this.loadFavoritos(); // cuando se crea el servicio
  }

  private async loadFavoritos() {
    const { value } = await Preferences.get({ key: STORAGE_KEYS.FAVORITOS_SALAS });
    const ids = value ? JSON.parse(value) : [];
    this.favoritosSubject.next(ids);
  }

  async toggleFavorito(id: number) {
    const current = this.favoritosSubject.value;
    const updated = current.includes(id)
      ? current.filter(favId => favId !== id)
      : [...current, id];

    this.favoritosSubject.next(updated);
    await Preferences.set({
      key: STORAGE_KEYS.FAVORITOS_SALAS,
      value: JSON.stringify(updated)
    });
  }

  isFavorito(id: number): boolean {
    return this.favoritosSubject.value.includes(id);
  }

  getFavoritoStatusStream(id: number) {
    return this.favoritos$.pipe(
      map(favoritos => favoritos.includes(id))
    );
  }
}


=== app/services/map.service.ts ===
// src/app/services/map.service.ts
import { Injectable } from '@angular/core';
import { HttpClient, HttpParams } from '@angular/common/http';
import { Observable } from 'rxjs';
import { environment } from 'src/environments/environment';
import { FiltrosBusqueda } from '../models/filtros.model';

export interface SalaPinDTO {
  id_sala: number;
  nombre: string;
  categorias?: string[];
  latitud: number | null;
  longitud: number | null;
  ciudad: string | null;
  cover_url: string | null;
  precio_min_pp: number | null;
  distancia_km?: number | null;
  tipo_via?: string | null;
  nombre_via?: string | null;
  numero?: string | null;
  ampliacion?: string | null;
  codigo_postal?: string | null;

}

@Injectable({ providedIn: 'root' })
export class MapService {
  private baseUrl = environment.apiUrl;
  constructor(private http: HttpClient) {}

  getSalasMap(filters: FiltrosBusqueda): Observable<SalaPinDTO[]> {
    let params = new HttpParams();

    Object.entries(filters || {}).forEach(([k, v]) => {
      if (v === undefined || v === null || v === '') return;

      if (Array.isArray(v)) {
        if (v.length) params = params.set(k, v.join(','));
        return;
      }
      if (typeof v === 'boolean') {
        params = params.set(k, v ? 'true' : 'false');
        return;
      }
      // numbers o strings
      params = params.set(k, String(v));
    });

    return this.http.get<SalaPinDTO[]>(`${this.baseUrl}/salas-map`, { params });
  }
}


=== app/services/sala.service.ts ===
import { Injectable } from '@angular/core';
import { HttpClient, HttpParams } from '@angular/common/http';
import { environment } from '../../environments/environment';
import { Sala } from '../models/sala.model';
import { Observable, map } from 'rxjs';
import { enrichSala } from '../utils/sala.utils';

@Injectable({ providedIn: 'root' })
export class SalaService {
  private baseUrl = `${environment.apiUrl}/salas`;

  constructor(private http: HttpClient) {}

  getSalas(filters: any = {}): Observable<Sala[]> {
    let params = new HttpParams();
    for (const key in filters) {
      if (filters[key]) {
        params = params.set(key, filters[key]);
      }
    }
    console.log(this.http.get<Sala[]>(this.baseUrl, { params }));
     return this.http.get<Sala[]>(this.baseUrl, { params }).pipe(
      map((salas) => salas.map(enrichSala))
    );
  }
  getSalaById(id: number, lat?: number | null, lng?: number | null): Observable<Sala> {
    let params = new HttpParams();
    if (Number.isFinite(lat as number) && Number.isFinite(lng as number)) {
      params = params.set('lat', String(lat)).set('lng', String(lng));
    }
    return this.http.get<Sala>(`${this.baseUrl}/${id}`, { params });
}


}


=== app/services/socket.service.ts ===
import { Injectable } from '@angular/core';
import { environment } from '../../environments/environment';
import { io, Socket } from 'socket.io-client';
import { fromEvent, Observable } from 'rxjs';

@Injectable({ providedIn: 'root' })
export class SocketService {
  private socket: Socket;

  connect(): void {
    const baseUrl = environment.apiUrl.replace('/api', '');
    this.socket = io(baseUrl, {
      transports: ['websocket'],
      autoConnect: true
    });
  }

  listenSalasUpdated(): Observable<any> {
console.log('listenSalasUpdated CLIENT');
    return fromEvent(this.socket, 'salasUpdated');
  }
  listenSalaModificada(): Observable<any> {
    console.log('listenSalaModificada CLIENT');
  return fromEvent(this.socket, 'salaActualizada');
  }
  disconnect(): void {
    if (this.socket) {
      this.socket.disconnect();
    }
  }
}


=== app/services/ubicacion.service.ts ===
// ==============================
// üåê src/app/services/ubicacion.service.ts
// ==============================

import { Injectable } from '@angular/core';
import { HttpClient, HttpParams } from '@angular/common/http';
import { environment } from '../../environments/environment';
import { Observable } from 'rxjs';
import { tap } from 'rxjs/operators';

export interface UbicacionResultado {
  direccion: string;
  ciudad: string;
  lat: number;
  lng: number;
  // Campos opcionales (compatibilidad con backend enriquecido)
  via?: string | null;
  via_tipo?: string | null;
  via_nombre?: string | null;
  numero?: string | null;
  codigo_postal?: string | null;
  barrio?: string | null;
  provincia?: string | null;
  comunidad?: string | null;
  pais?: string | null;
  pais_code?: string | null;
  place_id?: string | null;
}

@Injectable({ providedIn: 'root' })
export class UbicacionService {
  private baseUrl = `${environment.apiUrl}/ubicacion`;
  private sessionId = UbicacionService.ensureSessionId();

  constructor(private http: HttpClient) {}

  /**
   * Autocompleta mientras se escribe.
   * Importante: NO recortamos el input; enviamos tal cual (espacio final incluido).
   * El backend har√° coalescing/debounce por sesi√≥n y token-closing.
   */
  autocomplete(input: string): Observable<string[]> {
    const params = new HttpParams().set('input', input ?? '');
    return this.http.get<string[]>(`${this.baseUrl}/autocomplete`, {
      params,
      headers: { 'X-Session-Id': this.sessionId }
    }).pipe(
      tap(predictions => this.logAutocompletePredictions(input, predictions))
    );
  }

  /** Geocodifica una direcci√≥n seleccionada */
  geocode(description: string): Observable<UbicacionResultado> {
    const params = new HttpParams().set('description', description);
    return this.http
      .get<UbicacionResultado>(`${this.baseUrl}/geocode`, {
        params,
        headers: { 'X-Session-Id': this.sessionId }
      })
      .pipe(tap((res) => this.logUbicacionResultado('geocode', res)));
  }

  /** Desde coordenadas GPS */
  reverseGeocode(lat: number, lng: number): Observable<UbicacionResultado> {
    const params = new HttpParams()
      .set('lat', String(lat))
      .set('lng', String(lng));

    return this.http
      .get<UbicacionResultado>(`${this.baseUrl}/reverse`, {
        params,
        headers: { 'X-Session-Id': this.sessionId }
      })
      .pipe(tap((res) => this.logUbicacionResultado('reverse', res)));
  }

  // ======================================
  // Utils
  // ======================================

  /** Genera/recupera un SessionId estable (persistido en localStorage) */
  private static ensureSessionId(): string {
    try {
      const key = 'ef_session_id';
      const existing = localStorage.getItem(key);
      if (existing) return existing;

      const generated = (typeof crypto !== 'undefined' && 'randomUUID' in crypto)
        ? crypto.randomUUID()
        : `${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 10)}`;

      localStorage.setItem(key, generated);
      return generated;
    } catch {
      // Fallback (SSR / private mode)
      return `${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 10)}`;
    }
  }

  // Log estructurado de todos los campos que puede devolver el backend
  private logUbicacionResultado(context: 'geocode' | 'reverse', res: UbicacionResultado) {
    try {
      console.groupCollapsed(`UbicacionService:${context} UbicacionResultado`);
      console.log('direccion:', res.direccion);
      console.log('ciudad:', res.ciudad);
      console.log('lat:', res.lat);
      console.log('lng:', res.lng);
      console.log('via:', res.via ?? null);
      console.log('via_tipo:', res.via_tipo ?? null);
      console.log('via_nombre:', res.via_nombre ?? null);
      console.log('numero:', res.numero ?? null);
      console.log('codigo_postal:', res.codigo_postal ?? null);
      console.log('barrio:', res.barrio ?? null);
      console.log('provincia:', res.provincia ?? null);
      console.log('comunidad:', res.comunidad ?? null);
      console.log('pais:', res.pais ?? null);
      console.log('pais_code:', res.pais_code ?? null);
      console.log('place_id:', res.place_id ?? null);
      console.groupEnd();
    } catch {
      console.log(`UbicacionService:${context} UbicacionResultado:`, res);
    }
  }

  // Log de predicciones de autocompletado
  private logAutocompletePredictions(input: string, predictions: string[]) {
    try {
      console.groupCollapsed(`UbicacionService:autocomplete [${input}]`);
      console.log('Input:', input);
      console.log('Cantidad de predicciones:', predictions.length);
      console.log('Predicciones:', predictions);
      console.groupEnd();
    } catch {
      console.log(`UbicacionService:autocomplete [${input}]`, predictions);
    }
  }
}


=== app/states/usuario.state.ts ===
// src/app/states/usuario/usuario.state.ts
import { State, Action, StateContext, Selector } from '@ngxs/store';
import { UsuarioStateModel } from '../models/usuario.model';

export class SetUbicacionUsuario {
  static readonly type = '[Usuario] Set Ubicacion';
  constructor(public payload: { direccion: string, ciudad: string, lat: number, lng: number }) {}
}

export class ClearUbicacionUsuario {
  static readonly type = '[Usuario] Clear Ubicacion';
}



@State<UsuarioStateModel>({
  name: 'usuario',
  defaults: {
    direccion: null,
    ciudad: null,
    lat: null,
    lng: null
  }
})
export class UsuarioState {
  @Selector()
  static ubicacion(state: UsuarioStateModel) {
    return {
      direccion: state.direccion,
      ciudad: state.ciudad,
      lat: state.lat,
      lng: state.lng
    };
  }

  @Action(SetUbicacionUsuario)
  setUbicacion(ctx: StateContext<UsuarioStateModel>, action: SetUbicacionUsuario) {
    ctx.patchState({
      ...action.payload
    });
  }

  @Action(ClearUbicacionUsuario)
  clearUbicacion(ctx: StateContext<UsuarioStateModel>) {
    ctx.setState({
      direccion: null,
      ciudad: null,
      lat: null,
      lng: null
    });
  }

}

=== app/tab1/tab1-routing.module.ts ===
import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';
import { Tab1Page } from './tab1.page';

const routes: Routes = [
  {
    path: '',
    component: Tab1Page,
  }
];

@NgModule({
  imports: [RouterModule.forChild(routes)],
  exports: [RouterModule]
})
export class Tab1PageRoutingModule {}


=== app/tab1/tab1.module.ts ===
import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { IonicModule } from '@ionic/angular';
import { Tab1Page } from './tab1.page';
import { Tab1PageRoutingModule } from './tab1-routing.module';

import { HttpClientModule } from '@angular/common/http'; // üî• IMPORTANTE
import { SalaCardComponent } from '../components/sala-card/sala-card.component';
import { DireccionPickerComponent } from '../components/direccion-picker/direccion-picker.component';
import { FiltersModalComponent } from '../components/filter-modal/filters-modal.component';

@NgModule({
  declarations: [Tab1Page],
  imports: [
    CommonModule,
    FormsModule,
    IonicModule,
    Tab1PageRoutingModule,
    FiltersModalComponent ,
    HttpClientModule, // üí• A√±ade esto si no estaba
    SalaCardComponent,
    DireccionPickerComponent

  ]
})
export class Tab1PageModule {}


=== app/tab1/tab1.page.html ===
<ion-header class="ion-no-border">
  <div class="top-actions">
    <app-direccion-picker (ciudadSeleccionada)="onCiudadSeleccionada($event)"></app-direccion-picker>
    <ion-button fill="clear" size="small" class="btn-notificaciones" (click)="onNotificacionesClick()">
      <ion-icon name="notifications-outline"></ion-icon>
    </ion-button>
  </div>
</ion-header>

<ion-content #pageContent scrollEvents="true" (ionScroll)="onScroll($event)">

  <!-- Overlay transparente que impide el scroll (touch + wheel) cuando no hay salas -->
  <div class="no-scroll-overlay" *ngIf="numeroSalas === 0" (wheel)="$event.preventDefault()"></div>

  <!-- Header colapsable pegajoso -->
  <div #collapsible class="collapsible">
    <div class="collapsible-inner">
      <ion-toolbar>
        <div class="searchbar-con-boton">
          <ion-searchbar
            placeholder="Buscar sala o empresa..."
            [(ngModel)]="filters.query"
            (ionInput)="reloadSalas()"
            debounce="300"
            showCancelButton="never"
            animated>
          </ion-searchbar>

          <ion-button fill="clear" size="small" class="btn-filtros" (click)="openFilters()">
            <ion-icon name="options-outline"></ion-icon>
            <span *ngIf="filtrosActivos > 0" class="reset-btn__badge">{{ filtrosActivos }}</span>
          </ion-button>

          <ion-button fill="clear" size="small" class="btn-mapa" (click)="onMapaClick()">
            <ion-icon name="map-outline"></ion-icon>
          </ion-button>
        </div>

        <div class="categorias-scroll">
          <div
            class="categoria-item"
            *ngFor="let cat of categorias"
            [class.active]="categoriasActivas.includes(cat.valor)"
            (click)="selectCategoria(cat.valor)">
            <img [src]="cat.icono" alt="{{ cat.nombre }}" />
            <div class="nombre">{{ cat.nombre }}</div>
          </div>
        </div>
      </ion-toolbar>
    </div>
  </div>

  <!-- üëá Spacer que s√≠ cambia de altura (empuja las cards) -->


  <!-- Lista de salas -->
  <ng-container *ngIf="salas$ | async as salas">
    <ng-container *ngIf="salas.length > 0; else noResultados">
      <app-sala-card
        class="sala-card"
        *ngFor="let sala of salas; trackBy: trackBySalaId"
        [sala]="sala"
        (open)="abrirSalaDetalle($event)">
      </app-sala-card>
    </ng-container>
  </ng-container>

  <ng-template #noResultados>
    <div class="no-resultados-wrapper">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
           stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="no-resultados-icono">
        <path d="m13.5 8.5-5 5" />
        <path d="m8.5 8.5 5 5" />
        <circle cx="11" cy="11" r="8" />
        <path d="m21 21-4.3-4.3" />
      </svg>
    </div>
  </ng-template>

  <ion-infinite-scroll threshold="100px" (ionInfinite)="loadMore($event)" *ngIf="!todasCargadas">
    <ion-infinite-scroll-content loadingSpinner="bubbles" loadingText="Cargando m√°s salas...">
    </ion-infinite-scroll-content>
  </ion-infinite-scroll>
</ion-content>


=== app/tab1/tab1.page.scss ===
/* ====== Header fijo (fila superior) ====== */
/* Header fijo (fila superior) */
.top-actions {
  display: grid;
  grid-template-columns: 1fr auto; /* la direcci√≥n ocupa todo; la campana queda al borde */
  align-items: center;
  column-gap: 8px;
  padding: 0 8px;

  /* el picker puede crecer y tambi√©n encogerse sin romper el layout */
  app-direccion-picker {
    min-width: 0; /* clave para que el texto no fuerce overflow del grid */
  }

  .btn-notificaciones {
    width: 32px;
    height: 32px;
    min-width: 32px;
    margin: 0;
    justify-self: end; /* al borde derecho */
    --padding-start: 0;
    --padding-end: 0;
    --border-radius: 12px;
    font-size: 20px;
  }
}

/* ====== Bloque colapsable pegajoso dentro del CONTENT ====== */

/* Contenedor pegajoso del header (NO tiene fondo) */
.collapsible {
  position: sticky;
  top: var(--ion-safe-area-top, 0);
  z-index: 1000;
  overflow: hidden;
  background: transparent;
  height: auto;            /* TS la fija a px */
  pointer-events: none;
}

/* El que se mueve: usa transform 3D y aisla repaints */
.collapsible-inner {
  will-change: transform;
  transform: translate3d(0, calc(-1 * var(--header-offset, 0px)), 0);
  backface-visibility: hidden;
  contain: paint;
  background: var(--ion-background-color, #fff);
  box-shadow: 0 2px 10px rgba(0,0,0,0.06);
  pointer-events: auto;
  border-bottom: 1px solid rgba(0,0,0,0.06);
}

/* ====== Searchbar + botones (tus estilos) ====== */
ion-searchbar {
  --background: #f1f1f1;
  --border-radius: 16px;
  --box-shadow: none;
  --padding-start: 12px;
  --padding-end: 12px;
  --placeholder-color: #999;

  margin: 12px auto 0 auto;
  max-width: 100%;
  height: 40px;
  --height: 40px;

  input {
    font-size: 14px;
  }
}

.searchbar-con-boton {
  display: flex;
  align-items: center;
  padding: 0 8px;
  gap: 6px;

  ion-searchbar {
    flex: 1;
    margin: 12px 0 0 0;
    max-width: calc(100% - 96px); // 2 botones de 48px
  }

  ion-button {
    margin-top: 12px;
    width: 40px;
    height: 40px;
    min-width: 40px;
    --padding-start: 0;
    --padding-end: 0;
  }

  .btn-filtros {
    --color: var(--ion-color-success);
    --border-radius: 12px;
    font-size: 20px;
    position: relative;
    --overflow: visible !important; 
  }

  .btn-mapa {
    --color: #3399ff;
    --border-radius: 12px;
    font-size: 20px;
  }
}

/* ====== Categor√≠as (tus estilos) ====== */
.categorias-scroll {
  display: flex;
  overflow-x: auto;
  padding: 10px 0;
  gap: 14px;
  margin-bottom: 8px;
  padding-left: 12px;
  scroll-snap-type: x mandatory;

  &::-webkit-scrollbar {
    display: none;
  }
}

.categoria-item {
  position: relative;
  display: flex;
  flex-direction: column;
  align-items: center;
  min-width: 70px;
  cursor: pointer;
  opacity: 0.6;
  scroll-snap-align: start;
  transition: opacity 0.2s ease, transform 0.2s ease;
  user-select: none;

  &.active {
    opacity: 1;
    transform: rotate(5deg) scale(1.05);
  }

  &.active::after {
    content: '';
    position: absolute;
    top: -6px;
    left: 6px;
    width: 56px;
    height: 56px;
    background: #a2e3b1;
    border-radius: 50% 40% 50% 60% / 60% 50% 40% 50%;
    z-index: 1;
    filter: blur(2px);
    opacity: 0.6;
    transition: all 0.3s ease;
  }

  img {
    width: 40px;
    height: 40px;
    border-radius: 10px;
    object-fit: cover;
    transition: box-shadow 0.3s ease;
    z-index: 2;
  }

  .nombre {
    margin-top: 3px;
    font-size: 12px;
    text-align: center;
    font-weight: 500;
    color: #333;
    z-index: 2;
  }
}

/* ====== Varios (tuyos, sin cambios) ====== */
.spinner-global {
  display: flex;
  justify-content: center;
  align-items: center;
  height: 80vh;
}

.oculto { display: none; }

.no-resultados-wrapper {
  height: 100%;
  width: 100%;
  background-color: #e5f9e7;
  display: flex;
  justify-content: center;
  align-items: center;
  overflow: hidden;
  flex: 1;
}

.no-scroll-overlay {
  position: absolute;
  inset: 0; /* cubrir todo el ion-content */
  /* debe quedar POR DEBAJO del header colapsable (z-index: 1000) para permitir clicks en √©l */
  z-index: 900;
  background: transparent;
  touch-action: none; /* evita gestos t√°ctiles */
}

.no-resultados-icono {
  width: 50vw;
  height: auto;
  max-width: 280px;
  stroke: #34a853;
}

ion-content {
  --padding-bottom: 0;
  --padding-top: 0;
  height: 100%;
  --background: #f8f9fa url("data:image/svg+xml,%3Csvg width='20' height='20' viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='%23dce1e6' fill-opacity='0.4' fill-rule='evenodd'%3E%3Ccircle cx='3' cy='3' r='3'/%3E%3Ccircle cx='13' cy='13' r='3'/%3E%3C/g%3E%3C/svg%3E");
}

ion-content::part(scroll) {
  overscroll-behavior-y: contain;
  scrollbar-gutter: stable;
}

.reset-btn__badge {
  position: absolute;
  top: -4px;
  right: -4px;
  min-width: 18px;
  height: 18px;
  padding: 0 4px;
  border-radius: 999px;
  background: var(--ion-color-danger);
  color: #fff;
  font-size: 11px;
  font-weight: 600;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 2px 4px rgba(0,0,0,0.25);
  transition: transform 180ms ease, opacity 180ms ease;
}


=== app/tab1/tab1.page.ts ===
import { Component, OnInit, OnDestroy, ViewChild, AfterViewInit, ElementRef, ChangeDetectorRef } from '@angular/core';
import { Store } from '@ngxs/store';
import { ModalController, IonContent } from '@ionic/angular';
import { GetSalas, AppendSalas, SalaState, UpdateSala } from '../states/salas/salas.state';
import { SocketService } from '../services/socket.service';
import { FiltersModalComponent } from '../components/filter-modal/filters-modal.component';
import { Haptics, ImpactStyle } from '@capacitor/haptics';
import { CATEGORIAS } from '../constants/categorias.const';
import { Subscription } from 'rxjs';
import { UsuarioState } from '../states/usuario.state';
import { filter } from 'rxjs/operators';
import { Router, NavigationStart, NavigationEnd } from '@angular/router';
import { ChangeDetectionStrategy } from '@angular/core';


@Component({
  selector: 'app-tab1',
  templateUrl: './tab1.page.html',
  styleUrls: ['./tab1.page.scss'],
  changeDetection: ChangeDetectionStrategy.OnPush,
  standalone: false
})
export class Tab1Page implements OnInit, OnDestroy, AfterViewInit {
  categorias = CATEGORIAS;
  salas$ = this.store.select(SalaState.salas);
  filters: any = {};
  categoriasActivas: string[] = [];
  numeroSalas = 0;

  private subs: Subscription[] = [];
  private navSub?: Subscription;

  @ViewChild(IonContent) pageContent!: IonContent;
  @ViewChild('collapsible', { static: false }) collapsibleRef!: ElementRef<HTMLDivElement>;

  private latUsuario: number | null = null;
  private lngUsuario: number | null = null;

  limit = 20;
  offset = 0;
  todasCargadas = false;
  cargando = false;

  // Header (modo Œî)
  private maxCollapse = 0;
  private headerOffset = 0;
  private lastScrollTop = 0;
  private raf = false;
  private ro?: ResizeObserver;
  private scrollEl!: HTMLElement;

  // Estado guardado al salir
  private savedScrollTop = 0;
  private savedHeaderOffset = 0;
  private ignoreNextDelta = false;
  modalController: any;

  constructor(
    private store: Store,
    private socketService: SocketService,
    private modalCtrl: ModalController,
    private router: Router,
    private cdr: ChangeDetectorRef // üëà Agregado para updates manuales
  ) {}

  ngOnInit() {
    // ‚úÖ Los observables funcionan bien con OnPush
    this.subs.push(
      this.salas$.subscribe(salas => {
        this.numeroSalas = salas.length;
        this.cdr.markForCheck(); // üëà Marca para check manual
      })
    );

    this.subs.push(
      this.store.select(UsuarioState.ubicacion).subscribe(ubicacion => {
        const { ciudad, lat, lng } = ubicacion || {};
        this.latUsuario = lat ?? null;
        this.lngUsuario = lng ?? null;
        
        if (ciudad) {
          // ‚úÖ Crear nuevo objeto en lugar de mutar
          this.filters = { ...this.filters, ciudad };
        } else {
          const { ciudad: _c, ...rest } = this.filters;
          this.filters = { ...rest };
        }
        this.cdr.markForCheck(); // üëà Marca para check manual
      })
    );

    this.socketService.connect();
    
    this.subs.push(
      this.socketService.listenSalasUpdated().subscribe(() => {
        this.reloadSalas();
        this.cdr.markForCheck(); // üëà Marca para check manual
      })
    );

    this.subs.push(
      this.socketService.listenSalaModificada().subscribe(sala => {
        if (this.aplicaFiltros(sala)) {
          this.store.dispatch(new UpdateSala(sala));
          this.cdr.markForCheck(); // üëà Marca para check manual
        }
      })
    );

    const existing = this.store.selectSnapshot(SalaState.salas);
    if (!existing || existing.length === 0) this.reloadSalas();

    // Navigation handling
    this.navSub = this.router.events
      .pipe(filter(e => e instanceof NavigationStart || e instanceof NavigationEnd))
      .subscribe(async e => {
        if (e instanceof NavigationStart) {
          if (this.router.url.startsWith('/tabs/tab1')) {
            await this.ensureScrollEl();
            this.savedScrollTop = this.scrollEl?.scrollTop || 0;
            this.savedHeaderOffset = this.headerOffset;
          }
        } else {
          const url = (e as NavigationEnd).urlAfterRedirects || '';
          if (url.startsWith('/tabs/tab1')) {
            await this.ensureScrollEl();
            this.measureAndFixHeaderHeight();

            const y = Math.max(0, this.savedScrollTop);
            requestAnimationFrame(() => {
              this.scrollEl.scrollTop = y;
              requestAnimationFrame(() => {
                this.scrollEl.scrollTop = y;
                this.lastScrollTop = y;
                this.headerOffset = this.clamp(this.savedHeaderOffset);
                this.setHeaderOffsetVar(this.headerOffset);
                this.ignoreNextDelta = true;
                this.cdr.markForCheck(); // üëà Marca para check manual
              });
            });
          }
        }
      });
  }

  async ngAfterViewInit() {
    await this.waitForToolbarReady();
    this.scrollEl = await this.pageContent.getScrollElement();

    this.measureAndFixHeaderHeight();

    const y = this.scrollEl.scrollTop || 0;
    this.lastScrollTop = y;
    this.headerOffset = this.clamp(this.headerOffset);
    this.setHeaderOffsetVar(this.headerOffset);

    const el = this.collapsibleRef?.nativeElement;
    if (el && 'ResizeObserver' in window) {
      this.ro = new ResizeObserver(() => {
        const visibleAntes = Math.max(0, this.maxCollapse - this.headerOffset);
        this.measureAndFixHeaderHeight();
        const visibleDespues = Math.max(0, Math.min(visibleAntes, this.maxCollapse));
        this.headerOffset = this.clamp(this.maxCollapse - visibleDespues);
        this.setHeaderOffsetVar(this.headerOffset);
        this.cdr.markForCheck(); // üëà Marca para check manual
      });
      this.ro.observe(el);
    }
  }

  ngOnDestroy() {
    this.navSub?.unsubscribe();
    this.subs.forEach(s => s.unsubscribe());
    this.socketService.disconnect();
    if (this.ro) { 
      try { this.ro.disconnect(); } catch {} 
      this.ro = undefined; 
    }
  }

  // ===== Scroll handling =====
  onScroll(ev: any) {
    if (!this.maxCollapse) return;

    const y = ev?.detail?.scrollTop ?? 0;

    if (this.ignoreNextDelta) {
      this.lastScrollTop = y;
      this.ignoreNextDelta = false;
      return;
    }

    let dy = y - this.lastScrollTop;
    this.lastScrollTop = y;

    if (Math.abs(dy) < 0.5) return;

    let next = this.headerOffset + dy;
    if (y <= 0) next = 0;
    next = this.clamp(next);

    if (!this.raf) {
      this.raf = true;
      requestAnimationFrame(() => {
        this.headerOffset = next;
        this.setHeaderOffsetVar(this.headerOffset);
        this.raf = false;
      });
    } else {
      this.headerOffset = next;
    }
  }

  // ===== Utility methods =====
  private clamp(v: number) { 
    return Math.max(0, Math.min(this.maxCollapse, Math.round(v))); 
  }

  private async waitForToolbarReady() {
    if ('customElements' in window && (customElements as any).whenDefined) {
      try { await (customElements as any).whenDefined('ion-toolbar'); } catch {}
    }
    const toolbar = this.collapsibleRef?.nativeElement?.querySelector('ion-toolbar') as any;
    if (toolbar?.componentOnReady) { 
      try { await toolbar.componentOnReady(); } catch {} 
    }
    await new Promise<void>(r => requestAnimationFrame(() => r()));
  }

  private async ensureScrollEl() {
    if (!this.scrollEl) {
      await this.waitForToolbarReady();
      this.scrollEl = await this.pageContent.getScrollElement();
    }
  }

  private measureAndFixHeaderHeight() {
    const el = this.collapsibleRef?.nativeElement;
    if (!el) return;

    el.style.height = 'auto';
    let h = el.scrollHeight || el.getBoundingClientRect().height || 0;
    if (h < 1) h = 120;
    this.maxCollapse = Math.ceil(h);

    el.style.height = `${this.maxCollapse}px`;
    this.headerOffset = this.clamp(this.headerOffset);
    this.setHeaderOffsetVar(this.headerOffset);
  }

  private setHeaderOffsetVar(px: number) {
    const el = this.collapsibleRef?.nativeElement;
    if (!el) return;
    el.style.setProperty('--header-offset', `${px}px`);
  }

  // ===== Business logic methods =====
  async selectCategoria(valor: string) {
    if (valor === 'Filtros') { 
      await this.openFilters(); 
      return; 
    }
    
    const index = this.categoriasActivas.indexOf(valor);
    
    // ‚úÖ Crear nuevo array en lugar de mutar
    if (index > -1) {
      this.categoriasActivas = this.categoriasActivas.filter((_, i) => i !== index);
    } else {
      this.categoriasActivas = [...this.categoriasActivas, valor];
    }

    // ‚úÖ Crear nuevo objeto de filtros
    this.filters = this.categoriasActivas.length === 0
      ? { ...this.filters, categorias: undefined }
      : { ...this.filters, categorias: [...this.categoriasActivas] };

    await Haptics.impact({ style: ImpactStyle.Light });
    this.reloadSalas();
    this.cdr.markForCheck(); // üëà Marca para check manual
  }

  async openFilters() {
    const modal = await this.modalCtrl.create({
      component: FiltersModalComponent,
      componentProps: { filtrosActuales: this.filters },
      showBackdrop: true,
      cssClass: 'filters-modal-sheet',
      breakpoints: [0, 0.5, 1],
      initialBreakpoint: 1
    });

    await modal.present();
    const { data } = await modal.onDidDismiss();
    
    if (data) {
      // ‚úÖ Crear nuevos objetos
      this.filters = { ...this.filters, ...data };
      this.categoriasActivas = this.filters.categorias ? [...this.filters.categorias] : [];
      this.reloadSalas();
      this.cdr.markForCheck(); // üëà Marca para check manual
    }
  }

  onCiudadSeleccionada(ciudad: string | null) {
    if (ciudad) {
      this.filters = { ...this.filters, ciudad };
    } else {
      const { ciudad: _c, distancia_km: _d, coordenadas: _coords, ...rest } = this.filters;
      this.filters = { ...rest };
    }
    this.reloadSalas();
    this.cdr.markForCheck(); // üëà Marca para check manual
  }

  aplicaFiltros(sala: any): boolean {
    const q = this.filters.query?.toLowerCase() || '';
    const nombre = sala.nombre?.toLowerCase() || '';
    const empresa = sala.empresa?.toLowerCase() || '';
    if (q && !nombre.includes(q) && !empresa.includes(q)) return false;
    
    if (this.filters.categorias?.length > 0) {
      const categorias = sala.categorias || [];
      const intersecta = categorias.some(c => this.filters.categorias.includes(c));
      if (!intersecta) return false;
    }
    return true;
  }

  private getFiltros(offset: number): any {
    const filtros = { ...this.filters, offset, limit: this.limit };
    if (!filtros.distancia_km) { 
      delete filtros.lat; 
      delete filtros.lng; 
    } else { 
      filtros.lat = this.latUsuario; 
      filtros.lng = this.lngUsuario; 
    }
    return filtros;
  }

  reloadSalas() {
    this.pageContent?.scrollToTop(0);
    this.headerOffset = 0;
    this.setHeaderOffsetVar(0);
    this.lastScrollTop = 0;
    this.savedScrollTop = 0;
    this.savedHeaderOffset = 0;

    this.offset = 0;
    this.todasCargadas = false;
    this.cargando = true;

    const filtros = this.getFiltros(0);
    this.store.dispatch(new GetSalas(filtros)).subscribe({
      next: () => { 
        this.offset = this.limit; 
        this.cargando = false; 
        this.cdr.markForCheck(); // üëà Marca para check manual
      },
      error: (err) => { 
        this.cargando = false; 
        console.error('Error al cargar salas', err); 
        this.cdr.markForCheck(); // üëà Marca para check manual
      }
    });
  }

  loadMore(event?: any) {
    if (this.cargando || this.todasCargadas) { 
      event?.target?.complete(); 
      return; 
    }
    
    this.cargando = true;
    this.cdr.markForCheck(); // üëà Marca para check manual

    const filtros = this.getFiltros(this.offset);
    this.store.dispatch(new AppendSalas(filtros)).subscribe((res: any) => {
      const recibidas = res.sala?.cantidad || 0;
      this.offset += recibidas;
      if (recibidas === 0 || recibidas < this.limit) {
        this.todasCargadas = true;
      }
      event?.target?.complete();
      this.cargando = false;
      this.cdr.markForCheck(); // üëà Marca para check manual
    });
  }

  trackBySalaId(_i: number, sala: any): any { 
    return sala.id_sala; 
  }

  onMapaClick() {
    // Lee los filtros actuales de tu UI/estado de la lista y p√°salos tal cual como queryParams
    // Ejemplo m√≠nimo: si guardas filtros en this.filters
    const params = { ...this.filters };

    const distanciaActiva =
      params.distancia_km != null && params.distancia_km !== '' ? Number(params.distancia_km) :
      params.distancia != null && params.distancia !== '' ? Number(params.distancia) : null;

    if (distanciaActiva !== null && Number.isFinite(distanciaActiva)) {
      if (this.latUsuario != null && this.lngUsuario != null) {
        params.lat = this.latUsuario;
        params.lng = this.lngUsuario;
      } else if (this.filters?.lat != null && this.filters?.lng != null) {
        params.lat = this.filters.lat;
        params.lng = this.filters.lng;
      }
    }

    delete (params as any).coordenadas;

    this.router.navigate(['/mapa'], { queryParams: params });
    console.log('üó∫Ô∏è Click en bot√≥n de mapa (a implementar)');
  }

  onNotificacionesClick() { 
    console.log('üîî Notificaciones clickeadas'); 
  }

  get filtrosActivos(): number {
    const { ciudad, query, ...rest } = this.filters;
    let total = 0;
    Object.values(rest).forEach(value => {
      if (Array.isArray(value)) {
        total += value.length;
      } else if (value !== undefined && value !== null && value !== '' && value !== false) {
        total += 1;
      }
    });
    return total;
  }

  abrirSalaDetalle(id: number) {
    this.router.navigate(['/sala', id]);
  }
}

=== app/tab2/tab2-routing.module.ts ===
import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';
import { Tab2Page } from './tab2.page';

const routes: Routes = [
  {
    path: '',
    component: Tab2Page,
  }
];

@NgModule({
  imports: [RouterModule.forChild(routes)],
  exports: [RouterModule]
})
export class Tab2PageRoutingModule {}


=== app/tab2/tab2.module.ts ===
import { IonicModule } from '@ionic/angular';
import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { Tab2Page } from './tab2.page';
import { ExploreContainerComponentModule } from '../explore-container/explore-container.module';

import { Tab2PageRoutingModule } from './tab2-routing.module';

@NgModule({
  imports: [
    IonicModule,
    CommonModule,
    FormsModule,
    ExploreContainerComponentModule,
    Tab2PageRoutingModule
  ],
  declarations: [Tab2Page]
})
export class Tab2PageModule {}


=== app/tab2/tab2.page.html ===
<ion-header [translucent]="true">
  <ion-toolbar>
    <ion-title>
      Tab 2
    </ion-title>
  </ion-toolbar>
</ion-header>

<ion-content>
  <ion-header collapse="condense">
    <ion-toolbar>
      <ion-title size="large">Tab 2 Prueba2</ion-title>
    </ion-toolbar>
  </ion-header>

  <app-explore-container name="Tab 2 page Prueba2"></app-explore-container>
</ion-content>


=== app/tab2/tab2.page.scss ===


=== app/tab2/tab2.page.spec.ts ===
import { ComponentFixture, TestBed } from '@angular/core/testing';
import { IonicModule } from '@ionic/angular';

import { ExploreContainerComponentModule } from '../explore-container/explore-container.module';

import { Tab2Page } from './tab2.page';

describe('Tab2Page', () => {
  let component: Tab2Page;
  let fixture: ComponentFixture<Tab2Page>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      declarations: [Tab2Page],
      imports: [IonicModule.forRoot(), ExploreContainerComponentModule]
    }).compileComponents();

    fixture = TestBed.createComponent(Tab2Page);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});


=== app/tab2/tab2.page.ts ===
import { Component } from '@angular/core';

@Component({
  selector: 'app-tab2',
  templateUrl: 'tab2.page.html',
  styleUrls: ['tab2.page.scss'],
  standalone: false,
})
export class Tab2Page {

  constructor() {
    console.log("Pagina2")
  }

}


=== app/tab3/tab3-routing.module.ts ===
import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';
import { Tab3Page } from './tab3.page';

const routes: Routes = [
  {
    path: '',
    component: Tab3Page,
  }
];

@NgModule({
  imports: [RouterModule.forChild(routes)],
  exports: [RouterModule]
})
export class Tab3PageRoutingModule {}


=== app/tab3/tab3.module.ts ===
import { IonicModule } from '@ionic/angular';
import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { Tab3Page } from './tab3.page';
import { ExploreContainerComponentModule } from '../explore-container/explore-container.module';

import { Tab3PageRoutingModule } from './tab3-routing.module';

@NgModule({
  imports: [
    IonicModule,
    CommonModule,
    FormsModule,
    ExploreContainerComponentModule,
    Tab3PageRoutingModule
  ],
  declarations: [Tab3Page]
})
export class Tab3PageModule {}


=== app/tab3/tab3.page.html ===
<ion-header [translucent]="true">
  <ion-toolbar>
    <ion-title>
      Tab 3
    </ion-title>
  </ion-toolbar>
</ion-header>

<ion-content>
  <ion-header collapse="condense">
    <ion-toolbar>
      <ion-title size="large">Tab 3</ion-title>
    </ion-toolbar>
  </ion-header>

  <app-explore-container name="Tab 3 page"></app-explore-container>
</ion-content>


=== app/tab3/tab3.page.scss ===


=== app/tab3/tab3.page.spec.ts ===
import { ComponentFixture, TestBed } from '@angular/core/testing';
import { IonicModule } from '@ionic/angular';

import { ExploreContainerComponentModule } from '../explore-container/explore-container.module';

import { Tab3Page } from './tab3.page';

describe('Tab3Page', () => {
  let component: Tab3Page;
  let fixture: ComponentFixture<Tab3Page>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      declarations: [Tab3Page],
      imports: [IonicModule.forRoot(), ExploreContainerComponentModule]
    }).compileComponents();

    fixture = TestBed.createComponent(Tab3Page);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});


=== app/tab3/tab3.page.ts ===
import { Component } from '@angular/core';

@Component({
  selector: 'app-tab3',
  templateUrl: 'tab3.page.html',
  styleUrls: ['tab3.page.scss'],
  standalone: false,
})
export class Tab3Page {

  constructor() {
    console.log("Pagina3")
  }

}


=== app/tabs/tabs-routing.module.ts ===
import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';
import { TabsPage } from './tabs.page';

const routes: Routes = [
  {
    path: '',
    component: TabsPage,
    children: [
      {
        path: 'tab1',
        loadChildren: () => import('../tab1/tab1.module').then(m => m.Tab1PageModule)
      },
      {
        path: 'tab2',
        loadChildren: () => import('../tab2/tab2.module').then(m => m.Tab2PageModule)
      },
      {
        path: 'tab3',
        loadChildren: () => import('../tab3/tab3.module').then(m => m.Tab3PageModule)
      },
      {
        path: '',
        redirectTo: '/tabs/tab1',
        pathMatch: 'full'
      }
    ]
  },
  {
    path: '',
    redirectTo: '/tabs/tab1',
    pathMatch: 'full'
  }
];

@NgModule({
  imports: [RouterModule.forChild(routes)],
  exports: [RouterModule] // <--- FALTA ESTO
})
export class TabsPageRoutingModule {}


=== app/tabs/tabs.module.ts ===
import { IonicModule } from '@ionic/angular';
import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';

import { TabsPageRoutingModule } from './tabs-routing.module';

import { TabsPage } from './tabs.page';

@NgModule({
  imports: [
    IonicModule,
    CommonModule,
    FormsModule,
    TabsPageRoutingModule
  ],
  declarations: [TabsPage]
})
export class TabsPageModule {}


=== app/tabs/tabs.page.html ===
<ion-tabs>

  <ion-tab-bar slot="bottom">
    <ion-tab-button tab="tab1" href="/tabs/tab1">
      <ion-icon name="key-outline"></ion-icon>
      <ion-label>Salas</ion-label>
    </ion-tab-button>

    <ion-tab-button tab="tab2" href="/tabs/tab2">
      <ion-icon name="ellipse"></ion-icon>
      <ion-label>Tab 2</ion-label>
    </ion-tab-button>

    <ion-tab-button tab="tab3" href="/tabs/tab3">
      <ion-icon name="square"></ion-icon>
      <ion-label>Tab 3</ion-label>
    </ion-tab-button>
  </ion-tab-bar>
</ion-tabs>


=== app/tabs/tabs.page.scss ===



=== app/tabs/tabs.page.spec.ts ===
import { CUSTOM_ELEMENTS_SCHEMA } from '@angular/core';
import { ComponentFixture, TestBed } from '@angular/core/testing';

import { TabsPage } from './tabs.page';

describe('TabsPage', () => {
  let component: TabsPage;
  let fixture: ComponentFixture<TabsPage>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      declarations: [TabsPage],
      schemas: [CUSTOM_ELEMENTS_SCHEMA],
    }).compileComponents();
  });

  beforeEach(() => {
    fixture = TestBed.createComponent(TabsPage);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});


=== app/tabs/tabs.page.ts ===
import { Component } from '@angular/core';

@Component({
  selector: 'app-tabs',
  templateUrl: 'tabs.page.html',
  styleUrls: ['tabs.page.scss'],
  standalone: false,
})
export class TabsPage {

  constructor() {}

}


=== app/utils/sala.utils.ts ===
import { Sala } from '../models/sala.model';

/**
 * Enriches a Sala with a formatted jugadores string
 * combining jugadores_min and jugadores_max.
 */
export function enrichSala(sala: Sala): Sala {
  return {
    ...sala,
    jugadores: `${sala.jugadores_min} - ${sala.jugadores_max}`
  };
}

/**
 * Utilidades para abreviar tipos de v√≠a y construir etiquetas de direcci√≥n.
 * - Normaliza (lower + sin acentos) para buscar en el diccionario.
 * - Devuelve el original si no hay match (no rompe datos).
 * - Cobertura ES/CAT/GL/EU + variantes y abreviaturas comunes.
 */

export function norm(str: string): string {
  return (str || '')
    .normalize('NFD')
    .replace(/[\u0300-\u036f]/g, '')
    .toLowerCase()
    .trim();
}

/**
 * Diccionario de tipos de v√≠a -> abreviatura
 * Las CLAVES deben ir normalizadas (sin acentos y en min√∫sculas).
 */
const MAP: Record<string, string> = {
  // --- Castellano ---
  'calle': 'C.',
  'c/': 'C.',
  'c.': 'C.',
  'avenida': 'Av.',
  'av': 'Av.',
  'av.': 'Av.',
  'plaza': 'Pl.',
  'pza': 'Pl.',
  'pza.': 'Pl.',
  'paseo': 'P.¬∫',
  'pso': 'P.¬∫',
  'p.': 'P.¬∫',
  'carretera': 'Ctra.',
  'ctra': 'Ctra.',
  'ctra.': 'Ctra.',
  'camino': 'Cno.',
  'cno': 'Cno.',
  'cno.': 'Cno.',
  'travesia': 'Trv.',
  'traves√≠a': 'Trv.',
  'trva': 'Trv.',
  'trva.': 'Trv.',
  'ronda': 'Rda.',
  'glorieta': 'Gta.',
  'pasaje': 'Pje.',
  'callejon': 'Clj.',
  'callej√≥n': 'Clj.',
  'bulevar': 'Blvr.',
  'bulebard': 'Blvr.',
  'urbanizacion': 'Urb.',
  'urbanizaci√≥n': 'Urb.',
  'poligono': 'Pol.',
  'pol√≠gono': 'Pol.',
  'via': 'V√≠a',
  'via pecuaria': 'V√≠a Pec.',
  'costanilla': 'Cta.',
  'cuesta': 'Cta.',
  'barrio': 'B.¬∫',
  'barriada': 'Bda.',
  'vereda': 'Ver.',
  'parque': 'Pq.',
  'parc': 'Pq.',

  // --- Catal√°n / Valenciano ---
  'carrer': 'C.',
  'avinguda': 'Av.',
  'passeig': 'Pg.',
  'pg.': 'Pg.',
  'pla√ßa': 'Pl.',
  'placa': 'Pl.',
  'travessera': 'Trv.',
  'travessia': 'Trv.',
  'rambla': 'Rbla.',
  'cam√≠': 'Cno.',
  'cami': 'Cno.',
  'ronda (cat)': 'Rda.', // a veces llega ya como ‚ÄúRonda‚Äù

  // --- Gallego ---
  'rua': 'R.',
  'r√∫a': 'R.',
  'praza': 'Pza.',
  'estrada': 'Estr.',
  'carreiro': 'Crro.',
  'cami√±o': 'Cno.',
  'camino (gl)': 'Cno.',

  // --- Euskera (formas m√°s habituales que vemos en datos biling√ºes) ---
  'kalea': 'K.',
  'hiribidea': 'Hbda.',     // (avda.)
  'etorbidea': 'Etorb.',    // (avda.)
  'plaza (eu)': 'Pl.',      // muchos datos ya vienen en castellano
  'pasealekua': 'P.¬∫',
};

/**
 * Abrevia un tipo de v√≠a. Si no hay match, devuelve el original.
 */
export function abrevTipoVia(raw?: string | null): string | null {
  if (!raw) return null;
  const v = norm(raw);
  return MAP[v] ?? raw;
}

/**
 * Construye la etiqueta compacta para mostrar en UI:
 *   "<abrev tipo> <nombre> <numero> ¬∑ <ciudad>"
 * Evita repetir ciudad si ya viene embebida en la v√≠a.
 */
export function buildDireccionLabel(
  tipo_via?: string | null,
  nombre_via?: string | null,
  numero?: string | null,
  ciudad?: string | null
): string | null {
  const tv = abrevTipoVia(tipo_via?.trim() || null);
  const via = [tv, nombre_via?.trim(), numero?.trim()]
    .filter(Boolean)
    .join(' ')
    .replace(/\s+/g, ' ')
    .trim();

  const c = (ciudad || '').trim();
  if (via && c) return via.includes(c) ? via : `${via} ¬∑ ${c}`;
  return via || c || null;
}

=== app/states/salas/salas.actions.ts ===
export class GetSalas {
  static readonly type = '[Sala] Get';
  constructor(public filters: any = {}) {}
}

=== app/states/salas/salas.state.ts ===
import { State, Action, StateContext, Selector } from '@ngxs/store';
import { Injectable } from '@angular/core';
import { SalaService } from 'src/app/services/sala.service';
import { Sala } from 'src/app/models/sala.model';
import { map, tap } from 'rxjs/operators';
import { enrichSala } from 'src/app/utils/sala.utils';

export class GetSalas {
  static readonly type = '[Sala] Get';
  constructor(public filtros?: any) {}
}

export class AppendSalas {
  static readonly type = '[Sala] Append';
  constructor(public filtros?: any) {}
}

export class UpdateSala {
  static readonly type = '[Sala] Update';
  constructor(public sala: Sala) {}
}

export interface SalaStateModel {
  salas: Sala[];
  cantidad: number;
}

@State<SalaStateModel>({
  name: 'sala',
  defaults: {
    salas: [],
    cantidad: 30
  }
})
@Injectable()
export class SalaState {
  constructor(private salaService: SalaService) {}

  @Selector()
  static salas(state: SalaStateModel) {
    return state.salas;
  }

  // üîÑ Acci√≥n normal: sobrescribe salas
@Action(GetSalas)
getSalas({ patchState }: StateContext<SalaStateModel>, { filtros }: GetSalas) {
  return this.salaService.getSalas(filtros).pipe(
    tap((salas) => {
      console.log('üì• GetSalas recibi√≥ del servicio:', salas.length);
       //console.log('Filros antes de backend  ' + filtros.jugadores) 
      patchState({ salas });
    }),
    map((salas) => {
      console.log('üì§ Devolviendo desde GetSalas a componente:', salas.length);
      // console.log('Filros antes de backend  ' + filtros.jugadores) 
      return { salas };
    })
  );
}

  // ‚ûï Acci√≥n nueva: a√±ade salas al final (scroll infinito)
@Action(AppendSalas)
appendSalas({ getState, patchState }: StateContext<SalaStateModel>, { filtros }: AppendSalas) {
  return this.salaService.getSalas(filtros).pipe(
    tap((salas) => {
      const state = getState();
      patchState({ salas: [...state.salas, ...salas], cantidad: salas.length  });
    }),
    map((salas) => {
      return { cantidad: getState().cantidad};
    })
  );
}

    
@Action(UpdateSala)
updateSala({ patchState, getState }: StateContext<SalaStateModel>, { sala }: UpdateSala) {
  const enriched = enrichSala(sala);
  const salas = getState().salas.map(s =>
    s.id_sala === enriched.id_sala ? enriched : s
  );
  patchState({ salas });
}
}


=== app/pages/mapa/mapa-routing.module.ts ===
import { NgModule } from '@angular/core';
import { Routes, RouterModule } from '@angular/router';

import { MapaPage } from './mapa.page';

const routes: Routes = [
  {
    path: '',
    component: MapaPage
  }
];

@NgModule({
  imports: [RouterModule.forChild(routes)],
  exports: [RouterModule],
})
export class MapaPageRoutingModule {}


=== app/pages/mapa/mapa.module.ts ===
import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { IonicModule } from '@ionic/angular';
import { MapaPage } from './mapa.page';
import { RouterModule, Routes } from '@angular/router';
import { SalaMiniCardComponent } from 'src/app/components/sala-mini-card/sala-mini-card.component';

const routes: Routes = [{ path: '', component: MapaPage }];

@NgModule({
  imports: [CommonModule, FormsModule, IonicModule, RouterModule.forChild(routes), SalaMiniCardComponent],
  declarations: [MapaPage]
})
export class MapaPageModule {}

=== app/pages/mapa/mapa.page.html ===
<ion-header class="page-mapa">
  <ion-toolbar>
    <ion-buttons slot="start">
      <ion-back-button defaultHref="/" text="Volver"></ion-back-button>
    </ion-buttons>
    <ion-title>Mapa</ion-title>
  </ion-toolbar>
</ion-header>


<ion-content fullscreen class="page-mapa" [scrollY]="false">
  <div class="map-wrap">
    <div id="map"></div>
    <div class="carousel">
      <div class="carousel-track" tabindex="0">
        <div
          class="carousel-slide"
          *ngFor="let s of salas"
          [class.selected]="s.id_sala === selectedId"
          [attr.data-sala-id]="s.id_sala"
        >
          <div class="slide-content">
            <ion-button
              *ngIf="s.id_sala === selectedId"
              class="go-to-room-btn"
              fill="solid"
              size="small"
              type="button"
              (click)="irASala(s.id_sala, $event)"
            >
              Ir a la sala
              <ion-icon slot="end" name="arrow-forward-outline"></ion-icon>
            </ion-button>
            <app-sala-mini-card
              [sala]="s"
              (focusSala)="onCardFocus($event)"
            ></app-sala-mini-card>
          </div>
        </div>
      </div>
    </div>
  </div>
</ion-content>

=== app/pages/mapa/mapa.page.scss ===
:host {
  display: block;
  height: 100%;
}

ion-content.page-mapa {
  --padding-top: 0 !important;
  --padding-bottom: 0 !important;
  --offset-top: 0 !important;
  --offset-bottom: 0 !important;
  --overflow: hidden;
  --background: #f4f5f8;

  height: 100%;
}

.map-wrap {
  position: relative;
  display: flex;
  flex-direction: column;
  height: 100%;
  width: 100%;
}

#map {
  position: relative;
  flex: 1 1 auto;
  width: 100%;
  min-height: 320px;
  background: #e0e4eb;
  border-radius: 0;
  overflow: hidden;
}

.carousel {
  position: absolute;
  left: 0;
  right: 0;
  bottom: calc(var(--ion-safe-area-bottom, 0px) + 12px);
  padding: clamp(16px, 5vw, 36px) 12px;
  z-index: 401;
  pointer-events: none;
  background: linear-gradient(180deg, rgba(0, 0, 0, 0) 0%, rgba(0, 0, 0, 0.25) 45%, rgba(0, 0, 0, 0.35) 100%);
}

.carousel-track {
  display: flex;
  align-items: flex-end;
  justify-content: flex-start; // Cambiado de center a flex-start
  gap: clamp(10px, 2.8vw, 20px);
  overflow-x: auto;
  overflow-y: visible !important;
  padding: clamp(10px, 2.4vw, 20px) clamp(6px, 4vw, 20px);
  scroll-snap-type: x proximity;
  -webkit-overflow-scrolling: touch;
  overscroll-behavior-x: contain;
  pointer-events: auto;
  scrollbar-width: none;
}

.carousel-track::-webkit-scrollbar {
  display: none;
}

.carousel-slide {
  flex: 0 0 auto;
  scroll-snap-align: center;
  display: flex;
  align-items: center;
  justify-content: center;
}

.carousel-slide .slide-content {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: clamp(8px, 2vw, 14px);
}

ion-button.go-to-room-btn {
  align-self: center;
  pointer-events: auto;
  margin-bottom: clamp(2px, 1.6vw, 10px);
  width: clamp(150px, 70%, 240px);
  --border-radius: 999px;
  --background: linear-gradient(135deg, #5b21b6 0%, #7c3aed 100%);
  --background-hover: linear-gradient(135deg, #4c1d95 0%, #6d28d9 100%);
  --color: #ffffff;
  --padding-start: clamp(14px, 3vw, 20px);
  --padding-end: clamp(14px, 3vw, 20px);
  --padding-top: clamp(8px, 2vw, 12px);
  --padding-bottom: clamp(8px, 2vw, 12px);
  font-weight: 600;
  letter-spacing: 0.02em;
  text-transform: none;
  font-size: clamp(13px, 2.6vw, 15px);
  box-shadow: 0 14px 32px rgba(79, 70, 229, 0.28);
  transition: transform 180ms ease, box-shadow 180ms ease;
}

.carousel-slide.selected ion-button.go-to-room-btn {
  transform: translateY(-2px);
  box-shadow: 0 18px 38px rgba(79, 70, 229, 0.36);
}

ion-button.go-to-room-btn ion-icon {
  font-size: 18px;
  margin-left: 4px;
}

:host ::ng-deep .ef-marker-icon {
  background: transparent;
  border: none;
}

:host ::ng-deep .ef-marker {
  position: relative;
  width: 30px;
  height: 42px;
  display: flex;
  align-items: center;
  justify-content: center;
}

:host ::ng-deep .ef-marker__pin {
  width: 36px;
  height: 52px;
  background: url('/assets/icon/marker-escape-purple.svg') center/contain no-repeat;
  
}

:host ::ng-deep .ef-marker__badge {
  position: absolute;
  top: 0;
  right: -6px;
  min-width: 18px;
  height: 18px;
  padding: 0 5px;
  border-radius: 12px;
  background: #2563eb;
  color: #ffffff;
  font-size: 12px;
  font-weight: 700;
  line-height: 18px;
  text-align: center;
  box-shadow: 0 2px 4px rgba(15, 23, 42, 0.25);
}

:host ::ng-deep .ef-popup {
  min-width: 200px;
  max-width: 240px;
  font-size: 14px;
  color: #1f2937;
}

:host ::ng-deep .ef-popup__title {
  font-weight: 700;
  margin-bottom: 8px;
}

:host ::ng-deep .ef-popup__list {
  list-style: none;
  margin: 0;
  padding: 0;
  display: flex;
  flex-direction: column;
  gap: 6px;
  max-height: 220px;
  overflow: auto;
}

:host ::ng-deep .ef-popup__list li {
  padding: 6px 8px;
  border-radius: 8px;
  background: #f8fafc;
  cursor: pointer;
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 8px;
  transition: background 0.2s ease, color 0.2s ease;
}

:host ::ng-deep .ef-popup__list li:hover,
:host ::ng-deep .ef-popup__list li:focus {
  background: #e0f2fe;
  color: #0f172a;
}

:host ::ng-deep .ef-popup__name {
  font-weight: 600;
  flex: 1;
}

:host ::ng-deep .ef-popup__distance {
  font-size: 12px;
  color: #475569;
}

@media (min-width: 768px) {
  ion-content.page-mapa {
    --background: #ffffff;
  }

  .carousel {
    left: 0;
    right: 0;
    width: min(100%, 880px);
    margin: 0 auto;
    bottom: 28px;
    border-radius: 16px;
    padding: 36px 32px;
  }

  .carousel-track {
    gap: 24px;
    padding: 20px 32px;
    max-width: min(100%, 880px);
    margin: 0 auto;
  }
}


@media (min-width: 1024px) {
  .carousel {
    width: min(100%, 1040px);
    bottom: 36px;
    padding: 40px 40px;
    border-radius: 20px;
  }

  .carousel-track {
    gap: 28px;
    padding: 24px 40px;
    max-width: min(100%, 1040px);
  }
}


=== app/pages/mapa/mapa.page.ts ===
import { Component, OnDestroy, OnInit, NgZone, AfterViewInit } from '@angular/core';
import { ActivatedRoute, Router } from '@angular/router';
import * as L from 'leaflet';
import { Subject, Subscription } from 'rxjs';
import { debounceTime } from 'rxjs/operators';
import { MapService, SalaPinDTO } from 'src/app/services/map.service';
import { environment } from 'src/environments/environment';
import { FiltrosBusqueda } from 'src/app/models/filtros.model';

@Component({
  selector: 'app-mapa',
  templateUrl: './mapa.page.html',
  styleUrls: ['./mapa.page.scss'],
  standalone: false
})
export class MapaPage implements OnInit, AfterViewInit, OnDestroy {
  salas: SalaPinDTO[] = [];
  selectedId: number | null = null;
  filtros: FiltrosBusqueda = {};

  private map!: L.Map;
  private gruposPorCoord = new Map<string, SalaPinDTO[]>();
  private markersPorGrupo = new Map<string, L.Marker>();
  private moveEnd$ = new Subject<void>();
  private subs: Subscription[] = [];
  private hasFetchedOnce = false;
  private markerIcon!: L.Icon;
  private selectedMarkerIcon!: L.Icon;

  constructor(
    private route: ActivatedRoute,
    private router: Router,
    private mapService: MapService,
    private zone: NgZone
  ) {}

  ngOnInit(): void {
    // Lee filtros del querystring y normaliza
    this.subs.push(
      this.route.queryParams.subscribe((qp: any) => {
        const f: FiltrosBusqueda = { ...qp };

        const ensureArray = (v: any): string[] | undefined => {
          if (v === undefined || v === null || v === '') return undefined;
          if (Array.isArray(v)) return v;
          if (typeof v === 'string') return v.split(',').map(s => s.trim()).filter(Boolean);
          return undefined;
        };

        f.categorias = ensureArray(qp.categorias);
        f.dificultad = ensureArray(qp.dificultad);
        f.accesibilidad = ensureArray(qp.accesibilidad);
        f.restricciones_aptas = ensureArray(qp.restricciones_aptas);
        f.publico_objetivo = ensureArray(qp.publico_objetivo);
        f.tipo_sala = ensureArray(qp.tipo_sala);

        if (qp.actores !== undefined) {
          f.actores = qp.actores === true || qp.actores === 'true';
        }

        const toNum = (v: any): number | null => {
          const n = Number(v);
          return Number.isFinite(n) ? n : null;
        };

        f.jugadores = toNum(qp.jugadores);
        f.precio = toNum(qp.precio);
        f.distancia_km = toNum(qp.distancia_km);

        f.lat = qp.lat !== undefined ? (typeof qp.lat === 'string' ? Number(qp.lat) : qp.lat) : null;
        f.lng = qp.lng !== undefined ? (typeof qp.lng === 'string' ? Number(qp.lng) : qp.lng) : null;

        f.ciudad = qp.ciudad ? String(qp.ciudad).trim() : undefined;
        f.idioma = qp.idioma ? String(qp.idioma).trim() : undefined;
        f.query = qp.query ? String(qp.query) : undefined;

        this.filtros = f;
      })
    );

    this.subs.push(this.moveEnd$.pipe(debounceTime(400)).subscribe(() => this.fetchByViewport()));
  }

  ngAfterViewInit(): void {
    this.setMapContainerSize();
    this.initMap();
    setTimeout(() => this.map?.invalidateSize(), 0);
    window.addEventListener('resize', this._onResize, { passive: true });
  }

  ngOnDestroy(): void {
    this.subs.forEach(s => s.unsubscribe());
    this.moveEnd$.complete();
    if (this.map) this.map.remove();
    window.removeEventListener('resize', this._onResize);
  }

  private _onResize = () => {
    this.setMapContainerSize();
     if (this.map) {
      this.map.invalidateSize();
      this.createMarkerIcons();
      this.renderMarkers();
    }
  };

  private setMapContainerSize() {
    const mapEl = document.getElementById('map') as HTMLElement | null;
    if (!mapEl) return;

    const headerEl = document.querySelector('ion-header.page-mapa') as HTMLElement | null;
    const tabsEl = document.querySelector('ion-tab-bar[slot="bottom"]') as HTMLElement | null;

    const safeTop = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--ion-safe-area-top')) || 0;
    const safeBottom = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--ion-safe-area-bottom')) || 0;

    const headerH = headerEl ? Math.round(headerEl.getBoundingClientRect().height) : 0;
    const tabsH   = tabsEl   ? Math.round(tabsEl.getBoundingClientRect().height)   : 0;

    const targetHeight = window.innerHeight - headerH - tabsH - safeTop - safeBottom;
    mapEl.style.height = `${Math.max(200, targetHeight)}px`;
    mapEl.style.width = '100%';
  }

  private initMap() {
    if (this.map) return;
  this.createMarkerIcons();


    const lat0 = Number(this.filtros.lat) || 40.4168;
    const lng0 = Number(this.filtros.lng) || -3.7038;
    const zoom = this.filtros.ciudad ? 12 : 13;

    this.map = L.map('map', {
      zoomControl: false,
      attributionControl: true,
      maxBoundsViscosity: 1.0
    }).setView([lat0, lng0], zoom);

    const tiles = L.tileLayer(environment.tilesUrl, {
      attribution: environment.tilesAttribution,
      maxZoom: 19
    }).addTo(this.map);

    tiles.on('load', () => this.map.invalidateSize());

    this.map.on('moveend', () => this.moveEnd$.next());

    if (this.filtros.ciudad) {
      this.fetch({ ...this.filtros });
    } else if (this.filtros.lat != null && this.filtros.lng != null) {
      const base: FiltrosBusqueda = { ...this.filtros };
      if (!base.distancia_km && !base.bbox && !base.radio_km) {
        base.radio_km = 7;
      }
      this.fetch(base);
    } else {
      this.fetchByViewport();
    }
  }
  private createMarkerIcons() {
    const width = window.innerWidth || 0;
    const isTabletOrDesktop = width >= 768;

    const iconSize = isTabletOrDesktop ? [54, 74] : [34, 50];
    const selectedIconSize = isTabletOrDesktop ? [66, 90] : [44, 64];
    console.log("tama√±o iconos", iconSize, selectedIconSize);
    const iconAnchor: L.PointTuple = [Math.round(iconSize[0] / 2), iconSize[1]];
    const selectedIconAnchor: L.PointTuple = [Math.round(selectedIconSize[0] / 2), selectedIconSize[1]];

    const shadowScale = isTabletOrDesktop ? 1.2 : 1.0;
    const baseShadow = Math.round(40 * shadowScale);
    const baseShadowSize: L.PointTuple = [baseShadow, baseShadow];
    const selectedShadow = Math.round(baseShadow * 1.15);

    this.markerIcon = L.icon({
      iconUrl: 'assets/icon/marker-escape-purple.svg',
      iconRetinaUrl: 'assets/icon/marker-escape-purple.svg',
      shadowUrl: 'assets/icon/marker-shadow.png',
      iconSize,
      iconAnchor,
      popupAnchor: [1, -Math.round(iconSize[1] * 0.65)],
      shadowSize: baseShadowSize
    });

    this.selectedMarkerIcon = L.icon({
      iconUrl: 'assets/icon/marker-escape-purple-selected.svg',
      iconRetinaUrl: 'assets/icon/marker-escape-purple-selected.svg',
      shadowUrl: 'assets/icon/marker-shadow.png',
      iconSize: selectedIconSize,
      iconAnchor: selectedIconAnchor,
      popupAnchor: [1, -Math.round(selectedIconSize[1] * 0.74)],
      shadowSize: [selectedShadow, selectedShadow]
    });
  }

  private getBBoxQuery() {
    const b = this.map.getBounds();
    const w = b.getWest();
    const s = b.getSouth();
    const e = b.getEast();
    const n = b.getNorth();
    return `${w.toFixed(6)},${s.toFixed(6)},${e.toFixed(6)},${n.toFixed(6)}`;
  }

  private fetchByViewport() {
    const bbox = this.getBBoxQuery();
    const center = this.map.getCenter();
    const lat = Number(center.lat.toFixed(6));
    const lng = Number(center.lng.toFixed(6));
    const params: FiltrosBusqueda = { ...this.filtros, lat, lng, bbox };
    this.fetch(params);
  }

  private fetch(params: FiltrosBusqueda) {
    if (this.hasFetchedOnce) {
      return;
    }
    this.hasFetchedOnce = true;
    this.mapService.getSalasMap(params).subscribe({
      next: (rows) => {
        this.zone.run(() => {
          this.salas = rows || [];
          this.rebuildGruposPorCoord();
          this.renderMarkers();
        });
      },
      error: (err) => {
        console.error('Error cargando salas del mapa', err);
      }
    });
  }

  private renderMarkers() {
    if (!this.map || !this.markerIcon) return;

    const keysActuales = new Set(this.gruposPorCoord.keys());
    for (const [key, marker] of this.markersPorGrupo.entries()) {
      if (!keysActuales.has(key)) {
        marker.removeFrom(this.map);
        this.markersPorGrupo.delete(key);
      }
    }

    for (const [key, salasDelGrupo] of this.gruposPorCoord.entries()) {
      if (!salasDelGrupo.length) continue;
      const [latStr, lngStr] = key.split(',');
      const lat = Number(latStr);
      const lng = Number(lngStr);
      if (!Number.isFinite(lat) || !Number.isFinite(lng)) continue;

      let marker = this.markersPorGrupo.get(key);
      const count = salasDelGrupo.length;
      const posicion = L.latLng(lat, lng);

      const isSelected = this.selectedId != null && salasDelGrupo.some(s => s.id_sala === this.selectedId);

      if (!marker) {
        marker = L.marker(posicion, { icon: isSelected ? this.selectedMarkerIcon : this.markerIcon }).addTo(this.map);
        this.markersPorGrupo.set(key, marker);
      } else {
        marker.setLatLng(posicion);
        marker.setIcon(isSelected ? this.selectedMarkerIcon : this.markerIcon);
      }

      const markerRef = marker;
      if (!markerRef) continue;

      markerRef.off('click');
      markerRef.off('popupopen');
      markerRef.off('popupclose');
      markerRef.unbindPopup();

      markerRef.setZIndexOffset(isSelected ? 1000 : 0);

      if (count === 1) {
        markerRef.on('click', () => this.onMarkerClick(salasDelGrupo[0].id_sala));
      } else {
        const salasOrdenadas = [...salasDelGrupo].sort((a, b) => (a.nombre || '').localeCompare(b.nombre || ''));
        const popupHtml = this.buildPopupContent(salasOrdenadas);
        markerRef.bindPopup(popupHtml, { closeButton: true, maxWidth: 260 });

        markerRef.on('popupopen', (event: L.PopupEvent) => {
          const popupEl = event.popup.getElement();
          if (!popupEl) return;
          const listEl = popupEl.querySelector('.ef-popup__list');
          if (!listEl) return;

          const handleClick = (ev: Event) => {
            const target = ev.target as HTMLElement | null;
            const item = target?.closest('li[data-id-sala]') as HTMLElement | null;
            if (!item) return;
            const idSala = Number(item.dataset["idSala"]);
            if (!Number.isFinite(idSala)) return;
            markerRef.closePopup();
            this.onMarkerClick(idSala);
          };

          listEl.addEventListener('click', handleClick);

          markerRef.once('popupclose', () => {
            listEl.removeEventListener('click', handleClick);
          });
        });
      }
    }

    this.updateMapBounds();
    
    // Centrar la primera card al cargar inicialmente
    if (this.salas.length > 0 && !this.selectedId) {
      setTimeout(() => this.centerFirstCard(), 100);
    }
  }

  private rebuildGruposPorCoord() {
    this.gruposPorCoord.clear();
    for (const sala of this.salas) {
      if (typeof sala.latitud !== 'number' || typeof sala.longitud !== 'number') continue;
      const key = this.coordKey(sala.latitud, sala.longitud);
      const grupo = this.gruposPorCoord.get(key);
      if (grupo) {
        grupo.push(sala);
      } else {
        this.gruposPorCoord.set(key, [sala]);
      }
    }
  }

  private coordKey(lat: number, lng: number): string {
    const latRounded = lat.toFixed(6);
    const lngRounded = lng.toFixed(6);
    return `${latRounded},${lngRounded}`;
  }

  private buildPopupContent(salas: SalaPinDTO[]): string {
    const ciudades = new Set(
      salas
        .map(s => (s.ciudad ? s.ciudad.trim() : ''))
        .filter(Boolean)
    );

    const tieneCiudadUnica = ciudades.size === 1;
    const ciudad = tieneCiudadUnica ? Array.from(ciudades)[0] : null;
    const titulo = ciudad ? `Salas en esta ubicaci√≥n ‚Äì ${ciudad}` : 'Salas en esta ubicaci√≥n';

    const items = salas
      .map(s => {
        const distancia = typeof s.distancia_km === 'number' ? `${s.distancia_km.toFixed(1)} km` : '';
        return `
          <li data-id-sala="${s.id_sala}">
            <span class="ef-popup__name">${s.nombre}</span>
            ${distancia ? `<span class="ef-popup__distance">${distancia}</span>` : ''}
          </li>
        `;
      })
      .join('');

    return `
      <div class="ef-popup">
        <div class="ef-popup__title">${titulo}</div>
        <ul class="ef-popup__list">${items}</ul>
      </div>
    `;
  }

  private updateMapBounds() {
    if (!this.map) return;

    const coords = this.salas
      .filter(s => typeof s.latitud === 'number' && typeof s.longitud === 'number')
      .map(s => L.latLng(s.latitud!, s.longitud!));

    if (!coords.length) {
      this.map.setMaxBounds(null as unknown as L.LatLngBoundsExpression);
      return;
    }

    const bounds = L.latLngBounds(coords);
    const paddedBounds = bounds.pad(1.0);
    this.map.setMaxBounds(paddedBounds);

    if (!paddedBounds.contains(this.map.getCenter())) {
      this.map.panInsideBounds(paddedBounds, { animate: false });
    }
  }

  onMarkerClick(id: number) {
    this.selectedId = id;
    this.centerCardInCarousel(id);
    this.renderMarkers();
  }

  onCardFocus(id: number) {
    this.selectedId = id;
    this.centerCardInCarousel(id);
    const s = this.salas.find(x => x.id_sala === id);
    if (s?.latitud && s?.longitud) {
      this.map.panTo([s.latitud, s.longitud], { animate: true });
    }
    this.renderMarkers();
  }

  irASala(id: number, event?: Event) {
    event?.stopPropagation();
    if (id == null) {
      return;
    }
    if (this.selectedId !== id) {
      this.selectedId = id;
    }
    this.router.navigate(['/sala', id]);
  }


  private centerFirstCard() {
    const track = document.querySelector<HTMLElement>('.carousel-track');
    if (!track) return;
    track.scrollTo({ left: 0, behavior: 'auto' });
  }

  private centerCardInCarousel(id: number, behavior: ScrollBehavior = 'smooth') {
    // Esperar a que Angular renderice la card
    setTimeout(() => {
      requestAnimationFrame(() => {
        const track = document.querySelector<HTMLElement>('.carousel-track');
        const slide = document.querySelector<HTMLElement>(`.carousel-slide[data-sala-id="${id}"]`);
        
        if (!track || !slide) {
          console.warn(`No se encontr√≥ la card para la sala ${id}`);
          return;
        }

        const slideRect = slide.getBoundingClientRect();
        const trackRect = track.getBoundingClientRect();
        const currentScroll = track.scrollLeft;
        const desiredScroll =
          currentScroll + (slideRect.left - trackRect.left) - (trackRect.width - slideRect.width) / 2;
        const maxScroll = track.scrollWidth - track.clientWidth;
        const normalizedScroll = Math.max(0, Math.min(desiredScroll, maxScroll));

        track.scrollTo({ left: normalizedScroll, behavior });
      });
    }, 50);
  }
}


=== app/pages/sala-detalle/sala-detalle-routing.module.ts ===
import { NgModule } from '@angular/core';
import { Routes, RouterModule } from '@angular/router';

import { SalaDetallePage } from './sala-detalle.page';

const routes: Routes = [
  {
    path: '',
    component: SalaDetallePage
  }
];

@NgModule({
  imports: [RouterModule.forChild(routes)],
  exports: [RouterModule],
})
export class SalaDetallePageRoutingModule {}


=== app/pages/sala-detalle/sala-detalle.module.ts ===
import { NgModule, CUSTOM_ELEMENTS_SCHEMA } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { IonicModule } from '@ionic/angular';
import { RouterModule, Routes } from '@angular/router';
import { SalaDetallePage } from './sala-detalle.page';


const routes: Routes = [{ path: '', component: SalaDetallePage }];

@NgModule({
  imports: [CommonModule, FormsModule, IonicModule, RouterModule.forChild(routes)],
  declarations: [SalaDetallePage],
  schemas: [CUSTOM_ELEMENTS_SCHEMA] 
})
export class SalaDetallePageModule {}


=== app/pages/sala-detalle/sala-detalle.page.html ===
<ion-content [fullscreen]="true" class="detalle-content">

  <!-- Volver -->
  <button class="btn-back" (click)="volver()" aria-label="Volver">
    <ion-icon name="chevron-back-outline"></ion-icon>
  </button>

  <!-- Skeleton estructura -->
  <ng-container *ngIf="cargandoDatos">
    <div class="skel slide"></div>
    <div class="skel title"></div>
    <div class="skel text"></div>
    <div class="skel text small"></div>
    <div class="skel chips"></div>
    <div class="skel map"></div>
    <div class="footer-gap"></div>
  </ng-container>

  <ng-container *ngIf="!cargandoDatos && sala">

    <!-- Slide Swiper (cover primero; overlay hasta galer√≠a lista) -->
<!-- Slide Swiper (cover primero; overlay hasta galer√≠a lista) -->
<div class="slide-wrapper">
  <!-- Gradiente inferior para dar contraste al h√©roe -->
  <div class="hero-gradient"></div>

  <!-- Shimmer mientras a√∫n no est√° toda la galer√≠a -->
  <div class="slide-overlay" *ngIf="!galleryReady"></div>

  <!-- Favorito igual que en la card -->
  <ion-icon
    [name]="isFavorito ? 'heart' : 'heart-outline'"
    class="favorite-icon"
    (click)="toggleFavorito($event)">
  </ion-icon>

  <swiper-container
    slides-per-view="1"
    pagination="true"
    navigation="false"
    loop="false"
    resistance-ratio="0.85"
    style="width: 100%; height: 100%;"
  >
    <swiper-slide *ngFor="let src of displayedImgs; let i = index; trackBy: trackByUrl">
      <img
        [src]="src"
        alt="Imagen de la sala"
        [attr.loading]="i === 0 ? 'eager' : 'lazy'"
        decoding="async"
        [attr.fetchpriority]="i === 0 ? 'high' : null"
      />
    </swiper-slide>
  </swiper-container>
</div>
    <!-- T√≠tulo + empresa -->
    <section class="section">
      <h1>{{ sala.nombre }}</h1>
      <div class="empresa">{{ sala.empresa || sala.nombre_local }}</div>
    </section>

    <!-- Descripci√≥n -->
    <div class="section" *ngIf="sala as s">
      <div class="descripcion-wrapper" [class.expanded]="descExpanded" *ngIf="s.descripcion">
        <p class="descripcion-text" #descRef>{{ s.descripcion }}</p>
        <div class="fade-shadow" *ngIf="!descExpanded && isDescOverflow"></div>
      </div>

      <div *ngIf="isDescOverflow" class="ver-mas-ctr">
        <ion-button fill="outline"
                    size="small"
                    (click)="toggleDescripcion()"
                    class="btn-ver-mas"
                    [attr.aria-expanded]="descExpanded">
          {{ descExpanded ? 'Ver menos' : 'Ver m√°s' }}
          <ion-icon slot="end" [name]="descExpanded ? 'chevron-up-outline' : 'chevron-down-outline'"></ion-icon>
        </ion-button>
      </div>
    </div>

 <!-- Caracter√≠sticas principales (sin chips) -->
<section class="section keyfacts" *ngIf="sala as s">
  <div class="facts-grid">
    <div class="fact" *ngIf="s.jugadores_min || s.jugadores_max">
      <div class="icon"><ion-icon name="people-outline"></ion-icon></div>
      <div class="content">
        <div class="label">Jugadores</div>
        <div class="value">{{ s.jugadores_min }}‚Äì{{ s.jugadores_max }}</div>
      </div>
    </div>

    <div class="fact" *ngIf="s.tiempo">
      <div class="icon"><ion-icon name="time-outline"></ion-icon></div>
      <div class="content">
        <div class="label">Duraci√≥n</div>
        <div class="value">{{ s.tiempo }} min</div>
      </div>
    </div>

    <div class="fact" *ngIf="s.dificultad">
      <div class="icon"><ion-icon name="barbell-outline"></ion-icon></div>
      <div class="content">
        <div class="label">Dificultad</div>
        <div class="value">{{ s.dificultad }}</div>
      </div>
    </div>

    <div class="fact" *ngIf="s.categorias?.length">
      <div class="icon"><ion-icon name="pricetag-outline"></ion-icon></div>
      <div class="content">
        <div class="label">Categor√≠as</div>
        <div class="value value-multiline">{{ s.categorias!.join(', ') }}</div>
      </div>
    </div>
  </div>
</section>


    <!-- Precio -->
    <section class="section pricing-section" *ngIf="tienePrecioPP">
      <div class="price-range-header" *ngIf="sala.precio_min_pp || sala.precio_max_pp">
        <div class="price-pill min">
          <span class="label">M√≠n</span>
          <span class="value">{{ sala.precio_min_pp || sala.precio_max_pp }} ‚Ç¨</span>
        </div>
        <div class="price-pill max">
          <span class="label">M√°x</span>
          <span class="value">{{ sala.precio_max_pp || sala.precio_min_pp }} ‚Ç¨</span>
        </div>
      </div>

      <div class="pp-table" *ngIf="sala.precios_por_jugadores?.length">
        <div class="pp-row header">
          <span>Jugadores</span>
          <span>‚Ç¨/persona</span>
        </div>
        <div class="pp-row"
             *ngFor="let p of (priceTableExpanded ? sala.precios_por_jugadores : (sala.precios_por_jugadores | slice:0:6))">
          <span>{{ p.jugadores }}</span>
          <span>{{ p.pp }}</span>
        </div>
      </div>

      <div *ngIf="hasPriceOverflow" class="ver-mas-ctr price-more-btn">
        <ion-button fill="outline"
                    size="small"
                    class="btn-ver-mas"
                    (click)="togglePriceTable()"
                    [attr.aria-expanded]="priceTableExpanded">
          {{ priceTableExpanded ? 'Ver menos' : 'Ver m√°s' }}
          <ion-icon slot="end"
                    [name]="priceTableExpanded ? 'chevron-up-outline' : 'chevron-down-outline'"></ion-icon>
        </ion-button>
      </div>
    </section>

    <!-- Secundarias -->
    <section class="section secondary">
      <div class="sec-line" *ngIf="sala.tipo_sala?.length">
        <ion-icon name="home-outline"></ion-icon><span>{{ sala.tipo_sala!.join(', ') }}</span>
      </div>
      <div class="sec-line" *ngIf="sala.idiomas?.length">
        <ion-icon name="language-outline"></ion-icon><span>{{ sala.idiomas!.join(', ') }}</span>
      </div>
      <div class="sec-line" *ngIf="sala.actores !== null && sala.actores !== undefined">
        <ion-icon name="person-outline"></ion-icon><span>{{ sala.actores ? 'Actores en vivo' : 'Sin actores' }}</span>
      </div>

      <!-- ACCESIBILIDADES: una por l√≠nea con icono -->
      <ng-container *ngIf="accesibilidades?.length">
        <div class="sec-line" *ngFor="let acc of accesibilidades">
          <ion-icon [name]="getAccIcon(acc)"></ion-icon>
          <span>{{ acc }}</span>
        </div>
      </ng-container>
    </section>

       <!-- Mapa (placeholder) -->
    <section class="section ubicacion-section">
      <div class="section-title-row">
        <h3 class="section-title">Ubicaci√≥n de la sala</h3>
        <div class="distancia-usuario" *ngIf="distanciaKm !== null">
          <ion-icon name="location-outline"></ion-icon>
          <span>
            {{ distanciaKm < 1 ? ((distanciaKm * 1000) | number:'1.0-0') + ' m' : (distanciaKm | number:'1.0-1') + ' km' }}
          </span>
        </div>
      </div>

      <!-- Mapa est√°tico (si hay URL), con fallback al placeholder -->
      <div class="map-container" *ngIf="sala?.mapa_estatico_url; else noMap">
        <img class="map-img" 
             [src]="sala.mapa_estatico_url.startsWith('http') ? sala.mapa_estatico_url : baseUrl + sala.mapa_estatico_url" 
             alt="Mapa de {{ sala?.nombre }}" 
             decoding="async" 
             loading="lazy"
             (click)="abrirEnMapas($event)" />
      </div>
      <ng-template #noMap>
        <div class="map-placeholder"></div>
      </ng-template>
      <div class="direccion-text" *ngIf="sala?.nombre_via">
        {{ sala?.tipo_via }} {{ sala?.nombre_via }} {{ sala?.numero }},
        {{ sala?.ciudad }} {{ sala?.codigo_postal }}
      </div>

      <!-- Bot√≥n sutil para abrir en mapas -->
      <div class="ubicacion-actions" *ngIf="sala?.nombre_via">
        <ion-button class="btn-abrir-mapas"
                    fill="outline"
                    size="small"
                    (click)="abrirEnMapas($event)">
          <ion-icon name="map-outline" slot="start"></ion-icon>
          C√≥mo llegar
        </ion-button>
      </div>
    </section>

    <div class="footer-gap"></div>
  </ng-container>
</ion-content>

<ion-footer class="footer-reserva">
  <ion-toolbar>
    <ion-button expand="block" color="success" size="large">
      ¬°Reservar tu aventura!
    </ion-button>
  </ion-toolbar>
</ion-footer>

=== app/pages/sala-detalle/sala-detalle.page.scss ===
/* =========================
   Layout base / contenido
   ========================= */
.detalle-content {
  --padding-top: 0;
  --padding-bottom: calc(env(safe-area-inset-bottom) + 80px);
  background: #fff;

  /* Paleta marr√≥n + tipograf√≠a */
  --ef-font-stack: "Inter", ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI",
                   Roboto, "Helvetica Neue", "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji";
  --ef-brown-900: #4E342E;
  --ef-brown-800: #5D4037; /* t√≠tulo */
  --ef-brown-700: #6D4C41;

  --ef-title-color: var(--ef-brown-800);
  --ef-meta-color:  #6B7280; /* GRIS como antes */
}

/* =========================
   Bot√≥n Volver (glass)
   ========================= */
.btn-back {
  position: fixed;
  top: calc(env(safe-area-inset-top) + 12px);
  left: 12px;
  z-index: 1000;
  width: 36px; height: 36px;           /* mantiene tama√±o/posici√≥n */
  border-radius: 12px;
  background: rgba(255,255,255,.78);   /* glass m√°s suave */
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
  border: 0; /* evita halo/blanco sobre imagen */
  /* resto igual */
}
.btn-back::after {
  content: '';
  position: absolute;
  inset: 0;
  border-radius: 12px;
  box-shadow: inset 0 0 0 1px rgba(17,24,39,.10); /* contorno neutro */
  pointer-events: none;
}
.btn-back ion-icon {
  font-size: 20px;
  color: var(--ef-title-color, #5D4037); /* marr√≥n del t√≠tulo */
}

/* Hover (solo dispositivos con puntero) */
@media (hover: hover) {
  .btn-back:hover {
    background: rgba(255,255,255,.92);
    box-shadow:
      0 6px 14px rgba(17,24,39,.10),
      inset 0 1px 0 rgba(255,255,255,.6);
  }
}

/* Active / Focus */
.btn-back:active { transform: scale(.96); }
.btn-back:focus-visible {
  outline: none;
  box-shadow:
    0 0 0 3px rgba(93,64,55,.20),       /* anillo acorde al marr√≥n */
    0 4px 12px rgba(17,24,39,.08),
    inset 0 1px 0 rgba(255,255,255,.5);
}

/* Dark mode, coherente con el resto de la pantalla */
@media (prefers-color-scheme: dark) {
  .btn-back {
    background: rgba(18,18,18,.60);
    border-color: #2b2c2d;
    box-shadow:
      0 6px 16px rgba(0,0,0,.45),
      inset 0 1px 0 rgba(255,255,255,.06);
  }
  .btn-back ion-icon {
    color: #E9DFDC; /* marr√≥n claro */
  }
  .btn-back:focus-visible {
    box-shadow:
      0 0 0 3px rgba(233,223,220,.16),
      0 6px 16px rgba(0,0,0,.45),
      inset 0 1px 0 rgba(255,255,255,.06);
  }
}

/* =========================
   Slide / Galer√≠a
   ========================= */
.slide-wrapper {
  position: relative;
  height: clamp(180px, 32vh, 300px);
  background: #f2f3f5;
  border-bottom-left-radius: 20px;
  border-bottom-right-radius: 20px;
  overflow: hidden;
  margin-top: 0;
}

/* Im√°genes */
swiper-container, swiper-slide { width: 100%; height: 100%; display: block; }
swiper-slide img {
  width: 100%; height: 100%;
  object-fit: cover;
  filter: saturate(1.03) contrast(1.02);
}

/* Paginaci√≥n ‚Äúpill‚Äù */
swiper-container::part(bullet) {
  background: rgba(255,255,255,.85);
  opacity: .9; width: 8px; height: 8px; transition: width .2s ease;
}
swiper-container::part(bullet-active) {
  width: 22px; border-radius: 6px; background: #fff;
}

/* Gradiente inferior del hero */
.hero-gradient {
  position: absolute; inset: auto 0 0 0; height: 42%;
  background: linear-gradient(to top, rgba(0,0,0,.45), rgba(0,0,0,0));
  pointer-events: none; z-index: 1;
}

/* Favorito (igual que card) */
.favorite-icon {
  position: absolute;
  top: 10px;
  right: 10px;
  font-size: 30px;
  color: #32db64;
  z-index: 2;
  border-radius: 50%;
  padding: 4px;
  background: transparent;
  transition: transform 0.2s ease, opacity 0.2s ease;
}
.favorite-icon.pulse-animation {
  animation: pulse 0.3s ease;
}
@keyframes pulse {
  0% { transform: scale(1); }
  50% { transform: scale(1.4); }
  100% { transform: scale(1); }
}

/* =========================
   Secciones / texto general
   ========================= */
.section { padding: 16px; }

/* T√≠tulo (marr√≥n, app-like) */
.detalle-content .section h1 {
  font-family: var(--ef-font-stack), sans-serif;
  font-weight: 800;
  letter-spacing: -0.01em;
  font-size: clamp(18px, 2.8vh, 24px);
  line-height: 1.15;
  color: var(--ef-title-color, #5D4037);
  margin: 8px 0 2px;
  text-wrap: balance;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

/* Empresa (gris, simple como antes) */
.detalle-content .section .empresa {
  font-family: var(--ef-font-stack), sans-serif;
  font-weight: 600;                 /* como ten√≠as */
  color: var(--ef-meta-color, #6B7280);
  margin-top: 2px;

  /* sin chip */
  padding: 0;
  background: transparent;
  border: none;
  display: block;
}

.section p { margin: 0; color: #374151; line-height: 1.4; }



.secondary .sec-line {
  display: flex; align-items: center; gap: 8px; padding: 6px 0; color: #374151;
}

/* =========================
   Mapa / direcci√≥n
   ========================= */
.map-container {
  height: 200px;
  border-radius: 16px;
  overflow: hidden;
  border: 1px solid #eef1f5;
  background: #f6f7f9;
}

.map-img {
  width: 100%;
  height: 100%;
  object-fit: cover;
  display: block;
  cursor: pointer; /* clic para abrir en mapas */
}
.direccion-text { margin-top: 8px; color: #4b5563; }

/* Distancia usuario en bloque mapa */
.distancia-usuario {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  margin: 6px 0 10px;
  color: var(--ef-meta-color, #6B7280);
  font-weight: 600;
  font-size: 14px;
}
.distancia-usuario ion-icon {
  font-size: 18px;
  color: #5D4037;
}

@media (prefers-color-scheme: dark) {
  .distancia-usuario { color: #b9b1af; }
  .distancia-usuario ion-icon { color: #d7c7c1; }
}

/* =========================
   Skeletons
   ========================= */
.skel { border-radius: 14px; background: linear-gradient(90deg,#eee,#f7f7f7,#eee); animation: pulse 1.2s infinite; margin: 12px; }
.skel.slide { height: clamp(180px, 32vh, 300px); margin: 0; border-radius: 0; }
.skel.title { height: 24px; width: 60%; }
.skel.text { height: 14px; }
.skel.text.small { width: 80%; }
.skel.chips { height: 36px; }
.skel.map { height: 200px; }
@keyframes pulse { 0%{background-position:0%} 100%{background-position:100%} }

/* =========================
   Footer / CTA
   ========================= */
.footer-reserva {
  position: fixed;
  left: 0;
  right: 0;
  bottom: 0;                           /* pegado abajo */
  z-index: 1100;                       /* por encima de todo */
  background: transparent !important;  /* sin barra/fondo */
  border: 0;
  box-shadow: none;
}
.footer-reserva ion-toolbar {
  --background: transparent;
  background: transparent !important;
  box-shadow: none;
  border: 0;
  --border-width: 0;
  padding-bottom: max(8px, env(safe-area-inset-bottom)); /* mantiene posici√≥n + safe area */
}
/* elimina hairlines (iOS) */
.footer-reserva::before,
.footer-reserva::after,
.footer-reserva ion-toolbar::before,
.footer-reserva ion-toolbar::after {
  display: none;
}

.footer-reserva ion-button {
  --border-radius: 24px;
  --padding-start: 16px;
  --padding-end: 16px;
  height: 40px;
  max-width: 220px;
  width: auto;
  margin: 0 auto;
  font-size: 14px;
  text-transform: none;
}

.footer-reserva .reservar-container {
  display: flex;
  justify-content: center;
}

/* =========================
   Descripci√≥n expandible
   ========================= */
.descripcion-wrapper {
  position: relative;
  --collapsed-lines: 9; /* ajusta aqu√≠ el n¬∫ de l√≠neas visibles antes de 'Ver m√°s' */
  margin-top: 8px;
}

.descripcion-wrapper .descripcion-text {
  margin: 0;
  color: #374151;
  line-height: 1.5;          /* antes 1.45 */
  font-size: 15.8px;         /* antes ~14.5px (ligeramente mayor) */
  white-space: pre-wrap;
  word-break: break-word;
  -webkit-font-smoothing: antialiased;
}

.descripcion-wrapper:not(.expanded) .descripcion-text {
  display: -webkit-box;
  -webkit-line-clamp: var(--collapsed-lines);
  -webkit-box-orient: vertical;
  overflow: hidden;
}

.fade-shadow {
  position: absolute;
  inset: auto 0 0 0;
  height: 56px;
  background: linear-gradient(to bottom, rgba(255,255,255,0), #fff 65%);
  pointer-events: none;
}

.ver-mas-ctr {
  display: flex;
  justify-content: flex-start;
  margin-top: 4px;
}

.btn-ver-mas {
  --border-radius: 18px;
  --padding-start: 14px;
  --padding-end: 12px;
  --background: #ffffff;
  --border-color: #e2e5e9;
  --color: #5D4037;
  font-weight: 600;
  letter-spacing: .3px;
  --border-width: 1px;
  --box-shadow: 0 2px 4px rgba(0,0,0,0.04);
}

.btn-ver-mas ion-icon {
  font-size: 16px;
  margin-left: 2px;
}

.descripcion-wrapper.expanded + .ver-mas-ctr .btn-ver-mas {
  --border-color: #d5c9c4;
}

/* Dark mode */
@media (prefers-color-scheme: dark) {
  .detalle-content {
    --ef-title-color: #D7CCC8; /* marr√≥n claro */
    --ef-meta-color:  #9CA3AF; /* gris claro para empresa */
  }
  .fade-shadow {
    background: linear-gradient(to bottom, rgba(18,18,18,0), #121212 65%);
  }
  .btn-ver-mas {
    --background: #1e1f20;
    --border-color: #2b2c2d;
    --color: #E9DFDC;
  }
}

/* ===== Caracter√≠sticas principales (stats) ===== */
.keyfacts { padding-top: 8px; }

.facts-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
  gap: 10px;
}

.fact {
  display: grid;
  grid-template-columns: 36px 1fr;
  align-items: center;
  gap: 10px;
  padding: 12px;
  border-radius: 14px;
  background: #FAFAFB;
  border: 1px solid #EEF1F5;
  box-shadow: 0 1px 0 rgba(17,24,39,.03);
  transition: transform .08s ease, background .15s ease, border-color .15s ease;
}
.fact:active { transform: scale(.98); }

.fact .icon {
  width: 36px; height: 36px; border-radius: 12px;
  display: grid; place-items: center;
  background: linear-gradient(180deg, #FFF, #F3F4F6);
  border: 1px solid #E9EEF3;
}
.fact .icon ion-icon {
  font-size: 20px;
  color: var(--ef-brown-800, #5D4037); /* usa tu marr√≥n */
}

.fact .label {
  font-size: 12px;
  font-weight: 700;
  letter-spacing: .2px;
  color: #6B7280; /* gris meta */
  line-height: 1;
  margin-bottom: 4px;
}

.fact .value {
  font-size: 16px;
  font-weight: 800;
  color: #111827; /* t√≠tulo oscuro */
  line-height: 1.25;
  word-break: break-word;
}

/* Categor√≠as: permite 2 l√≠neas y luego corta con ellipsis */
.fact .value-multiline {
  display: -webkit-box;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
  overflow: hidden;
}

/* Dark mode */
@media (prefers-color-scheme: dark) {
  .fact {
    background: #0B1020;
    border-color: #1F2937;
    box-shadow: none;
  }
  .fact .icon {
    background: linear-gradient(180deg, #0E1324, #0B1020);
    border-color: #1F2937;
  }
  .fact .label { color: #9CA3AF; }
  .fact .value { color: #E5E7EB; }
}

/* =========================
   Bloque precios (nuevo formato)
   ========================= */
.pricing-section { margin-top: 4px; }

.price-range-header {
  display: flex;
  justify-content: space-between;
  gap: 12px;
  margin-bottom: 14px;
}

.price-pill {
  /* centrado interno */
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;      /* centra horizontalmente */
  text-align: center;       /* centra el texto */
  flex: 1;
  background: linear-gradient(135deg,#f8f5f4,#f1eeeb);
  border: 1px solid #e4dad5;
  border-radius: 16px;
  padding: 10px 14px 12px;
  min-height: 72px;
}

.price-pill .label {
  font-size: 11px;
  font-weight: 600;
  letter-spacing: .7px;
  text-transform: uppercase;
  color: #8d7168;
  margin-bottom: 6px;
}

.price-pill .value {
  font-size: 20px;
  font-weight: 700;
  color: #5D4037;
  line-height: 1;
}

.pp-table {
  border: 1px solid #ece7e4;
  border-radius: 14px;
  overflow: hidden;
  background: #ffffff;
}

.pp-row {
  display: flex;
  justify-content: space-between;
  padding: 10px 14px;
  font-size: 14px;
  font-weight: 500;
  color: #4a4d50;
}

.pp-row:nth-child(even):not(.header) { background: #faf9f8; }

.pp-row.header {
  background: #f3eeec;
  font-size: 12px;
  font-weight: 600;
  letter-spacing: .5px;
  text-transform: uppercase;
  color: #6f5248;
}

/* Dark mode */
@media (prefers-color-scheme: dark) {
  .price-pill {
    background: linear-gradient(135deg,#2a2523,#231f1e);
    border-color: #3a322f;
  }
  .price-pill .label { color: #b89f96; }
  .price-pill .value { color: #f2e6e2; }
  .pp-table { background:#1f1d1c; border-color:#352e2b; }
  .pp-row { color:#d9d4d2; }
  .pp-row:nth-child(even):not(.header) { background:#241f1e; }
  .pp-row.header { background:#2d2624; color:#c5b2aa; }
}

.price-more-btn { margin-top: 8px; }

/* =========================
   Secci√≥n ubicaci√≥n
   ========================= */
.ubicacion-section {
  padding: 16px;
  background: #f9fafb;
  border-radius: 14px;
  margin-top: 16px;
  border: 1px solid #e5e7eb;
}

.ubicacion-section .section-title-row {
  display: flex;
  align-items: center;
  justify-content: space-between; /* t√≠tulo a la izquierda, distancia a la derecha */
  gap: 12px;
  margin-bottom: 8px;
}

.ubicacion-section .section-title {
  margin: 0;
  font-size: 16px;
  font-weight: 700;
  color: var(--ef-title-color, #5D4037);
}

/* Ya existente, se reutiliza; ajustes leves para la fila */
.distancia-usuario {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  color: var(--ef-meta-color, #6B7280);
  font-weight: 600;
  font-size: 14px;
}
.distancia-usuario ion-icon { font-size: 18px; color: #5D4037; }

@media (prefers-color-scheme: dark) {
  .ubicacion-section {
    background: #111827;
    border-color: #374151;
  }
  .ubicacion-section .section-title {
    color: #D1D5DB;
  }
  .distancia-usuario { color: #9CA3AF; }
  .distancia-usuario ion-icon { color: #D1D5DB; }
}

.ubicacion-actions {
  margin-top: 8px;
  display: flex;              /* centrado horizontal */
  justify-content: center;    /* centrado horizontal */
  align-items: center;        /* opcional: centra verticalmente si hay m√°s altura */
}

.btn-abrir-mapas {
  --border-radius: 18px;
  --padding-start: 12px;
  --padding-end: 12px;
  --background: #ffffff;
  --border-color: #d7cbc6;
  --border-width: 1px;
  --color: var(--ef-brown-800, #5D4037);
  --box-shadow: 0 1px 2px rgba(0,0,0,0.03);
  font-weight: 600;
  letter-spacing: .2px;
}
.btn-abrir-mapas ion-icon { font-size: 16px; }

/* Dark mode */
@media (prefers-color-scheme: dark) {
  .btn-abrir-mapas {
    --background: #1e1f20;
    --border-color: #2b2c2d;
    --color: #E9DFDC;
  }
}


=== app/pages/sala-detalle/sala-detalle.page.ts ===
import { Component, OnDestroy, OnInit, ElementRef, ViewChild, AfterViewChecked } from '@angular/core';
import { ActivatedRoute, Router } from '@angular/router';
import { NavController } from '@ionic/angular';
import { Store } from '@ngxs/store';
import { Sala } from 'src/app/models/sala.model';
import { SalaService } from 'src/app/services/sala.service';
import { UsuarioState } from 'src/app/states/usuario.state';
import { environment } from 'src/environments/environment';
import { FavoritosService } from 'src/app/services/favoritos.service';
import { Subscription } from 'rxjs';
import { Haptics, ImpactStyle } from '@capacitor/haptics';
import { Capacitor } from '@capacitor/core';
import { App } from '@capacitor/app';

@Component({
  selector: 'app-sala-detalle',
  templateUrl: './sala-detalle.page.html',
  styleUrls: ['./sala-detalle.page.scss'],
  standalone: false
})
export class SalaDetallePage implements OnInit, OnDestroy, AfterViewChecked {
  sala: Sala | null = null;

  isFavorito = false;
  private favSub?: Subscription;
  cargandoDatos = true;
  galleryReady = false;

  displayedImgs: string[] = [];
  allImgs: string[] = [];

  accesibilidadesAptas = '';           // ...existing code...
  accesibilidades: string[] = [];      // NUEVO

  private cancelado = false;
  get baseUrl() { return environment.imageURL; }

  descExpanded = false;
  isDescOverflow = false;
  // private readonly DESC_CHAR_THRESHOLD = 800;  // <-- ya no se usa (por l√≠neas)
  @ViewChild('descRef') private descRef?: ElementRef<HTMLParagraphElement>;
  private pendingOverflowCheck = false;

  priceTableExpanded = false;
  hasPriceOverflow = false;

  distanciaKm: number | null = null;
  private userLat: number | null = null;
  private userLng: number | null = null;

  constructor(
    private route: ActivatedRoute,
    private router: Router,
    private navCtrl: NavController,
    private salaService: SalaService,
    private store: Store,
    private favoritosService: FavoritosService
  ) {}

  ngOnInit() {
    const id = Number(this.route.snapshot.paramMap.get('id'));
    const { lat, lng } = this.store.selectSnapshot(UsuarioState.ubicacion) || {};
    this.userLat = lat ?? null;
    this.userLng = lng ?? null;
    this.cargarSala(id, lat, lng);
  }

  ngAfterViewChecked() {
    if (this.pendingOverflowCheck) {
      this.pendingOverflowCheck = false;
      this.checkDescripcionOverflow();
    }
  }

  ngOnDestroy() { 
    this.cancelado = true; 
    this.favSub?.unsubscribe();
  }

  volver() {
    if (window.history.length > 1) this.navCtrl.back();
    else this.router.navigateByUrl('/tabs/tab1', { replaceUrl: true });
  }

private cargarSala(id: number, lat?: number | null, lng?: number | null) {
  this.cargandoDatos = true;
  this.galleryReady = false;
  this.distanciaKm = null;
  this.salaService.getSalaById(id, lat ?? null, lng ?? null).subscribe({
    next: (s) => {
      if (this.cancelado) return;
      this.sala = s;
      this.cargandoDatos = false;
      
      // Procesar URL del mapa est√°tico
      if (s.mapa_estatico_url && !s.mapa_estatico_url.startsWith('http')) {
        s.mapa_estatico_url = this.baseUrl + s.mapa_estatico_url.replace(/^\//, '');
      }

      // Extraer solo accesibilidades aptas
      this.accesibilidades = (s.caracteristicas || [])
        .filter(c => c.tipo === 'accesibilidad' && c.es_apta)
        .map(c => c.nombre);
      
      // Ya no evaluamos por n¬∫ de caracteres, siempre reset y luego medimos el DOM
      this.descExpanded = false;
      this.isDescOverflow = false;
      this.priceTableExpanded = false;
      this.hasPriceOverflow = (s.precios_por_jugadores?.length || 0) > 6;

      this.cargandoDatos = false;

      // ---- Im√°genes (DOM estable) ----
      const base = (u: string) =>
        u?.startsWith('http') ? u : (this.baseUrl + (u || '').replace(/^\//, ''));

      const cover   = s.cover_url ? [base(s.cover_url)] : [];
      const galeria = (s.imagenes || []).map(i => base(i.url)).filter(Boolean);

      // Evita duplicados (cover repetida)
      const set = new Set<string>([...cover, ...galeria]);
      this.allImgs = Array.from(set);

      // ‚úÖ Renderiza TODAS las im√°genes desde el principio
      this.displayedImgs = [...this.allImgs];

      // Preload: s√≥lo controla el overlay (no cambia el n¬∫ de slides)
      if (this.allImgs.length <= 1) {
        this.galleryReady = true; // sin overlay si hay 0/1 imagen
      } else {
        this.preloadGallery(this.allImgs);
      }

      // ---- Favorito: suscripci√≥n por sala ----
      this.favSub?.unsubscribe();
      this.favSub = this.favoritosService
        .getFavoritoStatusStream(s.id_sala)
        .subscribe(v => this.isFavorito = v);

      // Marcar que tras render se mida overflow (l√≠neas)
      this.pendingOverflowCheck = true;

      // Distancia: usa exclusivamente la del backend
      const rawDist = (s as any)?.distancia_km ?? (s as any)?.distancia ?? null;
      this.distanciaKm = (rawDist !== null && rawDist !== undefined && rawDist !== '')
        ? Number(rawDist)
        : null;

    },
    error: (e) => {
      console.error('Error cargando sala', e);
      this.cargandoDatos = false;
      this.allImgs = [];
      this.displayedImgs = [];
      this.galleryReady = true;
    }
  });
}


  private preloadGallery(urls: string[]) {
    if (urls.length <= 1) { this.galleryReady = true; return; }

    let loaded = 0;
    const onDone = () => {
      loaded++;
      if (loaded >= urls.length) {
        this.galleryReady = true;
      }
    };

    urls.forEach(u => {
      const img = new Image();
      img.onload = onDone; img.onerror = onDone;
      img.src = u;
    });
  }

  get tienePrecioPP(): boolean {
    return !!(this.sala?.precio_min_pp || this.sala?.precio_max_pp || (this.sala?.precios_por_jugadores?.length));
  }

  trackByUrl(_i: number, u: string) { return u; }

  async toggleFavorito(event?: Event) {
    event?.stopPropagation();
    event?.preventDefault();

    const target = (event?.target as HTMLElement) ?? null;
    try { await Haptics.impact({ style: ImpactStyle.Light }); } catch {}

    if (target) {
      target.classList.add('pulse-animation');
      setTimeout(() => target.classList.remove('pulse-animation'), 300);
    }
    this.favoritosService.toggleFavorito(this.sala!.id_sala);
  }

  togglePriceTable() {
    this.priceTableExpanded = !this.priceTableExpanded;
  }

  toggleDescripcion() {
    this.descExpanded = !this.descExpanded;
    if (!this.descExpanded) this.pendingOverflowCheck = true;
  }

  private checkDescripcionOverflow() {
    if (!this.descRef || this.descExpanded) return;
    const el = this.descRef.nativeElement;
    // Si el contenido real (scrollHeight) excede el alto visible (clientHeight) => overflow
    this.isDescOverflow = el.scrollHeight - el.clientHeight > 2;
  }

  getAccIcon(nombre: string): string {
    const n = (nombre || '').toLowerCase();
    if (n.includes('sign') || n.includes('se√±as') || n.includes('lengua')) return 'hand-left-outline';
    if (n.includes('audit') || n.includes('o√≠do') || n.includes('sonido')) return 'ear-outline';
    if (n.includes('visual') || n.includes('visi√≥n') || n.includes('ciego')) return 'eye-outline';
    if (n.includes('movilidad') || n.includes('rueda')) return 'accessibility-outline';
    return 'accessibility-outline';
  }

  async abrirEnMapas(event?: Event) {
    event?.preventDefault();
    event?.stopPropagation();

    // Construir la direcci√≥n textual
    const partes = [
      this.sala?.tipo_via,
      this.sala?.nombre_via,
      this.sala?.numero,
      this.sala?.ciudad,
      this.sala?.codigo_postal
    ]
      .filter(Boolean)
      .join(' ');
    
    const direccion = partes || this.sala?.nombre || '';
    const q = encodeURIComponent(direccion);
    
    // URL para navegador web (fallback)
    const webUrl = `https://www.google.com/maps/search/?api=1&query=${q}`;
    
    // Verificar la plataforma
    const platform = Capacitor.getPlatform();
    
    try {
      if (platform === 'ios') {
        // En iOS, abrir Apple Maps (nativo)
        window.location.href = `maps://?q=${q}`;
        
        // Fallback a navegador
        setTimeout(() => {
          window.open(webUrl, '_blank');
        }, 500);
      } else if (platform === 'android') {
        // En Android, usar la URL web espec√≠fica de Google Maps
        const intentUrl = `https://www.google.com/maps/search/?api=1&query=${q}`;
        
        // Simplemente usar window.open para Android
        window.open(intentUrl, '_blank');
      } else {
        // En web
        window.open(webUrl, '_blank');
      }
    } catch (error) {
      console.error('Error al abrir la aplicaci√≥n de mapas:', error);
      window.open(webUrl, '_blank');
    }
  }


}


=== app/components/direccion-picker/direccion-picker.component.html ===
<div class="direccion-picker">
  <ion-item button lines="none" class="trigger" (click)="togglePanel()">
    <ion-label class="ubicacion-label">
      <div class="linea-ubicacion">
        <span class="ciudad" [class.seleccionada]="ciudadActual">{{ ciudadActual ? ciudadActual : 'Direcci√≥n' }}</span>
  <ng-container *ngIf="ciudadActual && !calleNumero">
          <span class="centro">(centro)</span>
        </ng-container>
        <ng-container *ngIf="calleNumero">
          <span class="sep">¬∑</span>
          <span #direccionEl class="direccion" [class.compacta]="direccionCompacta">{{ calleNumero }}</span>
        </ng-container>
      </div>
    </ion-label>
    <ion-icon name="chevron-down-outline" slot="end"></ion-icon>
  </ion-item>

  <!-- Modal tipo hoja al 50% -->
  <ion-modal
    [isOpen]="abierto"
    [initialBreakpoint]="initialBreakpoint"
    [breakpoints]="breakpoints"
    (didDismiss)="onModalDismiss()">
    <ng-template>
      <ion-header class="modal-header">
        <div class="header-content">
          <h2>Seleccionar direcci√≥n</h2>
          <ion-icon name="close-outline" class="close-icon" (click)="togglePanel()"></ion-icon>
        </div>
      </ion-header>

      <ion-content class="modal-content">
        <div class="top-actions">
          <ion-button size="small" fill="solid" color="success" class="action-btn locate-btn" (click)="usarMiUbicacion()">
            <ion-icon name="locate" slot="start"></ion-icon>
            Usar mi ubicaci√≥n
          </ion-button>
          <ion-button size="small" fill="outline" color="medium" class="action-btn clear-btn" (click)="borrar()">
            <ion-icon name="trash-outline" slot="start"></ion-icon>
            Borrar direcci√≥n
          </ion-button>
        </div>

        <ion-searchbar
          class="searchbar-custom"
          animated="true"
          showClearButton="focus"
          searchIcon="search-outline"
          enterkeyhint="search"
          inputmode="search"
          [(ngModel)]="query"
          (ionInput)="buscar()"
          showCancelButton="never"
          placeholder="Buscar ciudad o direcci√≥n">
        </ion-searchbar>

        <!-- Direcci√≥n completa seleccionada, centrada; se muestra solo cuando no hay autocompletados -->
        <div class="direccion-completa-wrapper" *ngIf="direccionActual && predicciones.length === 0">
          <div class="direccion-completa" role="note" aria-label="Ubicaci√≥n actual seleccionada">
            <ion-badge color="success" class="badge-actual">
              <ion-icon name="checkmark-circle-outline"></ion-icon>
              <span>Ubicaci√≥n actual</span>
            </ion-badge>
            <div class="direccion-completa-line">
              <ion-icon name="location-outline" class="direccion-completa-icon" aria-hidden="true"></ion-icon>
              <span class="direccion-completa-text">{{ direccionActual }}</span>
            </div>
          </div>
        </div>

        <div class="predicciones-panel">
          <ion-list *ngIf="predicciones.length > 0" class="predictions-list">
            <ion-item button lines="none" class="prediction-item" *ngFor="let p of predicciones" (click)="seleccionar(p)">
              <ion-icon name="location-outline" slot="start" class="prediction-icon"></ion-icon>
              <ion-label [innerHTML]="highlight(p)"></ion-label>
              <ion-icon name="chevron-forward-outline" slot="end" class="prediction-chevron"></ion-icon>
            </ion-item>
          </ion-list>
          <ion-item *ngIf="mostrarNoResultados && query.length > 0" lines="none">
            <ion-label color="medium">No se encontraron resultados</ion-label>
          </ion-item>
        </div>
      </ion-content>
    </ng-template>
  </ion-modal>
</div>


=== app/components/direccion-picker/direccion-picker.component.scss ===
.direccion-picker {
  position: relative;
}

.trigger {
  cursor: pointer;
  font-size: 16px;
  --background: transparent;
}

.ubicacion-label {
  display: flex;
  flex-direction: row;
  align-items: center;
  min-width: 0;
}

.linea-ubicacion {
  display: flex;
  align-items: baseline;
  gap: 6px;
  width: 100%;
  min-width: 0;
  white-space: nowrap;
}

.ciudad {
  font-weight: 600;
  color: var(--ion-text-color, #222);
  flex: 0 0 auto; /* ciudad no se encoge */
}

.ciudad.seleccionada {
  color: var(--ion-color-success);
}

.centro {
  color: var(--ion-color-medium);
  font-weight: 500;
}

.sep {
  color: var(--ion-color-medium);
  flex: 0 0 auto;
}

.direccion {
  font-size: 13px;
  color: var(--ion-color-medium);
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  flex: 1 1 auto; /* esta parte s√≠ se encoge y elide */
}

.direccion.compacta {
  font-size: 12px;
}
.ciudad {
  font-weight: 600;
  color: var(--ion-text-color, #222);
}

.ciudad.seleccionada {
  color: var(--ion-color-success);
}

.direccion {
  font-size: 13px;
  color: var(--ion-color-medium);
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap; /* elipsis en una sola l√≠nea */
}

/* Estilos del modal tipo hoja */
.direccion-modal::part(content) {
  border-radius: 16px 16px 0 0;
}

.modal-header {
  padding: 8px 12px;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
  border-bottom: none;
  border-radius: 0 0 8px 8px;
  z-index: 10;
  position: relative;
}

.modal-header .header-content {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.modal-header .header-content h2 {
  font-size: 18px;
  font-weight: 600;
  margin: 0;
  color: #222;
}

.modal-header .header-content .close-icon {
  font-size: 24px;
  color: #555;
  cursor: pointer;
}

.modal-content {
  --padding-top: 12px;
  --padding-start: 16px;
  --padding-end: 16px;
  --padding-bottom: 24px;
}

.top-actions {
  display: grid;
  grid-template-columns: 1fr 1fr; /* dos columnas iguales siempre */
  gap: 8px;
  margin-bottom: 8px;
  width: 100%;
  align-items: stretch;
  justify-items: center;
}

/* Est√©tica del buscador */
.searchbar-custom {
  --background: #f6f7f9;
  --color: #1f2937;
  --placeholder-color: #9aa3af;
  --icon-color: #6b7280;
  --box-shadow: 0 6px 16px rgba(0, 0, 0, 0.06);
  --border-radius: 14px;
  --cancel-button-color: var(--ion-color-medium);
  border-radius: 14px; /* asegura radio en host */
}

.searchbar-custom .searchbar-input-container {
  border-radius: 14px;
}

.searchbar-custom:focus-within {
  --background: #ffffff;
  --box-shadow: 0 10px 24px rgba(16, 185, 129, 0.15);
}

.searchbar-custom::part(container) {
  border-radius: 14px;
}

.searchbar-custom::part(input) {
  font-size: 16px;
  font-weight: 500;
}

/* Botones acci√≥n estilo pill */
.action-btn {
  --border-radius: 999px;
  --padding-start: 12px;
  --padding-end: 12px;
  --box-shadow: 0 4px 12px rgba(16, 185, 129, 0.18);
  width: 100%; /* ocupa toda la celda de la grid */
  justify-content: center;
  text-align: center;
  white-space: normal; /* permitir que el texto se parta en dos l√≠neas si es necesario */
}

.clear-btn {
  --border-color: #e5e7eb;
  --color: #6b7280;
}

/* Lista de predicciones */
.predictions-list {
  margin-top: 6px;
}

.prediction-item {
  --background: #f8fafc;
  --inner-padding-end: 8px;
  --padding-start: 8px;
  border-radius: 12px;
  margin: 6px 0;
  box-shadow: 0 1px 0 rgba(0,0,0,0.02);
}

.prediction-item:hover {
  --background: #ffffff;
  box-shadow: 0 6px 16px rgba(0, 0, 0, 0.06);
}

.prediction-icon {
  color: var(--ion-color-success);
  font-size: 20px;
  margin-right: 6px;
}

.prediction-chevron {
  color: #94a3b8;
}

/* Resaltado del t√©rmino */
.hl {
  background: rgba(16, 185, 129, 0.12);
  color: #065f46;
  padding: 0 2px;
  border-radius: 4px;
}

/* Direcci√≥n completa seleccionada (debajo del buscador) */
.direccion-completa-wrapper {
  display: flex;
  align-items: center;
  justify-content: center;
  margin-top: 10px;
  width: 100%;
}

.direccion-completa {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 8px;
  padding: 12px 14px;
  background: #f8fafc;
  border: 1px solid #e5e7eb;
  border-radius: 12px;
  max-width: 100%;
}

.direccion-completa-line {
  display: flex;
  align-items: flex-start;
  gap: 8px;
  max-width: 100%;
}

.direccion-completa-icon {
  color: var(--ion-color-success);
  font-size: 18px;
}

.direccion-completa-text {
  color: #374151;
  font-size: 14px;
  font-weight: 500;
  white-space: pre-wrap; /* permite saltos de l√≠nea */
  overflow-wrap: anywhere; /* permite cortes dentro de palabras largas */
  word-break: break-word;
  max-width: min(720px, 100%);
}

.badge-actual {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  font-weight: 600;
  --background: #e6f9f1;
  --color: #047857;
  padding: 6px 10px;
  border-radius: 999px;
}

:host { --kb-height: 0px; }

.predicciones-panel {
  padding-bottom: max(env(safe-area-inset-bottom), var(--kb-height));
  max-height: calc(100vh - var(--kb-height)); /* usa toda la altura disponible */
  overflow: auto;
}


=== app/components/direccion-picker/direccion-picker.component.spec.ts ===
import { ComponentFixture, TestBed, waitForAsync } from '@angular/core/testing';
import { IonicModule } from '@ionic/angular';

import { DireccionPickerComponent } from './direccion-picker.component';

describe('DireccionPickerComponent', () => {
  let component: DireccionPickerComponent;
  let fixture: ComponentFixture<DireccionPickerComponent>;

  beforeEach(waitForAsync(() => {
    TestBed.configureTestingModule({
      declarations: [ DireccionPickerComponent ],
      imports: [IonicModule.forRoot()]
    }).compileComponents();

    fixture = TestBed.createComponent(DireccionPickerComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  }));

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});


=== app/components/direccion-picker/direccion-picker.component.ts ===
// ==============================
// üß≠ DireccionPickerComponent.ts
// ==============================

import { Component, EventEmitter, OnDestroy, OnInit, Output, ViewChild, ElementRef, ChangeDetectorRef, NgZone } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { IonicModule, IonModal } from '@ionic/angular';
import { UbicacionService, UbicacionResultado } from 'src/app/services/ubicacion.service';
import { Geolocation } from '@capacitor/geolocation';
import { Store } from '@ngxs/store';
import { ClearUbicacionUsuario, SetUbicacionUsuario, UsuarioState } from 'src/app/states/usuario.state';
import { Keyboard } from '@capacitor/keyboard';
import { PluginListenerHandle } from '@capacitor/core';
import { Subject, Subscription, of } from 'rxjs';
import { switchMap } from 'rxjs/operators';

@Component({
  selector: 'app-direccion-picker',
  templateUrl: './direccion-picker.component.html',
  styleUrls: ['./direccion-picker.component.scss'],
  standalone: true,
  imports: [CommonModule, FormsModule, IonicModule]
})
export class DireccionPickerComponent implements OnInit, OnDestroy {
  @Output() ciudadSeleccionada = new EventEmitter<string | null>();

  abierto = false;
  query = '';
  predicciones: string[] = [];
  ciudadActual: string | null = null;
  direccionActual: string | null = null;
  calleNumero: string | null = null; // lo que se pinta junto a la ciudad (v√≠a+num) o "(Centro)"
  direccionCompacta = false;
  mostrarNoResultados = false; // Control para mostrar "No hay resultados"
  
  private ultimaPrediccionTimestamp = 0; // Timestamp de la √∫ltima predicci√≥n
  private noResultadosTimeout: any = null; // Timeout para mostrar "No hay resultados"

  @ViewChild('direccionEl') direccionEl?: ElementRef<HTMLDivElement>;
  @ViewChild(IonModal) modal?: IonModal;

  breakpoints: number[] = [0, 0.5, 1];
  initialBreakpoint = 0.5;

  private queryChanged = new Subject<string>();
  private querySub?: Subscription;

  // Cambia a handles reales (no Promises)
  private kbShowSub?: PluginListenerHandle;
  private kbHideSub?: PluginListenerHandle;

  // Constante configurable para el tiempo de espera (en milisegundos)
  private readonly TIEMPO_ESPERA_NO_RESULTADOS = 2000; // 1 segundo

  constructor(
    private ubicacionService: UbicacionService, 
    private store: Store,
    private cdr: ChangeDetectorRef,
    private ngZone: NgZone
  ) {}

  ngOnInit() {
    const ubicacion = this.store.selectSnapshot(UsuarioState.ubicacion);
    if (ubicacion?.ciudad) {
      this.ciudadActual = ubicacion.ciudad;
    }

    if (ubicacion?.direccion) {
      this.direccionActual = ubicacion.direccion;
      this.updateCalleNumeroFromDireccion({
        direccion: ubicacion.direccion,
        ciudad: ubicacion.ciudad || null,
        lat: ubicacion.lat ?? null,
        lng: ubicacion.lng ?? null
      } as any as UbicacionResultado);
    } else if (this.ciudadActual) {
      this.calleNumero = '(Centro)';
    }

    setTimeout(() => this.ajustarTamanoDireccion(), 0);

    this.querySub = this.queryChanged.pipe(
      // ‚ö†Ô∏è sin debounce ni distinct: el backend ya coalescea por sesi√≥n
      switchMap((raw: string) => {
        // evita 400 si est√° vac√≠o; el resto lo decide el backend
        if (raw == null || raw === '') {
          this.predicciones = [];
          return of<string[]>([]);
        }
        return this.ubicacionService.autocomplete(raw);
      })
    ).subscribe((res) => {
      // Ejecutamos dentro de NgZone y forzamos detecci√≥n de cambios
      this.ngZone.run(() => {
        // Solo actualizamos las predicciones si hay resultados
        if (res && res.length > 0) {
          this.predicciones = res;
          this.ultimaPrediccionTimestamp = Date.now();
          this.mostrarNoResultados = false;
          
          // Cancelamos cualquier timeout pendiente de "no resultados"
          if (this.noResultadosTimeout) {
            clearTimeout(this.noResultadosTimeout);
            this.noResultadosTimeout = null;
          }
          
          console.log('Actualizando predicciones en UI:', this.predicciones);
        } else if (res && res.length === 0) {
          // Si no hay resultados, programamos mostrar "No hay resultados" despu√©s del tiempo configurado
          if (this.noResultadosTimeout) {
            clearTimeout(this.noResultadosTimeout);
          }
          
          this.noResultadosTimeout = setTimeout(() => {
            this.ngZone.run(() => {
              // Solo actualizamos si ha pasado el tiempo configurado sin nuevas predicciones
              if (Date.now() - this.ultimaPrediccionTimestamp >= this.TIEMPO_ESPERA_NO_RESULTADOS) {
                this.predicciones = [];
                this.mostrarNoResultados = true;
                console.log(`Mostrando "No hay resultados" tras ${this.TIEMPO_ESPERA_NO_RESULTADOS/1000}s`);
                this.cdr.detectChanges();
              }
            });
          }, this.TIEMPO_ESPERA_NO_RESULTADOS);
        }
        this.cdr.detectChanges();
      });
    });

    // Escuchar teclado y expandir al 100%
    Keyboard.addListener('keyboardDidShow', (e) => {
      document.documentElement.style.setProperty('--kb-height', `${e.keyboardHeight}px`);
      this.modal?.setCurrentBreakpoint(1); // 100%
    }).then(h => this.kbShowSub = h);

    Keyboard.addListener('keyboardDidHide', () => {
      document.documentElement.style.setProperty('--kb-height', `0px`);
      this.modal?.setCurrentBreakpoint(this.initialBreakpoint);
    }).then(h => this.kbHideSub = h);
  }

  ngOnDestroy() {
    this.querySub?.unsubscribe();
    // remove() devuelve Promise; no es necesario await aqu√≠
    this.kbShowSub?.remove();
    this.kbHideSub?.remove();
    
    // Limpiamos el timeout si existe
    if (this.noResultadosTimeout) {
      clearTimeout(this.noResultadosTimeout);
    }
  }

  togglePanel() {
    this.abierto = !this.abierto;
    if (this.abierto) {
      this.query = '';
      this.predicciones = [];
      this.mostrarNoResultados = false;
    } else {
      this.predicciones = [];
      this.mostrarNoResultados = false;
    }
  }

  onModalDismiss() {
    this.abierto = false;
    this.query = '';
    this.predicciones = [];
    this.mostrarNoResultados = false;
    
    // Limpiamos el timeout si existe
    if (this.noResultadosTimeout) {
      clearTimeout(this.noResultadosTimeout);
      this.noResultadosTimeout = null;
    }
  }

  buscar() {
    console.log('Buscando:', this.query);
    
    // Reiniciamos el estado de no resultados al buscar
    if (this.noResultadosTimeout) {
      clearTimeout(this.noResultadosTimeout);
      this.noResultadosTimeout = null;
    }
    this.mostrarNoResultados = false;
    
    this.queryChanged.next(this.query);
  }

  seleccionar(prediccion: string) {
    this.ubicacionService.geocode(prediccion).subscribe({
      next: (res: UbicacionResultado) => {
        this.direccionActual = res.direccion;
        this.ciudadActual = res.ciudad;
        this.query = res.direccion;
        this.abierto = false;
        this.predicciones = [];

        this.updateCalleNumeroFromDireccion(res);

        this.store.dispatch(new SetUbicacionUsuario({
          direccion: res.direccion,
          ciudad: res.ciudad,
          lat: res.lat,
          lng: res.lng
        }));
        this.ciudadSeleccionada.emit(res.ciudad);
      },
      error: (err) => {
        console.error('Error geocodificando:', err);
        alert('No se pudo obtener la ciudad desde la direcci√≥n.');
      }
    });
  }

  async usarMiUbicacion() {
    try {
      const perm = await Geolocation.requestPermissions();
      if (perm.location !== 'granted') {
        alert('Se necesita permiso de geolocalizaci√≥n para usar esta funci√≥n.');
        return;
      }
      const pos = await Geolocation.getCurrentPosition();
      this.ubicacionService.reverseGeocode(pos.coords.latitude, pos.coords.longitude).subscribe({
        next: (res: UbicacionResultado) => {
          this.direccionActual = res.direccion;
          this.ciudadActual = res.ciudad;
          this.query = res.direccion;
          this.ciudadSeleccionada.emit(res.ciudad);
          this.abierto = false;
          this.predicciones = [];

          this.updateCalleNumeroFromDireccion(res);

          this.store.dispatch(new SetUbicacionUsuario({
            direccion: res.direccion,
            ciudad: res.ciudad,
            lat: res.lat,
            lng: res.lng
          }));
        },
        error: (err) => {
          console.error('Error geolocalizaci√≥n backend:', err);
          alert('No se pudo obtener la ciudad desde tu ubicaci√≥n.');
        }
      });
    } catch (err) {
      console.error('Error obteniendo ubicaci√≥n del dispositivo:', err);
      alert('No se pudo acceder al GPS. Verific√° permisos.');
    }
  }

  borrar() {
    this.ciudadActual = null;
    this.direccionActual = null;
    this.query = '';
    this.predicciones = [];
    this.abierto = false;
    this.ciudadSeleccionada.emit(null);
    this.store.dispatch(new ClearUbicacionUsuario());
    this.calleNumero = null;
    this.direccionCompacta = false;
  }

  // ===== Autocomplete: SIN formateo =====
  highlight(texto: string): string {
    return texto; // exacto del backend
  }



  // Construye "calle abreviada + n√∫mero" o "(Centro)" desde res.direccion y res.ciudad
  private formatCalleNumero(res: UbicacionResultado): string {
    
    // Verificar si la direcci√≥n solo contiene la ciudad (para mostrar "(Centro)")
    const partes = res.direccion.split(',');
    const primeraParte = partes[0].trim();
    const numero = partes[1]?.trim(); 
    
    // Si la primera parte de la direcci√≥n es igual a la ciudad, mostrar "(Centro)"
    if (res.ciudad && primeraParte.toLowerCase() === res.ciudad.toLowerCase()) {
      return '(Centro)';
    }
    
    // Si no, usar la primera parte de la direcci√≥n (calle y n√∫mero)
    if (partes.length > 1) {
      // Verificar si el n√∫mero es realmente un n√∫mero
      const esNumero = numero && /^\d+[a-zA-Z]?$/.test(numero);
      return primeraParte + (esNumero ? ", " + numero : "");
    }
    
    // Si todo falla, devolver un fragmento de la direcci√≥n
    return res.direccion.length > 30 ? 
      res.direccion.substring(0, 30) + '...' : 
      res.direccion;
  }

  // Implementar el m√©todo updateCalleNumeroFromDireccion
  private updateCalleNumeroFromDireccion(res: UbicacionResultado): void {
    // Si no hay direcci√≥n, usar (Centro)
    if (!res.direccion) {
      this.calleNumero = '(Centro)';
      return;
    }

    // Si hay direcci√≥n, usar el formateo
    this.calleNumero = this.formatCalleNumero(res);
    
    // Ajustar tama√±o despu√©s de actualizar
    setTimeout(() => this.ajustarTamanoDireccion(), 0);
  }

  // Implementar el m√©todo ajustarTamanoDireccion
  private ajustarTamanoDireccion(): void {
    if (!this.direccionEl || !this.calleNumero) return;
    
    const el = this.direccionEl.nativeElement;
    const parentWidth = el.parentElement?.clientWidth;
    
    if (!parentWidth) return;
    
    // Si el ancho del elemento es mayor que el contenedor, activar modo compacto
    this.direccionCompacta = el.scrollWidth > parentWidth * 0.8;
  }
}


=== app/components/filter-modal/filters-modal.component.html ===
<ion-header class="modal-header">
  <div class="header-content">
<button
  type="button"
  class="reset-btn"
  [class.active]="hasActiveFilters"
  (click)="onResetClick($event)"
  aria-label="Borrar filtros"
>
  <ion-icon name="trash-outline" class="reset-btn__icon"></ion-icon>

  <!-- Anillo de realce (solo visible cuando hay filtros) -->
  <span class="reset-btn__ring" aria-hidden="true"></span>

  <!-- Chispas al clic -->
  <span class="reset-btn__sparkles" aria-hidden="true"></span>
    <!-- Badge con el n√∫mero de filtros activos -->
  <span
    class="reset-btn__badge"
    *ngIf="activeFilterCount > 0"
    >{{ activeFilterCount }}</span
  >
</button>
    <h2>Filtros</h2>
    <ion-icon name="close-outline" class="close-icon" (click)="dismiss()"></ion-icon>
  </div>
</ion-header>

<ion-content class="modal-content">
<ion-item lines="none" class="filter-row jugadores-row">
  <ion-label class="filter-label">Jugadores</ion-label>
  <ion-select
    slot="end"
    interface="popover"
    [(ngModel)]="filtros.jugadores"
    placeholder="Todos"
    class="jugadores-select">
    <ion-select-option [value]="null">Todos</ion-select-option>
    <ion-select-option *ngFor="let num of jugadoresOpciones" [value]="num">
      {{ num === 10 ? '10 o m√°s' : num }}
    </ion-select-option>
  </ion-select>
</ion-item>


  <div class="filtro-section">
  <label class="section-label">Precio por persona (‚Ç¨)</label>

  <div *ngIf="!filtros.jugadores">
    <ion-text color="medium" class="precio-info-text">
      <ion-icon name="information-circle-outline"></ion-icon>
      Seleccione el n√∫mero de jugadores para mayor precisi√≥n
    </ion-text>
  </div>

  <ion-range
    min="0"
    max="100"
    step="5"
    snaps="true"
    [(ngModel)]="filtros.precio">
  </ion-range>

<div class="precio-limites-con-texto">
  <span>0 ‚Ç¨</span>
  <span class="precio-label">
    {{ filtros.precio ? ('Hasta ' + filtros.precio + ' ‚Ç¨ por persona') : 'Sin definir' }}
  </span>
  <span>100+ ‚Ç¨</span>
</div>
</div>

<div class="filtro-section">
  <label class="section-label">Distancia (km)</label>

  <div *ngIf="!_tieneUbicacion" class="ubicacion-warning">
    <ion-text color="warning">
      <ion-icon name="warning-outline"></ion-icon>
      Selecciona una ubicaci√≥n para usar este filtro
    </ion-text>
  </div>

  <ion-range
    min="0"
    max="150"
    step="5"
    snaps="true"
    [(ngModel)]="filtros.distancia_km"
    [disabled]="!_tieneUbicacion"
    (ionChange)="onDistanciaChange($event)">
  </ion-range>

  <div *ngIf="_tieneUbicacion" class="precio-limites-con-texto">
    <span>0 KM</span>
    <span class="precio-label">
      {{
        filtros.distancia_km
          ? filtros.distancia_km + ' km de radio'
          : 'Todas las salas de ' + filtros.ciudad
      }}
    </span>
    <span>150 KM</span>
  </div>
</div>

  <div class="filtro-section">
    <label class="section-label">Dificultad</label>
    <div class="categorias-grid">
      <div
        class="categoria-btn"
        *ngFor="let dif of dificultadOpciones"
        [class.selected]="filtros.dificultad.includes(dif)"
        (click)="toggleDificultad(dif)">
        {{ dif }}
      </div>
    </div>
  </div>
  <div class="filtro-section">
    <label class="section-label">Categor√≠as</label>
    <div class="categorias-grid">
      <div
        class="categoria-btn"
        *ngFor="let cat of categoriasOpciones"
        [class.selected]="filtros.categorias.includes(cat.valor)"
        (click)="toggleCategoria(cat.valor)">
        <img [src]="cat.icono" alt="{{cat.nombre}} icono" class="categoria-icon" />
        <span>{{ cat.nombre }}</span>
      </div>
    </div>
  </div>

<!-- ========================================
     NUEVOS FILTROS DE ACTORES E IDIOMA (EN L√çNEA)
     ======================================== -->
<!-- FILTROS DE ACTORES E IDIOMA (UNO DEBAJO DEL OTRO) -->
<!-- Con Actores -->
<ion-item lines="none" class="filter-row">
  <ion-label class="filter-label">Con Actores</ion-label>
  <ion-toggle slot="end" [(ngModel)]="filtros.actores" color="success"></ion-toggle>
</ion-item>

<!-- Idioma -->
<ion-item lines="none" class="filter-row">
  <ion-label class="filter-label">Idioma</ion-label>
  <ion-select
    slot="end"
    interface="popover"
    [(ngModel)]="filtros.idioma"
    placeholder="Cualquier idioma"
    class="idioma-select">
    <ion-select-option [value]="null">Cualquier idioma</ion-select-option>
    <ion-select-option *ngFor="let idioma of idiomaOpciones" [value]="idioma">
      {{ idioma }}
    </ion-select-option>
  </ion-select>
</ion-item>


<div class="filtro-section">
  <ion-item lines="none" (click)="toggleTipoSala()" detail="false" class="collapsible-header">
    <ion-label class="section-label">Tipo de sala</ion-label>
    <ion-icon [name]="isTipoSalaOpen ? 'chevron-up-outline' : 'chevron-down-outline'" slot="end"></ion-icon>
  </ion-item>

  <div *ngIf="isTipoSalaOpen" class="checkbox-grid">
    <ion-item *ngFor="let tipo of tiposSalaOpciones" lines="none" class="checkbox-item">
      <ion-checkbox slot="start"
                    [(ngModel)]="tipo.checked"
                    (ionChange)="onToggleTipo()"
                    class="modern-checkbox" 
                     color="success">
      </ion-checkbox>
      <ion-label>{{ tipo.nombre }}</ion-label>
    </ion-item>
  </div>
</div>

<!-- ========================================
     NUEVO FILTRO DE ACCESIBILIDAD
     ======================================== -->
<div class="filtro-section">
  <ion-item lines="none" (click)="toggleAccesibilidad()" detail="false" class="collapsible-header">
    <ion-label class="section-label">Accesibilidad</ion-label>
    <ion-icon [name]="isAccesibilidadOpen ? 'chevron-up-outline' : 'chevron-down-outline'" slot="end"></ion-icon>
  </ion-item>

  <div *ngIf="isAccesibilidadOpen" class="checkbox-list">
    <ion-item *ngFor="let opcion of accesibilidadOpciones" lines="none" class="checkbox-item">
      <ion-checkbox slot="start"
                    [(ngModel)]="opcion.checked"
                    (ionChange)="onToggleAccesibilidad()"
                    class="modern-checkbox"
                    color="success">
      </ion-checkbox>
      <ion-icon [name]="opcion.icono" slot="start" class="checkbox-icon"></ion-icon>
      <ion-label>{{ opcion.texto }}</ion-label>
    </ion-item>
  </div>
</div>

<!-- ========================================
     NUEVO FILTRO DE RESTRICCIONES
     ======================================== -->
<div class="filtro-section">
  <ion-item lines="none" (click)="toggleRestricciones()" detail="false" class="collapsible-header">
    <ion-label class="section-label">Restricciones</ion-label>
    <ion-icon [name]="isRestriccionesOpen ? 'chevron-up-outline' : 'chevron-down-outline'" slot="end"></ion-icon>
  </ion-item>

  <div *ngIf="isRestriccionesOpen" class="checkbox-list">
    <ion-item *ngFor="let opcion of restriccionesOpciones" lines="none" class="checkbox-item">
      <ion-checkbox slot="start"
                    [(ngModel)]="opcion.checked"
                    (ionChange)="onToggleRestricciones()"
                    class="modern-checkbox"
                    color="success">
      </ion-checkbox>
      <ion-icon [name]="opcion.icono" slot="start" class="checkbox-icon"></ion-icon>
      <ion-label>{{ opcion.texto }}</ion-label>
    </ion-item>
  </div>
</div>

<!-- ========================================
     NUEVO FILTRO DE P√öBLICO OBJETIVO
     ======================================== -->
<div class="filtro-section">
  <ion-item lines="none" (click)="togglePublicoObjetivo()" detail="false" class="collapsible-header">
    <ion-label class="section-label">P√∫blico objetivo</ion-label>
    <ion-icon [name]="isPublicoObjetivoOpen ? 'chevron-up-outline' : 'chevron-down-outline'" slot="end"></ion-icon>
  </ion-item>

  <div *ngIf="isPublicoObjetivoOpen" class="checkbox-grid">
    <ion-item *ngFor="let opcion of publicoObjetivoOpciones" lines="none" class="checkbox-item">
      <ion-checkbox slot="start"
                    [(ngModel)]="opcion.checked"
                    (ionChange)="onTogglePublicoObjetivo()"
                    class="modern-checkbox"
                    color="success">
      </ion-checkbox>
      <ion-label>{{ opcion.texto }}</ion-label>
    </ion-item>
  </div>
</div>

</ion-content>

<ion-footer class="modal-footer">
  <ion-button expand="block" class="apply-btn" (click)="aplicarFiltros()">Aplicar filtros</ion-button>
</ion-footer>


=== app/components/filter-modal/filters-modal.component.scss ===
.modal-header {
  padding: 5px 5px;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05); // üëà Suavidad inferior
  border-bottom: none; // opcional: quita l√≠nea dura
  border-radius: 0 0 8px 8px; // üëà Borde inferior curvado
  z-index: 10;
  position: relative;

  .header-content {
    display: flex;
    justify-content: space-between;
    align-items: center;

    h2 {
      font-size: 18px;
      font-weight: 600;
      margin: 0;
      color: #222;
    }

    .close-icon {
      font-size: 24px;
      color: #555;
      cursor: pointer;
    }
   .reset-icon {
      font-size: 22px;
      color: #a2e3b1;
      cursor: pointer;
      margin-right: 16px;
    }
  }
}

.modal-content {
 --padding-top: 12px;
  --padding-start: 16px;
  --padding-end: 16px;
  --padding-bottom: 24px;
  --background: #fafafa; // üëà fondo ligeramente distinto
  

.filtro-section {
  margin-top: 20px;

  .section-label {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 8px;
    font-size: 16px;
    font-weight: 600;
    color: #444;

    .dropdown-icon {
      font-size: 18px;
      color: #666;
      margin-left: 8px;
    }
  }

  ion-range {
    --bar-background-active: var(--ion-color-success);
  }
}

// üëá NUEVOS ESTILOS PARA FILTROS EN L√çNEA
.inline-filters-container {
  display: flex;
  gap: 16px; // Espacio entre los filtros
  align-items: flex-end; // Alinea los items en la parte inferior para que coincidan
}

.inline-filter-item {
  flex: 1; // Cada filtro ocupa el mismo espacio
}

// üëá A√ëADE ESTE NUEVO ESTILO PARA EL TOGGLE
.toggle-item {
  --background: transparent;
  --padding-start: 0;
  --inner-padding-end: 0;
  .section-label {
    margin-bottom: 0;
  }
}

  .categorias-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 10px;
    margin-top: 10px;

    .categoria-btn {
      padding: 8px;
      text-align: center;
      background: #f1f1f1;
      border-radius: 12px;
      font-size: 14px;
      color: #333;
      cursor: pointer;
      user-select: none;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .categoria-btn.selected {
      background: #a2e3b1;
      font-weight: bold;
    }
  }
  .jugadores-select {
  --padding-start: 12px;
  --padding-end: 12px;
  --border-radius: 12px;
  --background: #f1f1f1;
  margin-top: 4px;
}

.precio-info-text {
  font-size: 13px;
  opacity: 0.8;
  display: flex;
  align-items: center;
  gap: 6px;

  ion-icon {
    font-size: 16px;
  }
}

.precio-limites-con-texto {
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-size: 13px;
  color: #444;
  margin-top: 4px;
  padding: 0 2px;

  .precio-label {
    font-size: 13px;
    color: #666;
    text-align: center;
    flex: 1;
  }

  span:first-child,
  span:last-child {
    width: 50px;
    text-align: center;
  }
}


}

.modal-footer {
  /*padding: 16px;
  background: #fff;
  border-top: 1px solid #e0e0e0;*/
    border-top: none;
  border-radius: 16px 16px 0 0; // üëà Borde superior curvado
  box-shadow: 0 -4px 8px rgba(0, 0, 0, 0.04); // üëà Sombra superior suave
  background: #fff;
  z-index: 10;
  position: relative;
  padding: 5px;

  .apply-btn {
    --background: var(--ion-color-success);
    --border-radius: 12px;
    font-weight: 600;
  }

  
}

.categoria-icon {
  width: 1.5em;
  height: 1.5em;
  margin-right: 6px;
  vertical-align: middle;
  object-fit: contain;
}

.ubicacion-warning {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 8px;
  margin: 8px 0;
  background-color: rgba(255, 196, 9, 0.1);
  border-radius: 8px;
  font-size: 14px;

  ion-icon {
    font-size: 18px;
    color: var(--ion-color-warning);
  }
}

.collapsible-header {
  --background: transparent;
  --padding-start: 0;
  --inner-padding-end: 0;
  cursor: pointer;
  .section-label {
    margin-bottom: 0;
  }
}

// Para "Tipo de sala" (2 columnas)
.checkbox-grid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 8px;
  padding: 8px 0;
}

// NUEVO: Para "Accesibilidad" (1 columna)
.checkbox-list {
  display: flex;
  flex-direction: column;
  gap: 8px;
  padding: 8px 0;
}

.checkbox-item {
  --background: #f7f7f7;
  --inner-padding-end: 8px;
  --padding-start: 8px;
  border-radius: 12px;
  /* El 'gap' de la rejilla se encarga del espaciado vertical */
}

.checkbox-item ion-icon.checkbox-icon {
  margin-left: 8px;
  margin-right: 8px;
  font-size: 20px;
  color: #555;
}

ion-checkbox.modern-checkbox {
  --size: 28px;
  --border-radius: 8px;
  --border-color-checked: #a2e3b1;
  --background-checked: #a2e3b1;
  --checkmark-color: white;
}

/* Bot√≥n circular con glass + anillo de gradiente */
.reset-btn {
  position: relative;
  width: 38px;
  height: 38px;
  border: 0;
  border-radius: 50%;
  background: rgba(255, 255, 255, 0.55);
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
  box-shadow:
    inset 0 0 0 1px rgba(0,0,0,0.06),
    0 4px 14px rgba(0,0,0,0.10);
  display: inline-grid;
  place-items: center;
  cursor: pointer;
  transition: transform 140ms ease, box-shadow 140ms ease, background 140ms ease, opacity 140ms ease;
  margin-right: 10px; /* ajusta si lo necesitas */
  outline: none;
  opacity: 0.95;

  /* Hover suave */
  &:hover { transform: translateY(-1px); }

  /* Active (mientras pulsas) */
  &:active { transform: translateY(0); }

  /* Accesibilidad: respeta reduce motion */
  @media (prefers-reduced-motion: reduce) {
    transition: none;
    & * { animation: none !important; }
  }
}

.reset-btn__icon {
  font-size: 20px;
  color: var(--ion-text-color, #1d1d1f);
  transition: transform 160ms ease, color 160ms ease, opacity 160ms ease;
}

/* Anillo de gradiente (solo cuando hay filtros) */
.reset-btn__ring {
  position: absolute;
  inset: -3px;
  border-radius: 50%;
  pointer-events: none;
  opacity: 0;
  transition: opacity 220ms ease;
  background:
    conic-gradient(
      from 180deg,
      var(--ion-color-success) 0%,
      #7dd3fc 25%,
      #c084fc 50%,
      var(--ion-color-danger) 75%,
      var(--ion-color-success) 100%
    );
  filter: blur(0.6px) saturate(1.1);
  /* marco suave */
  mask:
    radial-gradient(circle at center, transparent 62%, black 63%);
}

/* Chispas (se animan al clic) */
.reset-btn__sparkles {
  --s-size: 8px;
  position: absolute;
  inset: 0;
  pointer-events: none;
}

.reset-btn__sparkles::before,
.reset-btn__sparkles::after {
  content: "";
  position: absolute;
  width: var(--s-size);
  height: var(--s-size);
  border-radius: 2px;
  background: currentColor;
  left: 50%; top: 50%;
  transform: translate(-50%, -50%) scale(0);
  opacity: 0;
}

/* Estado ACTIVO (hay filtros): color + pulso + anillo visible */
.reset-btn.active {
  background: rgba(255, 255, 255, 0.75);
  .reset-btn__icon {
    color: var(--ion-color-success);
    animation: resetBreath 1700ms ease-in-out infinite;
  }
  .reset-btn__ring { opacity: 1; animation: ringSpin 2600ms linear infinite; }
}

/* Animaci√≥n al clic */
.reset-btn.reset-anim {
  .reset-btn__icon { animation: trashPop 360ms ease forwards; }
  .reset-btn__sparkles::before { animation: sparkA 420ms ease-out forwards; }
  .reset-btn__sparkles::after  { animation: sparkB 480ms ease-out forwards; }
}

/* --- Keyframes --- */

/* Pulso sutil del icono cuando hay filtros */
@keyframes resetBreath {
  0%   { transform: scale(1);   opacity: 1;   }
  50%  { transform: scale(1.06); opacity: 0.95; }
  100% { transform: scale(1);   opacity: 1;   }
}

/* Giro lent√≠simo del anillo (feedback continuo) */
@keyframes ringSpin {
  to { transform: rotate(360deg); }
}

/* Pop con inclinaci√≥n de la papelera al clic */
@keyframes trashPop {
  0%   { transform: scale(1) rotate(0deg); }
  35%  { transform: scale(1.18) rotate(-10deg); }
  100% { transform: scale(1) rotate(0deg); }
}

/* Chispas que salen hacia arriba-dcha */
@keyframes sparkA {
  0%   { opacity: 0; transform: translate(-50%, -50%) scale(0.6) rotate(0deg); }
  25%  { opacity: 1; }
  100% { opacity: 0; transform: translate(8px, -18px) scale(0.1) rotate(160deg); }
}

/* Chispas hacia arriba-izda, m√°s lentas */
@keyframes sparkB {
  0%   { opacity: 0; transform: translate(-50%, -50%) scale(0.6) rotate(0deg); }
  25%  { opacity: 1; }
  100% { opacity: 0; transform: translate(-10px, -22px) scale(0.1) rotate(-150deg); }
}

/* Modo oscuro: ajusta fondo e icono */
:host-context(.dark) .reset-btn {
  background: rgba(24, 24, 27, 0.55);
  box-shadow:
    inset 0 0 0 1px rgba(255,255,255,0.06),
    0 4px 14px rgba(0,0,0,0.35);
}

:host-context(.dark) .reset-btn__icon {
  color: #e5e7eb;
}

.reset-btn__badge {
  position: absolute;
  top: -4px;
  right: -4px;
  min-width: 18px;
  height: 18px;
  padding: 0 4px;
  border-radius: 999px;
  background: var(--ion-color-danger);
  color: #fff;
  font-size: 11px;
  font-weight: 600;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 2px 4px rgba(0,0,0,0.25);
  transform: scale(0);
  opacity: 0;
  transition: transform 180ms ease, opacity 180ms ease;
}

/* Aparece cuando hay filtros activos */
.reset-btn.active .reset-btn__badge {
  transform: scale(1);
  opacity: 1;
}


/* üëâ NUEVO ESTILO PARA FILTROS "Con Actores" e "Idioma" EN UNA L√çNEA */
.filter-row {
  --background: transparent;
  --padding-start: 0;
  --inner-padding-end: 0;
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-top: 10px;

  ion-label.filter-label {
    font-size: 16px;
    font-weight: 600;
    color: #444;
    flex-shrink: 0; /* Evita que la etiqueta se encoja */
    margin-right: 16px; /* A√±ade un espacio de seguridad */
  }

  ion-select.idioma-select {
    --background: #f1f1f1;
    --border-radius: 12px;
    --padding-start: 12px;
    --padding-end: 12px;
    font-size: 14px;
    min-width: 160px;
    text-align: right;
  }
}

.filter-row.jugadores-row {
  ion-select.jugadores-select {
    min-width: 0; // Permite que el select se encoja por debajo de su ancho base
    flex: 1;           // se expande si hay espacio
  }
}



=== app/components/filter-modal/filters-modal.component.ts ===
import { Component, Input, OnInit } from '@angular/core';
import { CommonModule } from '@angular/common';
import { IonicModule, ModalController } from '@ionic/angular';
import { FormsModule } from '@angular/forms';
import { Store } from '@ngxs/store';
import { CATEGORIAS } from '../../constants/categorias.const';
@Component({
  selector: 'app-filters-modal',
  standalone: true,
  imports: [CommonModule, IonicModule, FormsModule ],
  templateUrl: './filters-modal.component.html',
  styleUrls: ['./filters-modal.component.scss']
})
export class FiltersModalComponent implements OnInit {
  @Input() filtrosActuales: any = {};
 // distancia: number = 10;
  filtros: any = {
    jugadores: null,
    distancia_km: undefined,
    precio: null,
    tipo_sala: [],
    categorias: [],
    dificultad: [],
    accesibilidad: [],
    restricciones_aptas: [],
    publico_objetivo: [],
    actores: false, // üëà Nuevo filtro para Actores
    idioma: null    // üëà Nuevo filtro para Idioma
  };
jugadoresOpciones = [2, 3, 4, 5, 6, 7, 8, 9, 10];
tiposSalaOpciones: any[] = [ // üëà CAMBIO: Especificar el tipo como any[]
  'Al aire libre',
  'Escape Room',
  'Experiencia',
  'Hall game',
  'Juego port√°til',
  'Realidad Virtual'
];
dificultadOpciones = ['F√°cil', 'Media', 'Alta'];
// üëá Nuevas opciones para el desplegable de Idioma
idiomaOpciones: string[] = ['Espa√±ol', 'Ingl√©s', 'Catal√°n', 'Franc√©s'];
accesibilidadOpciones: any[] = [
  { texto: 'Apto Discapacidad motora', valor: 'Apto Discapacidad motora', icono: 'accessibility-outline' },
  { texto: 'Apto Discapacidad visual', valor: 'Apto Discapacidad visual', icono: 'eye-off-outline' },
  { texto: 'Apto Discapacidad auditiva', valor: 'Apto Discapacidad auditiva', icono: 'ear-outline' }
];
// üëá Nuevas opciones de restricciones
restriccionesOpciones: any[] = [
  { texto: 'Apto para embarazadas', valor: 'Mujeres embarazadas', icono: 'female-outline' },
  { texto: 'Apto para claustrofobia', valor: 'Claustrofobia', icono: 'lock-open-outline' }
];
// üëá Nuevas opciones de p√∫blico objetivo
publicoObjetivoOpciones: any[] = [
  { texto: 'Ni√±os con adulto', valor: 'Ni√±os con adulto', icono: 'people-circle-outline' },
  { texto: 'Ni√±os con Monitor', valor: 'Ni√±os con Monitor', icono: 'school-outline' },
  { texto: 'Empresas', valor: 'Empresas', icono: 'business-outline' },
  { texto: 'Grupos grandes', valor: 'Grupos grandes', icono: 'people-outline' },
  { texto: 'Estandar', valor: 'Estandar', icono: 'person-outline' },
  { texto: 'Familiar', valor: 'Familiar', icono: 'home-outline' },
  { texto: 'Ni√±os', valor: 'Ni√±os', icono: 'happy-outline' }
];
categoriasOpciones = CATEGORIAS.slice(1);
isTipoSalaOpen = false;
isAccesibilidadOpen = false;
isRestriccionesOpen = false;
isPublicoObjetivoOpen = false; // üëà Nuevo: para controlar el desplegable
_tieneUbicacion: boolean = false;

  constructor(private modalCtrl: ModalController, private store: Store) {}

  ngOnInit() {
    this.filtros = {
      ...this.filtros,
      ...this.filtrosActuales,
      categorias: Array.isArray(this.filtrosActuales.categorias) ? [...this.filtrosActuales.categorias] : [],
      dificultad: Array.isArray(this.filtrosActuales.dificultad) ? [...this.filtrosActuales.dificultad] : [],
      tipo_sala: Array.isArray(this.filtrosActuales.tipo_sala) ? [...this.filtrosActuales.tipo_sala] : [],
      accesibilidad: Array.isArray(this.filtrosActuales.accesibilidad) ? [...this.filtrosActuales.accesibilidad] : [],
      restricciones_aptas: Array.isArray(this.filtrosActuales.restricciones_aptas) ? [...this.filtrosActuales.restricciones_aptas] : [],
      publico_objetivo: Array.isArray(this.filtrosActuales.publico_objetivo) ? [...this.filtrosActuales.publico_objetivo] : [],
      actores: this.filtrosActuales.actores === true,
     idioma: this.filtrosActuales.idioma || null,
      precio: this.filtrosActuales.precio ?? null,
      distancia_km: this.filtrosActuales.distancia_km ?? undefined
    };
    this._tieneUbicacion = !!this.filtrosActuales.ciudad;

    this.tiposSalaOpciones = this.tiposSalaOpciones.map(nombre => ({
      nombre,
      checked: this.filtros.tipo_sala.includes(nombre)
    }));
    this.accesibilidadOpciones = this.accesibilidadOpciones.map(opcion => ({
      ...opcion,
      checked: this.filtros.accesibilidad.includes(opcion.valor)
    }));
    this.restriccionesOpciones = this.restriccionesOpciones.map(opcion => ({
      ...opcion,
      checked: this.filtros.restricciones_aptas.includes(opcion.valor)
    }));
    this.publicoObjetivoOpciones = this.publicoObjetivoOpciones.map(opcion => ({
      ...opcion,
      checked: this.filtros.publico_objetivo.includes(opcion.valor)
    }));

    // üëá Abrir autom√°ticamente las secciones con selecciones previas
    this.isTipoSalaOpen = this.filtros.tipo_sala.length > 0;
    this.isAccesibilidadOpen = this.filtros.accesibilidad.length > 0;
    this.isRestriccionesOpen = this.filtros.restricciones_aptas.length > 0;
    this.isPublicoObjetivoOpen = this.filtros.publico_objetivo.length > 0;
  }

  dismiss() {
    this.modalCtrl.dismiss();
  }

aplicarFiltros() {
  const filtrosParaEnviar = { ...this.filtros };

  // Booleanos: si es false, que vaya como undefined
  if (!filtrosParaEnviar.actores) filtrosParaEnviar.actores = undefined;

  // Listas: si quedan vac√≠as, NO delete -> undefined (pisa el valor anterior en el padre)
  if (!filtrosParaEnviar.categorias?.length) filtrosParaEnviar.categorias = undefined;
  if (!filtrosParaEnviar.dificultad?.length) filtrosParaEnviar.dificultad = undefined;
  if (!filtrosParaEnviar.tipo_sala?.length) filtrosParaEnviar.tipo_sala = undefined;
  if (!filtrosParaEnviar.accesibilidad?.length) filtrosParaEnviar.accesibilidad = undefined;
  if (!filtrosParaEnviar.restricciones_aptas?.length) filtrosParaEnviar.restricciones_aptas = undefined;
  if (!filtrosParaEnviar.publico_objetivo?.length) filtrosParaEnviar.publico_objetivo = undefined;
  if (!filtrosParaEnviar.idioma) filtrosParaEnviar.idioma = undefined;
  if (!filtrosParaEnviar.precio) filtrosParaEnviar.precio = undefined;
  if (!filtrosParaEnviar.distancia_km) filtrosParaEnviar.distancia_km = undefined;

  this.modalCtrl.dismiss(filtrosParaEnviar);
}
resetearFiltros() {
  const ciudad = this.filtros.ciudad;

  this.filtros = {
    ciudad,
    jugadores: null,
    distancia_km: null, // si quieres resetear tambi√©n la distancia
    precio: null,
    tipo_sala: [],
    categorias: [],
    dificultad: [],
    accesibilidad: [],
    restricciones_aptas: [],
    publico_objetivo: [],
    actores: false,
    idioma: null
  };

  // Desmarcar visualmente todos los checkboxes (nuevas refs -> change detection)
  this.tiposSalaOpciones = this.tiposSalaOpciones.map(t => ({ ...t, checked: false }));
  this.accesibilidadOpciones = this.accesibilidadOpciones.map(o => ({ ...o, checked: false }));
  this.restriccionesOpciones = this.restriccionesOpciones.map(o => ({ ...o, checked: false }));
  this.publicoObjetivoOpciones = this.publicoObjetivoOpciones.map(o => ({ ...o, checked: false }));
}

toggleTipoSala() {
  this.isTipoSalaOpen = !this.isTipoSalaOpen;
}

toggleAccesibilidad() {
  this.isAccesibilidadOpen = !this.isAccesibilidadOpen;
}

toggleRestricciones() {
  this.isRestriccionesOpen = !this.isRestriccionesOpen;
}

// üëá Nuevo: Abre y cierra el desplegable de p√∫blico objetivo
togglePublicoObjetivo() {
  this.isPublicoObjetivoOpen = !this.isPublicoObjetivoOpen;
}

onToggleTipo() {
  this.filtros.tipo_sala = (this.tiposSalaOpciones as any[])
    .filter(t => t.checked)
    .map(t => t.nombre);
}

onToggleAccesibilidad() {
  this.filtros.accesibilidad = this.accesibilidadOpciones
    .filter(opcion => opcion.checked)
    .map(opcion => opcion.valor);
}

// üëá Nuevo: Actualiza los filtros cuando un checkbox de restricciones cambia
onToggleRestricciones() {
  this.filtros.restricciones_aptas = this.restriccionesOpciones
    .filter(opcion => opcion.checked)
    .map(opcion => opcion.valor);
}

// üëá Nuevo: Actualiza los filtros cuando un checkbox de p√∫blico objetivo cambia
onTogglePublicoObjetivo() {
  this.filtros.publico_objetivo = this.publicoObjetivoOpciones
    .filter(opcion => opcion.checked)
    .map(opcion => opcion.valor);
}

toggleCategoria(cat: string) {
  const idx = this.filtros.categorias.indexOf(cat);
  if (idx > -1) {
    this.filtros.categorias.splice(idx, 1);
  } else {
    this.filtros.categorias.push(cat);
  }
}

toggleDificultad(dificultad: string) {
    const idx = this.filtros.dificultad.indexOf(dificultad);
    if (idx > -1) {
      this.filtros.dificultad.splice(idx, 1);
    } else {
      this.filtros.dificultad.push(dificultad);
    }
  }
onDistanciaChange(event: any) {
  const value = event.detail.value;
  this.filtros.distancia_km = value === 0 ? undefined : value;
}


  get hasActiveFilters(): boolean {
  const f = this.filtros || {};
  // ‚ùå No cuenta 'ciudad'
  return !!(
    f.jugadores ||
    f.precio ||
    f.distancia_km ||
    (Array.isArray(f.tipo_sala) && f.tipo_sala.length) ||
    (Array.isArray(f.categorias) && f.categorias.length) ||
    (Array.isArray(f.dificultad) && f.dificultad.length) ||
    (Array.isArray(f.accesibilidad) && f.accesibilidad.length) ||
    (Array.isArray(f.restricciones_aptas) && f.restricciones_aptas.length) ||
    (Array.isArray(f.publico_objetivo) && f.publico_objetivo.length) ||
    f.actores === true ||
    !!f.idioma
  );
}

get activeFilterCount(): number {
  const f = this.filtros || {};
  let count = 0;

  // Jugadores
  if (f.jugadores) count++;
  // Precio
  if (f.precio) count++;
  // Distancia
  if (f.distancia_km) count++;
  // Arrays
  const arrays = [
    f.tipo_sala,
    f.categorias,
    f.dificultad,
    f.accesibilidad,
    f.restricciones_aptas,
    f.publico_objetivo
  ];
  arrays.forEach(arr => {
    if (Array.isArray(arr) && arr.length) count += arr.length;
  });
  // Booleanos
  if (f.actores === true) count++;
  // Select idioma
  if (f.idioma) count++;

  return count;
}

onResetClick(ev: Event) {
  const el = ev.currentTarget as HTMLElement;
  el.classList.remove('reset-anim');
  // Reinicia animaciones si clicas varias veces
  void el.offsetWidth;
  el.classList.add('reset-anim');

  this.resetearFiltros();
}
}

=== app/components/sala-card/sala-card.component.html ===
<ion-card class="sala-card" (click)="onOpen()">
  <!-- Mostrar el contenido real solo cuando la imagen se ha cargado completamente -->
  <ng-container *ngIf="!loadingImage; else skeletonTemplate">
    
    <!-- Imagen principal de la sala -->
    <div class="img-wrapper">
      <div class="image-container">
        <img
          [src]="currentImage"
          [attr.loading]="'lazy'"
          (load)="onImageLoad()"
          (error)="onImageError()"
          [class.loaded]="!loadingImage"
          alt="Imagen de la sala"
        />
      </div>
      <!-- Icono de favorito (verde si activo) -->
      <ion-icon
        #favoriteIcon
        [name]="isFavorito ? 'heart' : 'heart-outline'"
        class="favorite-icon"
        (click)="toggleFavorito($event)">
      </ion-icon>
      <!-- Nombre de la sala y ciudad -->
  <div class="nombre-overlay">
    <h2>{{ sala.nombre }}</h2>
    <p class="empresa">{{ sala.empresa }} - <small>{{ sala.ciudad }}</small></p>
    </div>
  </div>
  <!-- Chips informativos agrupados en dos filas -->
  <div class="info-chips-container">
    <!-- Fila Superior: Jugadores, Dificultad, Categor√≠as -->
    <div class="chip-row chip-row-top">
      <div class="chip">
        <ion-icon name="people-outline"></ion-icon>
        <span>{{ sala.jugadores_min }}-{{ sala.jugadores_max }}</span>
      </div>
      <div class="chip">
        <ion-icon name="extension-puzzle-outline"></ion-icon>
        <span>{{ sala.dificultad }}</span>
      </div>
      <div class="chip chip-categorias" *ngIf="sala.categorias && sala.categorias.length > 0">
        <ion-icon name="pricetag-outline"></ion-icon>
        <span>{{ sala.categorias.join(', ') }}</span>
      </div>
    </div>

    <!-- Fila Inferior: Precio y Distancia -->
    <div class="chip-row chip-row-bottom">
      <!-- Chip de Precio -->
      <div class="chip chip-precio" *ngIf="sala.precio_min_pp">
        <ion-icon name="cash-outline"></ion-icon>
        <span>Desde {{ sala.precio_min_pp }}‚Ç¨ por persona</span>
      </div>
      <!-- Chip de Distancia -->
      <div class="chip" *ngIf="sala.distancia_km !== null && sala.distancia_km !== undefined">
        <ion-icon name="navigate-circle-outline"></ion-icon>
        <span>{{ formatDistancia(sala.distancia_km) }}</span>
      </div>
    </div>
  </div>

  <!-- Contenido de la tarjeta -->
  <ion-card-content>
      <p class="descripcion-limitada">
        {{ sala.descripcion_corta || 'Sin descripci√≥n disponible.' }}
      </p>
    </ion-card-content>
  </ng-container>
  <!-- üíÄ SKELETON (s√≥lo se muestra mientras loadingImage === true) -->
  <ng-template #skeletonTemplate>
    <div class="skeleton-wrapper">
      <div class="skeleton-image shimmer"></div>
      <div class="skeleton-lines">
        <div class="shimmer skeleton-line short"></div>
        <div class="shimmer skeleton-line medium"></div>
        <div class="shimmer skeleton-line long"></div>
      </div>
    </div>
  </ng-template>
</ion-card>



=== app/components/sala-card/sala-card.component.scss ===
/* ========================================
   Estilos del componente SalaCard
   ======================================== */
.sala-card {
  border-radius: 16px;
  overflow: hidden;
  background: #fff;
  box-shadow: 0 4px 10px rgba(0, 0, 0, 0.06);
  margin-bottom: 16px;

  .img-wrapper {
    position: relative;
    border-radius: 12px;
    overflow: hidden;

    .image-container {
      width: 100%;
      height: 240px;
      position: relative;

      &::after {
        content: '';
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        height: 60%;
        background: linear-gradient(to top, rgba(0, 0, 0, 0.7) 0%, rgba(0, 0, 0, 0) 100%);
        z-index: 1;
        border-radius: 0 0 12px 12px;
      }
    }

    img {
      width: 100%;
      height: 240px;
      object-fit: cover;
      opacity: 0;
      transition: opacity 0.4s ease-in;
    }
    img.loaded {
      opacity: 1;
    }

    .favorite-icon {
      position: absolute;
      top: 10px;
      right: 10px;
      font-size: 30px;
      color: #32db64;
      z-index: 2;
      border-radius: 50%;
      padding: 4px;
      background: transparent;
      transition: transform 0.2s ease, opacity 0.2s ease;
    }
    .favorite-icon.pulse-animation {
      animation: pulse 0.3s ease;
    }
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.4); }
      100% { transform: scale(1); }
    }

    .nombre-overlay {
      position: absolute;
      bottom: 12px;
      left: 12px;
      right: 12px;
      color: white;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.6);
      z-index: 2;

      h2 {
        margin: 0;
        font-size: 18px;
        font-weight: 600;
        line-height: 1.2;
      }
      .empresa {
        font-size: 14px;
        margin: 0;
        opacity: 0.9;
      }
      small {
        font-size: 13px;
        opacity: 0.75;
      }
    }

    .info-overlay {
      display: none;
    }
  }

  .info-chips-container {
    display: flex;
    flex-direction: column;
    gap: 8px;
    padding: 12px 16px 0;
  }

  .chip-row {
    display: flex;
    align-items: center;
    gap: 8px;

    .chip {
      flex-grow: 1;
      flex-shrink: 1;
      flex-basis: auto;
      min-width: 0;
      justify-content: center;
      text-align: center;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
  }

  .chip-row-top {
    justify-content: space-between;

    .chip-categorias {
      flex-grow: 1.5;
    }
  }

  .chip-row-bottom {
    justify-content: center;

    &:has(> :nth-child(2)) {
      justify-content: space-between;
    }

    .chip-precio {
      flex-grow: 1.5;
    }
  }

  .chip {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 6px;
    font-size: 13px;
    padding: 6px 10px;
    border-radius: 16px;
    font-weight: 500;
    background: #f7f7f7;
    color: #333;
    border: 1px solid #e0e0e0;
    transition: background 0.2s ease;
    animation: chipFadeIn 0.3s ease;

    &:hover {
      background: #eeeeee;
    }

    ion-icon {
      font-size: 16px;
      flex-shrink: 0;
    }
  }

  .chip-row-top .chip:nth-child(1) {
    background: #e3f2fd;
    color: #0d47a1;
    border-color: #bbdefb;
  }

  .chip-row-top .chip:nth-child(2) {
    background: #fff3e0;
    color: #ef6c00;
    border-color: #ffe0b2;
  }

  .chip-categorias {
    background: #ede7f6;
    color: #5e35b1;
    border-color: #d1c4e9;
  }

  .chip-precio {
    background: #e8f5e9;
    color: #2e7d32;
    border-color: #c8e6c9;
  }

  .chip-row-bottom .chip:not(.chip-precio) {
    background: #fce4ec;
    color: #ad1457;
    border-color: #f8bbd0;
  }

  @keyframes chipFadeIn {
    from {
      opacity: 0;
      transform: scale(0.95);
    }
    to {
      opacity: 1;
      transform: scale(1);
    }
  }

  @media (max-width: 360px) {
    .chip-row-top .chip {
      font-size: 11px;
      padding: 5px 8px;

      ion-icon {
        font-size: 14px;
      }
    }
  }

  ion-card-content {
    padding: 12px 16px;
    .descripcion-limitada {
  font-size: 14px;
  color: #2e2e2e;
  line-height: 1.4;
  font-weight: 500;
  padding-top: 10px;
  margin-top: 10px;
  border-top: 1px solid #f0f0f0;

  display: -webkit-box;
  -webkit-line-clamp: 5;
  -webkit-box-orient: vertical;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: normal;

  /* animaci√≥n sutil si se quiere mostrar con fade */
  animation: fadeInDescripcion 0.3s ease-in;
}

@keyframes fadeInDescripcion {
  from { opacity: 0; transform: translateY(4px); }
  to   { opacity: 1; transform: translateY(0); }
}
  }
}

/* ========================================
   Skeleton de carga
   ======================================== */
.skeleton-wrapper {
  padding: 16px;
}
.skeleton-image {
  width: 100%;
  height: 240px;
  background: #e0e0e0;
  border-radius: 12px;
  margin-bottom: 12px;
}
.skeleton-lines {
  display: flex;
  flex-direction: column;
  gap: 8px;
  .skeleton-line {
    height: 14px;
    background: #ddd;
    border-radius: 8px;
    &.short { width: 40%; }
    &.medium { width: 60%; }
    &.long { width: 80%; }
  }
}
.shimmer {
  background: linear-gradient(
    to right,
    #e0e0e0 0%,
    #f8f8f8 50%,
    #e0e0e0 100%
  );
  background-size: 200% 100%;
  animation: shimmer 1.2s infinite linear;
}
@keyframes shimmer {
  0% { background-position: -200% 0; }
  100% { background-position: 200% 0; }
}


=== app/components/sala-card/sala-card.component.ts ===
import {
  Component,
  Input,
  ViewChild,
  ElementRef,
  ChangeDetectorRef,
  OnDestroy,
  OnInit,
  OnChanges,
  SimpleChanges,
  Output,
  EventEmitter 
} from '@angular/core';
import { Sala } from 'src/app/models/sala.model';
import { CommonModule } from '@angular/common';
import { IonicModule } from '@ionic/angular';
import { Haptics, ImpactStyle } from '@capacitor/haptics';
import { FavoritosService } from 'src/app/services/favoritos.service';
import { Subscription } from 'rxjs';
import { environment } from 'src/environments/environment';

/**
 * SalaCardComponent
 *
 * Componente que representa visualmente una sala de escape.
 * Muestra skeleton mientras se carga la imagen, incluyendo retardo m√≠nimo visual.
 * Resetea el estado visual cuando la sala cambia (Input muta sin destruir el componente).
 */
@Component({
  selector: 'app-sala-card',
  standalone: true,
  templateUrl: './sala-card.component.html',
  styleUrls: ['./sala-card.component.scss'],
  imports: [CommonModule, IonicModule]
})
export class SalaCardComponent implements OnInit, OnDestroy, OnChanges {
  @Input() sala!: Sala;
  @ViewChild('favoriteIcon') favoriteIconRef!: ElementRef;
  @Output() open = new EventEmitter<number>(); // <-- NUEVO

  isFavorito = false;
  loadingImage = true;

  // Tiempo m√≠nimo que el skeleton debe estar visible, en milisegundos.
  private skeletonDelay = 400;
  private imageLoadStart = 0;

  private favoritoSub?: Subscription;
  private animationFrameId: number | null = null;

  fallbackImage = 'assets/escapeImagen.png';
  currentImage = '';
  private urlImage = environment.imageURL;

  constructor(
    private favoritosService: FavoritosService,
    private cdr: ChangeDetectorRef
  ) {}

  /**
   * Se llama cuando el componente se inicializa por primera vez.
   */
  ngOnInit() {
    this.resetCard(); // inicializaci√≥n de imagen y skeleton

    this.favoritoSub = this.favoritosService
      .getFavoritoStatusStream(this.sala.id_sala)
      .subscribe(isFav => {
        this.isFavorito = isFav;
        this.cdr.markForCheck();
      });
  }

  /**
   * Detecta cambios en el input `sala` (cuando Angular reutiliza la card).
   * Esto es necesario porque Angular NO destruye el componente si se usa `trackBy`.
   */
  ngOnChanges(changes: SimpleChanges): void {
    if (changes['sala'] && !changes['sala'].firstChange) {
      this.resetCard(); // reiniciar imagen y skeleton al recibir nueva sala
    }
  }

  ngOnDestroy() {
    this.favoritoSub?.unsubscribe();
    if (this.animationFrameId) cancelAnimationFrame(this.animationFrameId);
  }

  /**
   * Inicializa la imagen y fuerza la visualizaci√≥n del skeleton con retardo m√≠nimo.
   */
  private resetCard() {
    this.loadingImage = true;
    this.imageLoadStart = performance.now();

    this.currentImage = this.sala.cover_url
      ? this.urlImage + this.sala.cover_url
      : this.fallbackImage;

    const img = new Image();
    img.src = this.currentImage;
    img.onload = () => this.onImageLoad();
    img.onerror = () => this.onImageError();
  }

  /**
   * Evento lanzado cuando la imagen se ha cargado (o el fallback).
   * Asegura un m√≠nimo de tiempo para que el skeleton sea visible.
   */
  onImageLoad() {
    const elapsed = performance.now() - this.imageLoadStart;
    const remaining = Math.max(this.skeletonDelay - elapsed, 0);

    setTimeout(() => {
      this.loadingImage = false;
      this.cdr.markForCheck(); // forzar redibujo en caso de imagen r√°pida
    }, remaining);
  }

  /**
   * Si la imagen falla, se usa una imagen por defecto.
   * Tambi√©n se asegura que se dispare `onImageLoad()` aunque falle la carga original.
   */
  onImageError() {
    if (this.currentImage !== this.fallbackImage) {
      this.currentImage = this.fallbackImage;

      const fallback = new Image();
      fallback.src = this.fallbackImage;
      fallback.onload = () => this.onImageLoad();
    } else {
      this.loadingImage = false;
    }
  }

  /**
   * Marca o desmarca una sala como favorita, con feedback h√°ptico y animaci√≥n.
   */
  async toggleFavorito(event: Event) {
    event.stopPropagation();
    event.preventDefault();

    const target = event.target as HTMLElement;
    if (!target) return;

    target.style.transform = 'scale(1)';
    await Haptics.impact({ style: ImpactStyle.Light });

    this.animationFrameId = requestAnimationFrame(() => {
      target.classList.add('pulse-animation');
      this.favoritosService.toggleFavorito(this.sala.id_sala);
      setTimeout(() => {
        target.classList.remove('pulse-animation');
        this.animationFrameId = null;
      }, 300);
    });
  }

  /**
   * Formatea la distancia para mostrarla en la tarjeta de la sala.
   * Si la distancia es menor a 1 km, se muestra en metros.
   * Si es 1 km o m√°s, se muestra con un decimal.
   */
  formatDistancia(km: number): string {
    if (km < 1) {
      return `${Math.round(km * 1000)} m`;
    }
    return `${km.toFixed(1)} km`;
  }

  // NUEVA FUNCI√ìN para formatear el rango de precios
  formatPrecio(min?: number, max?: number): string {
    if (min && max) {
      if (min === max) {
        return `${min}‚Ç¨`;
      }
      return `${min}‚Ç¨ - ${max}‚Ç¨`;
    }
    if (min) {
      return `${min}‚Ç¨`;
    }
    if (max) {
      return `${max}‚Ç¨`;
    }
    return 'N/A';
  }

 
  
  onOpen() {
    // Si el click vino desde el icono favorito, ya hiciste stopPropagation() ah√≠
    if (this.sala?.id_sala) this.open.emit(this.sala.id_sala);
  }
}



=== app/components/sala-mini-card/sala-mini-card.component.html ===
<article class="minicard" (click)="onClick()">
  <figure class="cover">
    <img
      [src]="imageSrc"
      loading="lazy"
      alt="Portada de la sala"
    />
  </figure>
  <div class="body">
    <div class="title" *ngIf="sala?.nombre">
      <div class="title__name">{{ sala?.nombre }}</div>
      <div class="title__address" *ngIf="sala?.tipo_via && sala?.nombre_via">
        {{ sala?.tipo_via | viaAbrev }} {{ sala?.nombre_via }}{{ sala?.numero ? ', ' + sala?.numero : '' }}
      </div>
    </div>
    <div class="meta">
      <ng-container *ngIf="sala?.precio_min_pp as precio">üí∂ {{ precio | number: '1.0-0' }} ‚Ç¨/pp</ng-container>
      <ng-container *ngIf="sala?.distancia_km !== null && sala?.distancia_km !== undefined">¬∑ üìç {{ sala?.distancia_km | number: '1.0-1' }} km</ng-container>
    </div>
  </div>
</article>

=== app/components/sala-mini-card/sala-mini-card.component.scss ===
:host {
  display: block;
  --minicard-width: clamp(220px, 65vw, 320px);
  --minicard-min-height: clamp(112px, calc(var(--minicard-width) * 0.48), 188px);
  --minicard-padding: clamp(10px, 3vw, 18px);
  --minicard-gap: clamp(6px, 2vw, 14px);
  --minicard-title-size: clamp(14px, 1.8vw, 18px);
  --minicard-meta-size: clamp(12px, 1.6vw, 14px);
  --minicard-address-size: clamp(12px, 1.4vw, 14px);
  --minicard-cover-width: clamp(74px, calc(var(--minicard-width) * 0.28), 112px);
}

@media (min-width: 768px) {
  :host {
    --minicard-width: clamp(320px, 42vw, 420px);
    --minicard-min-height: clamp(180px, calc(var(--minicard-width) * 0.52), 260px);
    --minicard-padding: clamp(16px, 3vw, 26px);
    --minicard-gap: clamp(10px, 2.4vw, 20px);
    --minicard-title-size: clamp(18px, 2.6vw, 26px);
    --minicard-meta-size: clamp(14px, 2.2vw, 20px);
    --minicard-address-size: clamp(13px, 1.8vw, 18px);
    --minicard-cover-width: clamp(120px, calc(var(--minicard-width) * 0.3), 168px);
  }
}

@media (min-width: 1024px) {
  :host {
    --minicard-width: clamp(380px, 32vw, 480px);
    --minicard-min-height: clamp(220px, calc(var(--minicard-width) * 0.54), 320px);
    --minicard-padding: clamp(20px, 2.4vw, 32px);
    --minicard-gap: clamp(12px, 2vw, 24px);
    --minicard-title-size: clamp(20px, 2.2vw, 30px);
    --minicard-meta-size: clamp(16px, 2vw, 22px);
    --minicard-address-size: clamp(14px, 1.6vw, 20px);
    --minicard-cover-width: clamp(150px, calc(var(--minicard-width) * 0.32), 200px);
  }
}

.minicard {
  width: var(--minicard-width);
  min-height: var(--minicard-min-height);
  display: flex;
  background: #ffffff;
  border-radius: 14px;
  overflow: hidden;
  box-shadow: 0 6px 16px rgba(15, 23, 42, 0.18);
  transition: transform 140ms ease, box-shadow 140ms ease;
}

.minicard .cover {
  width: var(--minicard-cover-width);
  min-width: var(--minicard-cover-width);
  margin: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  background: var(--ef-minicard-cover-bg, #0f172a);
  overflow: hidden;
}

.minicard .cover img {
  width: 100%;
  height: 100%;
  object-fit: cover;
  display: block;
}

.minicard .body {
  flex: 1;
  padding: var(--minicard-padding);
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: flex-start;
  gap: var(--minicard-gap);
}

.minicard .title {
  display: flex;
  flex-direction: column;
  gap: clamp(2px, 0.6vw, 6px);
}

.minicard .title__name {
  font-weight: 800;
  font-size: var(--minicard-title-size);
  color: #5d4037;
  line-height: 1.2;
  letter-spacing: -0.01em;
}

.minicard .title__address {
  font-weight: 600;
  font-size: var(--minicard-address-size);
  color: #6b7280;
  line-height: 1.25;
}

.minicard .meta {
  font-size: var(--minicard-meta-size);
  color: var(--ef-meta-color, #64748b);
  display: flex;
  flex-wrap: wrap;
  gap: clamp(4px, 1.4vw, 10px);
  align-items: center;
}

:host-context(.carousel-slide.selected) .minicard {
  box-shadow: 0 16px 36px rgba(50, 219, 100, 0.42);
  transform: translateY(-10px);
}

=== app/components/sala-mini-card/sala-mini-card.component.ts ===
import { CommonModule } from '@angular/common';
import { ChangeDetectionStrategy, Component, EventEmitter, Input, Output, SimpleChanges, OnChanges } from '@angular/core';
import { SalaPinDTO } from 'src/app/services/map.service';
import { environment } from 'src/environments/environment';
import { ViaAbrevPipe } from 'src/app/pipes/via-abrev.pipe'; 


@Component({
  selector: 'app-sala-mini-card',
  standalone: true,
  imports: [CommonModule, ViaAbrevPipe],
  templateUrl: './sala-mini-card.component.html',
  styleUrls: ['./sala-mini-card.component.scss'],
  changeDetection: ChangeDetectionStrategy.OnPush
})
export class SalaMiniCardComponent implements OnChanges{
  @Input() sala!: SalaPinDTO;
  @Output() focusSala = new EventEmitter<number>();

  imageSrc = 'assets/placeholder.jpg';
  
  get direccionLabel(): string | null {
    const sala = this.sala;
    if (!sala) {
      return null;
    }

    const tipoVia = sala.tipo_via?.trim();
    const numero = sala.numero?.trim();
    const ampliacion = sala.ampliacion?.trim();
    const codigoPostal = sala.codigo_postal?.trim();
    const nombreVia = sala.nombre_via?.trim();
    const ciudad = sala.ciudad?.trim();

    const base =  tipoVia + " " + nombreVia;
    if (base && ciudad) {
      return base.includes(ciudad) ? base : `${base} ¬∑ ${ciudad}`;
    }

    return base || ciudad || null;
  }

  ngOnChanges(changes: SimpleChanges): void {
    if (changes['sala']) {
      this.updateImageSrc();
    }
  }

  private updateImageSrc(): void {
    const cover = this.sala?.cover_url?.trim();
    if (!cover) {
      this.imageSrc = 'assets/placeholder.jpg';
      return;
    }

    const isAbsolute = /^https?:\/\//i.test(cover);
    if (isAbsolute) {
      this.imageSrc = cover;
      return;
    }

    const base = environment.imageURL.replace(/\/$/, '');
    const path = cover.replace(/^\//, '');
    this.imageSrc = `${base}/${path}`;
  }

  onClick(): void {
    if (this.sala?.id_sala != null) {
      this.focusSala.emit(this.sala.id_sala);
    }
  }
}

