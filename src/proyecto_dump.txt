=== global.scss ===
/*
 * App Global CSS
 * ----------------------------------------------------------------------------
 * Put style rules here that you want to apply globally. These styles are for
 * the entire app and not just one component. Additionally, this file can be
 * used as an entry point to import other CSS/Sass files to be included in the
 * output CSS.
 * For more information on global stylesheets, visit the documentation:
 * https://ionicframework.com/docs/layout/global-stylesheets
 */

/* Core CSS required for Ionic components to work properly */
@import "@ionic/angular/css/core.css";

/* Basic CSS for apps built with Ionic */
@import "@ionic/angular/css/normalize.css";
@import "@ionic/angular/css/structure.css";
@import "@ionic/angular/css/typography.css";
@import "@ionic/angular/css/display.css";

/* Optional CSS utils that can be commented out */
@import "@ionic/angular/css/padding.css";
@import "@ionic/angular/css/float-elements.css";
@import "@ionic/angular/css/text-alignment.css";
@import "@ionic/angular/css/text-transformation.css";
@import "@ionic/angular/css/flex-utils.css";

/**
 * Ionic Dark Mode
 * -----------------------------------------------------
 * For more info, please see:
 * https://ionicframework.com/docs/theming/dark-mode
 */

/* @import "@ionic/angular/css/palettes/dark.always.css"; */
/* @import "@ionic/angular/css/palettes/dark.class.css"; */
@import "@ionic/angular/css/palettes/dark.system.css";

ion-header,
ion-toolbar {
  padding-top: var(--safe-area-inset-top, 0px);
  background: #fff;
}

ion-content {
  --padding-top: 0px;
  --padding-bottom: calc(var(--safe-area-inset-bottom, 0px) + 80px); // 80px para la barra de tabs
  background: #fff;
}

ion-footer {
  padding-bottom: var(--safe-area-inset-bottom, 0px);
}

=== index.html ===
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>Ionic App</title>

  <base href="/" />

  <meta name="color-scheme" content="light dark" />
  <meta name="viewport" content="viewport-fit=cover, width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="format-detection" content="telephone=no" />
  <meta name="msapplication-tap-highlight" content="no" />

  <link rel="icon" type="image/png" href="assets/icon/favicon.png" />

  <!-- add to homescreen for ios -->
  <meta name="mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
</head>

<body>
  <app-root></app-root>
</body>

</html>


=== main.ts ===
import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';

import { AppModule } from './app/app.module';

platformBrowserDynamic().bootstrapModule(AppModule)
  .catch(err => console.log(err));


=== polyfills.ts ===
/**
 * This file includes polyfills needed by Angular and is loaded before the app.
 * You can add your own extra polyfills to this file.
 *
 * This file is divided into 2 sections:
 *   1. Browser polyfills. These are applied before loading ZoneJS and are sorted by browsers.
 *   2. Application imports. Files imported after ZoneJS that should be loaded before your main
 *      file.
 *
 * The current setup is for so-called "evergreen" browsers; the last versions of browsers that
 * automatically update themselves. This includes recent versions of Safari, Chrome (including
 * Opera), Edge on the desktop, and iOS and Chrome on mobile.
 *
 * Learn more in https://angular.io/guide/browser-support
 */

/***************************************************************************************************
 * BROWSER POLYFILLS
 */

/**
 * By default, zone.js will patch all possible macroTask and DomEvents
 * user can disable parts of macroTask/DomEvents patch by setting following flags
 * because those flags need to be set before `zone.js` being loaded, and webpack
 * will put import in the top of bundle, so user need to create a separate file
 * in this directory (for example: zone-flags.ts), and put the following flags
 * into that file, and then add the following code before importing zone.js.
 * import './zone-flags';
 *
 * The flags allowed in zone-flags.ts are listed here.
 *
 * The following flags will work for all browsers.
 *
 * (window as any).__Zone_disable_requestAnimationFrame = true; // disable patch requestAnimationFrame
 * (window as any).__Zone_disable_on_property = true; // disable patch onProperty such as onclick
 * (window as any).__zone_symbol__UNPATCHED_EVENTS = ['scroll', 'mousemove']; // disable patch specified eventNames
 *
 *  in IE/Edge developer tools, the addEventListener will also be wrapped by zone.js
 *  with the following flag, it will bypass `zone.js` patch for IE/Edge
 *
 *  (window as any).__Zone_enable_cross_context_check = true;
 *
 */
 
import './zone-flags';

/***************************************************************************************************
 * Zone JS is required by default for Angular itself.
 */
import 'zone.js';  // Included with Angular CLI.


/***************************************************************************************************
 * APPLICATION IMPORTS
 */


=== test.ts ===
// This file is required by karma.conf.js and loads recursively all the .spec and framework files

import 'zone.js/testing';
import { getTestBed } from '@angular/core/testing';
import {
  BrowserDynamicTestingModule,
  platformBrowserDynamicTesting
} from '@angular/platform-browser-dynamic/testing';

// First, initialize the Angular testing environment.
getTestBed().initTestEnvironment(
  BrowserDynamicTestingModule,
  platformBrowserDynamicTesting(),
);


=== zone-flags.ts ===
/**
 * Prevents Angular change detection from
 * running with certain Web Component callbacks
 */
// eslint-disable-next-line no-underscore-dangle
(window as any).__Zone_disable_customElements = true;


=== app/app-routing.module.ts ===
import { NgModule } from '@angular/core';
import { PreloadAllModules, RouterModule, Routes } from '@angular/router';

const routes: Routes = [
  {
    path: '',
    redirectTo: 'tabs/tab2',
    pathMatch: 'full'
  },
  {
    path: 'tabs',
    loadChildren: () => import('./tabs/tabs.module').then(m => m.TabsPageModule)
  }
];

@NgModule({
  imports: [RouterModule.forRoot(routes, { preloadingStrategy: PreloadAllModules })],
  exports: [RouterModule]
})
export class AppRoutingModule {}


=== app/app.component.html ===
<ion-app>
  <ion-router-outlet></ion-router-outlet>
</ion-app>


=== app/app.component.scss ===


=== app/app.component.spec.ts ===
import { CUSTOM_ELEMENTS_SCHEMA } from '@angular/core';
import { TestBed } from '@angular/core/testing';

import { AppComponent } from './app.component';

describe('AppComponent', () => {

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      declarations: [AppComponent],
      schemas: [CUSTOM_ELEMENTS_SCHEMA],
    }).compileComponents();
  });

  it('should create the app', () => {
    const fixture = TestBed.createComponent(AppComponent);
    const app = fixture.componentInstance;
    expect(app).toBeTruthy();
  });

});


=== app/app.component.ts ===
import { Component } from '@angular/core';
import { EdgeToEdge } from '@capawesome/capacitor-android-edge-to-edge-support';
import { StatusBar, Style } from '@capacitor/status-bar';
import { Keyboard } from '@capacitor/keyboard';
import { Capacitor } from '@capacitor/core';

@Component({
  selector: 'app-root',
  templateUrl: 'app.component.html',
  styleUrls: ['app.component.scss'],
  standalone: false
})
export class AppComponent {
  constructor() {
    this.initializeApp();
  }

  async initializeApp() {
    await EdgeToEdge.enable();
    await EdgeToEdge.setBackgroundColor({ color: '#ffffff' });
    await StatusBar.setOverlaysWebView({ overlay: false });
    await StatusBar.setStyle({ style: Style.Dark });
  }

  ngOnInit() {
    try {
      if (Capacitor.isNativePlatform()) {
        // setResizeMode puede no existir en versiones antiguas; usar optional chaining
        (Keyboard as any).setResizeMode?.({ mode: 'ionic' });
      }
    } catch {}
  }
}


=== app/app.module.ts ===
import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { RouteReuseStrategy } from '@angular/router';

import { IonicModule, IonicRouteStrategy } from '@ionic/angular';
import { AppComponent } from './app.component';
import { AppRoutingModule } from './app-routing.module';
import { HttpClientModule } from '@angular/common/http';
import { NgxsModule } from '@ngxs/store';
import { SalaState } from './states/salas/salas.state';
import { UsuarioState } from './states/usuario.state';
import { NgxsStoragePluginModule } from '@ngxs/storage-plugin';

@NgModule({
  declarations: [AppComponent],
  imports: [
    BrowserModule,
    IonicModule.forRoot(),
    HttpClientModule,
    AppRoutingModule,

    NgxsModule.forRoot([SalaState, UsuarioState]),
    NgxsStoragePluginModule.forRoot({
      keys: ['usuario']
    })
  ],
  providers: [{ provide: RouteReuseStrategy, useClass: IonicRouteStrategy }],
  bootstrap: [AppComponent]
})
export class AppModule {}

=== environments/environment.prod.ts ===
export const environment = {
  production: true,
  //apiUrl: 'http://192.168.1.131:3000/api',
 // imageURL: 'http://192.168.1.131:3000/'
//apiUrl: 'http://10.0.2.2:3000/api'
//Internet
  //apiUrl: 'https://soil-gabriel-violation-structured.trycloudflare.com/api',
  //imageURL: 'https://soil-gabriel-violation-structured.trycloudflare.com/'

  /*PARCELA*/
apiUrl: 'http://192.168.1.200:3000/api',
imageURL: 'http://192.168.1.200:3000/'

};


=== environments/environment.ts ===
// This file can be replaced during build by using the `fileReplacements` array.
// `ng build` replaces `environment.ts` with `environment.prod.ts`.
// The list of file replacements can be found in `angular.json`.

export const environment = {
  production: true,
  //Piso y casa de padres
  //apiUrl: 'http://192.168.1.131:3000/api',
  //imageURL: 'http://192.168.1.131:3000/'
//Internet
  //apiUrl: 'https://soil-gabriel-violation-structured.trycloudflare.com/api',
  //imageURL: 'https://soil-gabriel-violation-structured.trycloudflare.com/'
 //Parcela
//apiUrl: 'http://localhost:3000/api',
//imageURL: 'http://localhost:3000/'
/*PARCELA*/
apiUrl: 'http://192.168.1.200:3000/api',
imageURL: 'http://192.168.1.200:3000/'

};

/*
 * For easier debugging in development mode, you can import the following file
 * to ignore zone related error stack frames such as `zone.run`, `zoneDelegate.invokeTask`.
 *
 * This import should be commented out in production mode because it will have a negative impact
 * on performance if an error is thrown.
 */
// import 'zone.js/plugins/zone-error';  // Included with Angular CLI.


=== theme/variables.scss ===
// For information on how to create your own theme, please see:
// http://ionicframework.com/docs/theming/


=== app/constants/categorias.const.ts ===
export interface Categoria {
    nombre: string;   // Visible para el usuario
    valor: string;    // Enviado al backend
    icono: string;
  }
  
  export const CATEGORIAS: Categoria[] = [
   // { nombre: 'Filtros',          valor: 'Filtros',          icono: 'assets/categorias/varita-magica.png' },
    { nombre: 'Fantasía',         valor: 'fantasia',         icono: 'assets/categorias/book.png' },
    { nombre: 'Aventuras',        valor: 'aventuras',        icono: 'assets/categorias/map.png' },
    { nombre: 'Terror',           valor: 'terror',           icono: 'assets/categorias/skull.png' },
    { nombre: 'C. Ficción',       valor: 'Ciencia Ficción',  icono: 'assets/categorias/ufo.png' },
    { nombre: 'Historia',         valor: 'historia',         icono: 'assets/categorias/greek-pillars.png' },
    { nombre: 'Apocalíptico',     valor: 'apocaliptico',     icono: 'assets/categorias/nuclear-bomb.png' },
    { nombre: 'Misterio',         valor: 'misterio',         icono: 'assets/categorias/footprint.png' },
    { nombre: 'Policíaca',        valor: 'policiaca',        icono: 'assets/categorias/police-car.png' },
    { nombre: 'Criminal',         valor: 'criminal',         icono: 'assets/categorias/money-bag_02.png' },
    { nombre: 'Adultos',          valor: 'adultos',          icono: 'assets/categorias/wine.png' },
    { nombre: 'Niños',            valor: 'ninos',            icono: 'assets/categorias/cubes.png' },
  ];


=== app/constants/storage.keys.ts ===
// src/app/constants/storage.keys.ts
export const STORAGE_KEYS = {
  FAVORITOS_SALAS: 'favoritos_salas',
  TOKEN: 'auth_token',
  USER_DATA: 'user_data'
};


=== app/explore-container/explore-container.component.html ===
<div id="container">
  <strong>{{ name }}</strong>
  <p>Explore <a target="_blank" rel="noopener noreferrer" href="https://ionicframework.com/docs/components">UI Components</a></p>
</div>

=== app/explore-container/explore-container.component.scss ===
#container {
  text-align: center;

  position: absolute;
  left: 0;
  right: 0;
  top: 50%;
  transform: translateY(-50%);
}

#container strong {
  font-size: 20px;
  line-height: 26px;
}

#container p {
  font-size: 16px;
  line-height: 22px;

  color: #8c8c8c;

  margin: 0;
}

#container a {
  text-decoration: none;
}

=== app/explore-container/explore-container.component.spec.ts ===
import { ComponentFixture, TestBed } from '@angular/core/testing';
import { IonicModule } from '@ionic/angular';

import { ExploreContainerComponent } from './explore-container.component';

describe('ExploreContainerComponent', () => {
  let component: ExploreContainerComponent;
  let fixture: ComponentFixture<ExploreContainerComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      declarations: [ExploreContainerComponent],
      imports: [IonicModule.forRoot()]
    }).compileComponents();

    fixture = TestBed.createComponent(ExploreContainerComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});


=== app/explore-container/explore-container.component.ts ===
import { Component, Input } from '@angular/core';

@Component({
  selector: 'app-explore-container',
  templateUrl: './explore-container.component.html',
  styleUrls: ['./explore-container.component.scss'],
  standalone: false,
})
export class ExploreContainerComponent {

  @Input() name?: string;

}


=== app/explore-container/explore-container.module.ts ===
import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';

import { IonicModule } from '@ionic/angular';

import { ExploreContainerComponent } from './explore-container.component';

@NgModule({
  imports: [ CommonModule, FormsModule, IonicModule],
  declarations: [ExploreContainerComponent],
  exports: [ExploreContainerComponent]
})
export class ExploreContainerComponentModule {}


=== app/models/sala.model.ts ===
export interface SalaCaracteristica {
  tipo: 'publico_objetivo' | 'restriccion' | 'accesibilidad' | string;
  nombre: string;
  es_apta: boolean;
}

export interface SalaImagen {
  url: string;
  tipo: 'gallery' | 'cover' | string;
}

export interface SalaPrecioPorJugadores {
  jugadores: number;
  total: string; // viene como DECIMAL en string desde la API
  pp: string;    // viene como DECIMAL en string desde la API
}

export interface Sala {
  id_sala: number;
  id_local: number;
  id_tipo_reserva?: number | null;

  nombre: string;
  descripcion?: string | null;
  tiempo?: string | number | null;
  jugadores_min?: number | null;
  jugadores_max?: number | null;
  actores?: boolean | null;
  experiencia_por_jugador?: number | string | null;
  cover_url?: string | null;
  dificultad?: string | null;
  descripcion_corta?: string | null;

  // Datos derivados/relacionados
  distancia_km?: number | null;
  precio_min_pp?: string | null;
  precio_max_pp?: string | null;
  nombre_local?: string | null;

  // Derivados solo en front
  jugadores?: string; // ej. "4 - 20"

  // Dirección
  id_direccion?: number | null;
  tipo_via?: string | null;
  nombre_via?: string | null;
  numero?: string | null;
  ampliacion?: string | null;
  codigo_postal?: string | null;
  ciudad?: string | null;
  codigo_google?: string | null;
  latitud?: number | null;
  longitud?: number | null;

  // Empresa / reserva
  empresa?: string | null;
  tipo_reserva?: string | null;

  // Listas
  categorias?: string[];
  idiomas?: string[];
  tipo_sala?: string[];

  // Solo en detalle
  caracteristicas?: SalaCaracteristica[];
  imagenes?: SalaImagen[];
  precios_por_jugadores?: SalaPrecioPorJugadores[];
}


=== app/models/usuario.model.ts ===
export interface UsuarioStateModel {
  direccion: string | null;
  ciudad: string | null;
  lat: number | null;
  lng: number | null;
}

=== app/services/favoritos.service.ts ===
// src/app/services/favoritos.service.ts
import { Injectable } from '@angular/core';
import { BehaviorSubject, map } from 'rxjs';
import { Preferences } from '@capacitor/preferences';
import { STORAGE_KEYS } from '../constants/storage.keys';

@Injectable({ providedIn: 'root' })
export class FavoritosService {
  private favoritosSubject = new BehaviorSubject<number[]>([]);
  favoritos$ = this.favoritosSubject.asObservable(); // expone solo lectura

  constructor() {
    this.loadFavoritos(); // cuando se crea el servicio
  }

  private async loadFavoritos() {
    const { value } = await Preferences.get({ key: STORAGE_KEYS.FAVORITOS_SALAS });
    const ids = value ? JSON.parse(value) : [];
    this.favoritosSubject.next(ids);
  }

  async toggleFavorito(id: number) {
    const current = this.favoritosSubject.value;
    const updated = current.includes(id)
      ? current.filter(favId => favId !== id)
      : [...current, id];

    this.favoritosSubject.next(updated);
    await Preferences.set({
      key: STORAGE_KEYS.FAVORITOS_SALAS,
      value: JSON.stringify(updated)
    });
  }

  isFavorito(id: number): boolean {
    return this.favoritosSubject.value.includes(id);
  }

  getFavoritoStatusStream(id: number) {
    return this.favoritos$.pipe(
      map(favoritos => favoritos.includes(id))
    );
  }
}


=== app/services/sala.service.ts ===
import { Injectable } from '@angular/core';
import { HttpClient, HttpParams } from '@angular/common/http';
import { environment } from '../../environments/environment';
import { Sala } from '../models/sala.model';
import { Observable, map } from 'rxjs';
import { enrichSala } from '../utils/sala.utils';

@Injectable({ providedIn: 'root' })
export class SalaService {
  private baseUrl = `${environment.apiUrl}/salas`;

  constructor(private http: HttpClient) {}

  getSalas(filters: any = {}): Observable<Sala[]> {
    let params = new HttpParams();
    for (const key in filters) {
      if (filters[key]) {
        params = params.set(key, filters[key]);
      }
    }
    console.log(this.http.get<Sala[]>(this.baseUrl, { params }));
     return this.http.get<Sala[]>(this.baseUrl, { params }).pipe(
      map((salas) => salas.map(enrichSala))
    );
  }
}


=== app/services/socket.service.ts ===
import { Injectable } from '@angular/core';
import { environment } from '../../environments/environment';
import { io, Socket } from 'socket.io-client';
import { fromEvent, Observable } from 'rxjs';

@Injectable({ providedIn: 'root' })
export class SocketService {
  private socket: Socket;

  connect(): void {
    const baseUrl = environment.apiUrl.replace('/api', '');
    this.socket = io(baseUrl, {
      transports: ['websocket'],
      autoConnect: true
    });
  }

  listenSalasUpdated(): Observable<any> {
console.log('listenSalasUpdated CLIENT');
    return fromEvent(this.socket, 'salasUpdated');
  }
  listenSalaModificada(): Observable<any> {
    console.log('listenSalaModificada CLIENT');
  return fromEvent(this.socket, 'salaActualizada');
  }
  disconnect(): void {
    if (this.socket) {
      this.socket.disconnect();
    }
  }
}


=== app/services/ubicacion.service.ts ===
// ==============================
// 🌐 src/app/services/ubicacion.service.ts
// ==============================

import { Injectable } from '@angular/core';
import { HttpClient, HttpParams } from '@angular/common/http';
import { environment } from '../../environments/environment';
import { Observable } from 'rxjs';
import { tap } from 'rxjs/operators';

export interface UbicacionResultado {
  direccion: string;
  ciudad: string;
  lat: number;
  lng: number;
  // Nuevos campos proporcionados por el backend (opcionales para compatibilidad)
  via?: string | null;
  via_tipo?: string | null;
  via_nombre?: string | null;
  numero?: string | null;
  codigo_postal?: string | null;
  barrio?: string | null;
  provincia?: string | null;
  comunidad?: string | null;
  pais?: string | null;
  pais_code?: string | null;
  place_id?: string | null;
}

@Injectable({ providedIn: 'root' })
export class UbicacionService {
  private baseUrl = `${environment.apiUrl}/ubicacion`;

  constructor(private http: HttpClient) {}

  /** Autocompleta mientras se escribe */
  autocomplete(input: string): Observable<string[]> {
    const params = new HttpParams().set('input', input);
    return this.http.get<string[]>(`${this.baseUrl}/autocomplete`, { params });
  }

  /** Geocodifica una dirección seleccionada */
  geocode(description: string): Observable<UbicacionResultado> {
    const params = new HttpParams().set('description', description);
    return this.http
      .get<UbicacionResultado>(`${this.baseUrl}/geocode`, { params })
      .pipe(tap((res) => this.logUbicacionResultado('geocode', res)));
  }

  /** Desde coordenadas GPS */
  reverseGeocode(lat: number, lng: number): Observable<UbicacionResultado> {
    const params = new HttpParams().set('lat', lat.toString()).set('lng', lng.toString());
    return this.http
      .get<UbicacionResultado>(`${this.baseUrl}/reverse`, { params })
      .pipe(tap((res) => this.logUbicacionResultado('reverse', res)));
  }

  // Log estructurado de todos los campos que puede devolver el backend
  private logUbicacionResultado(context: 'geocode' | 'reverse', res: UbicacionResultado) {
    try {
      // agrupado y colapsado para no saturar la consola
      console.groupCollapsed(`UbicacionService:${context} UbicacionResultado`);
      console.log('direccion:', res.direccion);
      console.log('ciudad:', res.ciudad);
      console.log('lat:', res.lat);
      console.log('lng:', res.lng);
      console.log('via:', res.via ?? null);
      console.log('via_tipo:', res.via_tipo ?? null);
      console.log('via_nombre:', res.via_nombre ?? null);
      console.log('numero:', res.numero ?? null);
      console.log('codigo_postal:', res.codigo_postal ?? null);
      console.log('barrio:', res.barrio ?? null);
      console.log('provincia:', res.provincia ?? null);
      console.log('comunidad:', res.comunidad ?? null);
      console.log('pais:', res.pais ?? null);
      console.log('pais_code:', res.pais_code ?? null);
      console.log('place_id:', res.place_id ?? null);
      console.groupEnd();
    } catch {
      // fallback simple por si algo falla
      console.log(`UbicacionService:${context} UbicacionResultado:`, res);
    }
  }
}


=== app/states/usuario.state.ts ===
// src/app/states/usuario/usuario.state.ts
import { State, Action, StateContext, Selector } from '@ngxs/store';
import { UsuarioStateModel } from '../models/usuario.model';

export class SetUbicacionUsuario {
  static readonly type = '[Usuario] Set Ubicacion';
  constructor(public payload: { direccion: string, ciudad: string, lat: number, lng: number }) {}
}

export class ClearUbicacionUsuario {
  static readonly type = '[Usuario] Clear Ubicacion';
}



@State<UsuarioStateModel>({
  name: 'usuario',
  defaults: {
    direccion: null,
    ciudad: null,
    lat: null,
    lng: null
  }
})
export class UsuarioState {
  @Selector()
  static ubicacion(state: UsuarioStateModel) {
    return {
      direccion: state.direccion,
      ciudad: state.ciudad,
      lat: state.lat,
      lng: state.lng
    };
  }

  @Action(SetUbicacionUsuario)
  setUbicacion(ctx: StateContext<UsuarioStateModel>, action: SetUbicacionUsuario) {
    ctx.patchState({
      ...action.payload
    });
  }

  @Action(ClearUbicacionUsuario)
  clearUbicacion(ctx: StateContext<UsuarioStateModel>) {
    ctx.setState({
      direccion: null,
      ciudad: null,
      lat: null,
      lng: null
    });
  }

}

=== app/tab1/tab1-routing.module.ts ===
import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';
import { Tab1Page } from './tab1.page';

const routes: Routes = [
  {
    path: '',
    component: Tab1Page,
  }
];

@NgModule({
  imports: [RouterModule.forChild(routes)],
  exports: [RouterModule]
})
export class Tab1PageRoutingModule {}


=== app/tab1/tab1.module.ts ===
import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { IonicModule } from '@ionic/angular';
import { Tab1Page } from './tab1.page';
import { Tab1PageRoutingModule } from './tab1-routing.module';

import { HttpClientModule } from '@angular/common/http'; // 🔥 IMPORTANTE
import { SalaCardComponent } from '../components/sala-card/sala-card.component';
import { DireccionPickerComponent } from '../components/direccion-picker/direccion-picker.component';
import { FiltersModalComponent } from '../components/filter-modal/filters-modal.component';

@NgModule({
  declarations: [Tab1Page],
  imports: [
    CommonModule,
    FormsModule,
    IonicModule,
    Tab1PageRoutingModule,
    FiltersModalComponent ,
    HttpClientModule, // 💥 Añade esto si no estaba
    SalaCardComponent,
    DireccionPickerComponent

  ]
})
export class Tab1PageModule {}


=== app/tab1/tab1.page.html ===
<ion-header class="ion-no-border">
  <div class="top-actions">
    <app-direccion-picker (ciudadSeleccionada)="onCiudadSeleccionada($event)"></app-direccion-picker>
    <ion-button fill="clear" size="small" class="btn-notificaciones" (click)="onNotificacionesClick()">
      <ion-icon name="notifications-outline"></ion-icon>
    </ion-button>
  </div>
</ion-header>

<ion-content #pageContent scrollEvents="true" (ionScroll)="onScroll($event)">

  <!-- Overlay transparente que impide el scroll (touch + wheel) cuando no hay salas -->
  <div class="no-scroll-overlay" *ngIf="numeroSalas === 0" (wheel)="$event.preventDefault()"></div>

  <!-- Header colapsable pegajoso -->
  <div #collapsible class="collapsible">
    <div class="collapsible-inner">
      <ion-toolbar>
        <div class="searchbar-con-boton">
          <ion-searchbar
            placeholder="Buscar sala o empresa..."
            [(ngModel)]="filters.query"
            (ionInput)="reloadSalas()"
            debounce="300"
            showCancelButton="never"
            animated>
          </ion-searchbar>

          <ion-button fill="clear" size="small" class="btn-filtros" (click)="openFilters()">
            <ion-icon name="options-outline"></ion-icon>
            <span *ngIf="filtrosActivos > 0" class="reset-btn__badge">{{ filtrosActivos }}</span>
          </ion-button>

          <ion-button fill="clear" size="small" class="btn-mapa" (click)="onMapaClick()">
            <ion-icon name="map-outline"></ion-icon>
          </ion-button>
        </div>

        <div class="categorias-scroll">
          <div
            class="categoria-item"
            *ngFor="let cat of categorias"
            [class.active]="categoriasActivas.includes(cat.valor)"
            (click)="selectCategoria(cat.valor)">
            <img [src]="cat.icono" alt="{{ cat.nombre }}" />
            <div class="nombre">{{ cat.nombre }}</div>
          </div>
        </div>
      </ion-toolbar>
    </div>
  </div>

  <!-- 👇 Spacer que sí cambia de altura (empuja las cards) -->


  <!-- Lista de salas -->
  <ng-container *ngIf="salas$ | async as salas">
    <ng-container *ngIf="salas.length > 0; else noResultados">
      <app-sala-card class="sala-card" *ngFor="let sala of salas; trackBy: trackBySalaId" [sala]="sala">
      </app-sala-card>
    </ng-container>
  </ng-container>

  <ng-template #noResultados>
    <div class="no-resultados-wrapper">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
           stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="no-resultados-icono">
        <path d="m13.5 8.5-5 5" />
        <path d="m8.5 8.5 5 5" />
        <circle cx="11" cy="11" r="8" />
        <path d="m21 21-4.3-4.3" />
      </svg>
    </div>
  </ng-template>

  <ion-infinite-scroll threshold="100px" (ionInfinite)="loadMore($event)" *ngIf="!todasCargadas">
    <ion-infinite-scroll-content loadingSpinner="bubbles" loadingText="Cargando más salas...">
    </ion-infinite-scroll-content>
  </ion-infinite-scroll>
</ion-content>


=== app/tab1/tab1.page.scss ===
/* ====== Header fijo (fila superior) ====== */
/* Header fijo (fila superior) */
.top-actions {
  display: grid;
  grid-template-columns: 1fr auto; /* la dirección ocupa todo; la campana queda al borde */
  align-items: center;
  column-gap: 8px;
  padding: 0 8px;

  /* el picker puede crecer y también encogerse sin romper el layout */
  app-direccion-picker {
    min-width: 0; /* clave para que el texto no fuerce overflow del grid */
  }

  .btn-notificaciones {
    width: 32px;
    height: 32px;
    min-width: 32px;
    margin: 0;
    justify-self: end; /* al borde derecho */
    --padding-start: 0;
    --padding-end: 0;
    --border-radius: 12px;
    font-size: 20px;
  }
}

/* ====== Bloque colapsable pegajoso dentro del CONTENT ====== */

/* Contenedor pegajoso del header (NO tiene fondo) */
.collapsible {
  position: sticky;
  top: 0;                       /* o var(--ion-safe-area-top, 0) si lo necesitas */
  z-index: 1000;
  overflow: hidden;
  background: transparent;
  height: var(--collapsible-h, auto); /* pero TS la fija a px */
  border-bottom: 1px solid rgba(0,0,0,0.06);
   pointer-events: none;
}

/* El que se mueve: usa transform 3D y aisla repaints */
.collapsible-inner {
  will-change: transform;
  transform: translate3d(0, calc(-1 * var(--header-offset, 0px)), 0);
  backface-visibility: hidden;
  contain: paint;               /* aisla repaints del resto */
  background: var(--ion-background-color, #fff);
  box-shadow: 0 2px 10px rgba(0,0,0,0.06);
  pointer-events: auto; 
}

/* ====== Searchbar + botones (tus estilos) ====== */
ion-searchbar {
  --background: #f1f1f1;
  --border-radius: 16px;
  --box-shadow: none;
  --padding-start: 12px;
  --padding-end: 12px;
  --placeholder-color: #999;

  margin: 12px auto 0 auto;
  max-width: 100%;
  height: 40px;
  --height: 40px;

  input {
    font-size: 14px;
  }
}

.searchbar-con-boton {
  display: flex;
  align-items: center;
  padding: 0 8px;
  gap: 6px;

  ion-searchbar {
    flex: 1;
    margin: 12px 0 0 0;
    max-width: calc(100% - 96px); // 2 botones de 48px
  }

  ion-button {
    margin-top: 12px;
    width: 40px;
    height: 40px;
    min-width: 40px;
    --padding-start: 0;
    --padding-end: 0;
  }

  .btn-filtros {
    --color: var(--ion-color-success);
    --border-radius: 12px;
    font-size: 20px;
    position: relative;
    --overflow: visible !important; 
  }

  .btn-mapa {
    --color: #3399ff;
    --border-radius: 12px;
    font-size: 20px;
  }
}

/* ====== Categorías (tus estilos) ====== */
.categorias-scroll {
  display: flex;
  overflow-x: auto;
  padding: 10px 0;
  gap: 14px;
  margin-bottom: 8px;
  padding-left: 12px;
  scroll-snap-type: x mandatory;

  &::-webkit-scrollbar {
    display: none;
  }
}

.categoria-item {
  position: relative;
  display: flex;
  flex-direction: column;
  align-items: center;
  min-width: 70px;
  cursor: pointer;
  opacity: 0.6;
  scroll-snap-align: start;
  transition: opacity 0.2s ease, transform 0.2s ease;
  user-select: none;

  &.active {
    opacity: 1;
    transform: rotate(5deg) scale(1.05);
  }

  &.active::after {
    content: '';
    position: absolute;
    top: -6px;
    left: 6px;
    width: 56px;
    height: 56px;
    background: #a2e3b1;
    border-radius: 50% 40% 50% 60% / 60% 50% 40% 50%;
    z-index: 1;
    filter: blur(2px);
    opacity: 0.6;
    transition: all 0.3s ease;
  }

  img {
    width: 40px;
    height: 40px;
    border-radius: 10px;
    object-fit: cover;
    transition: box-shadow 0.3s ease;
    z-index: 2;
  }

  .nombre {
    margin-top: 3px;
    font-size: 12px;
    text-align: center;
    font-weight: 500;
    color: #333;
    z-index: 2;
  }
}

/* ====== Varios (tuyos, sin cambios) ====== */
.spinner-global {
  display: flex;
  justify-content: center;
  align-items: center;
  height: 80vh;
}

.oculto { display: none; }

.no-resultados-wrapper {
  height: 100%;
  width: 100%;
  background-color: #e5f9e7;
  display: flex;
  justify-content: center;
  align-items: center;
  overflow: hidden;
  flex: 1;
}

.no-scroll-overlay {
  position: absolute;
  inset: 0; /* cubrir todo el ion-content */
  /* debe quedar POR DEBAJO del header colapsable (z-index: 1000) para permitir clicks en él */
  z-index: 900;
  background: transparent;
  touch-action: none; /* evita gestos táctiles */
}

.no-resultados-icono {
  width: 50vw;
  height: auto;
  max-width: 280px;
  stroke: #34a853;
}

ion-content {
  --padding-bottom: 0;
  --padding-top: 0;
  height: 100%;
  --background: #f8f9fa url("data:image/svg+xml,%3Csvg width='20' height='20' viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='%23dce1e6' fill-opacity='0.4' fill-rule='evenodd'%3E%3Ccircle cx='3' cy='3' r='3'/%3E%3Ccircle cx='13' cy='13' r='3'/%3E%3C/g%3E%3C/svg%3E");
}

.reset-btn__badge {
  position: absolute;
  top: -4px;
  right: -4px;
  min-width: 18px;
  height: 18px;
  padding: 0 4px;
  border-radius: 999px;
  background: var(--ion-color-danger);
  color: #fff;
  font-size: 11px;
  font-weight: 600;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 2px 4px rgba(0,0,0,0.25);
  transition: transform 180ms ease, opacity 180ms ease;
}


=== app/tab1/tab1.page.ts ===
// tab1.page.ts
import { Component, OnInit, OnDestroy, ViewChild, AfterViewInit, ElementRef } from '@angular/core';
import { Store } from '@ngxs/store';
import { ModalController, IonContent } from '@ionic/angular';
import { GetSalas, AppendSalas, SalaState, UpdateSala } from '../states/salas/salas.state';
import { SocketService } from '../services/socket.service';
import { FiltersModalComponent } from '../components/filter-modal/filters-modal.component';
import { Haptics, ImpactStyle } from '@capacitor/haptics';
import { CATEGORIAS } from '../constants/categorias.const';
import { Subscription } from 'rxjs';
import { IonInfiniteScroll } from '@ionic/angular';
import { UsuarioState } from '../states/usuario.state';

@Component({
  selector: 'app-tab1',
  templateUrl: './tab1.page.html',
  styleUrls: ['./tab1.page.scss'],
  standalone: false
})
export class Tab1Page implements OnInit, OnDestroy, AfterViewInit {
  categorias = CATEGORIAS;
  salas$ = this.store.select(SalaState.salas);
  filters: any = {};
  categoriasActivas: string[] = [];
  numeroSalas = 0;
  private subs: Subscription[] = [];

  @ViewChild(IonInfiniteScroll) infiniteScroll: IonInfiniteScroll;
  @ViewChild(IonContent) pageContent!: IonContent;

  // Header movible (sticky) dentro del ion-content
  @ViewChild('collapsible', { static: false }) collapsibleRef!: ElementRef<HTMLDivElement>;



  
  private latUsuario: number | null = null;
  private lngUsuario: number | null = null;

  limit = 20;
  offset = 0;
  todasCargadas = false;
  cargando = false;
  observer!: IntersectionObserver;

  // Estado del colapso/movimiento
  private maxCollapse = 0;     // altura natural del bloque colapsable
  private headerOffset = 0;    // desplazamiento consumido (0..maxCollapse)
  private lastY = 0;           // último scrollTop para Δ
  private ticking = false;
  private ro?: ResizeObserver;
  private scrollEl!: HTMLElement;
    


    constructor(
    private store: Store,
    private socketService: SocketService,
    private modalCtrl: ModalController
  ) {}

  ngOnInit() {
    this.subs.push(this.salas$.subscribe(salas => (this.numeroSalas = salas.length)));

    this.subs.push(
      this.store.select(UsuarioState.ubicacion).subscribe(ubicacion => {
        const { ciudad, lat, lng } = ubicacion || {};
        this.latUsuario = lat ?? null;
        this.lngUsuario = lng ?? null;
        if (ciudad) {
          this.filters = { ...this.filters, ciudad };
        } else {
          const { ciudad: _c, ...rest } = this.filters;
          this.filters = { ...rest };
        }
      })
    );

    this.socketService.connect();
    this.subs.push(this.socketService.listenSalasUpdated().subscribe(() => this.reloadSalas()));
    this.subs.push(
      this.socketService.listenSalaModificada().subscribe(sala => {
        if (this.aplicaFiltros(sala)) this.store.dispatch(new UpdateSala(sala));
      })
    );

    this.reloadSalas();
  }

  async ngAfterViewInit() {
    // (opcional) infinito manual
    this.observer = new IntersectionObserver(entries => {
      const entry = entries[0];
      if (entry.isIntersecting && !this.cargando && !this.todasCargadas) this.loadMore();
    });

    await this.waitForToolbarReady();
    this.scrollEl = await this.pageContent.getScrollElement();
    this.measureAndFixHeaderHeight(); // fija maxCollapse y deja el contenedor sticky con altura FIJA

    // Estado inicial del movimiento
    this.headerOffset = 0;
    this.lastY = 0;
    this.setHeaderOffsetVar(0); // inner sin desplazar

    // Observa cambios de tamaño dinámicos (chips, etc.) y mantiene la proporción visible
    const el = this.collapsibleRef?.nativeElement;
    if (el && 'ResizeObserver' in window) {
      this.ro = new ResizeObserver(() => {
        const visibleAntes = Math.max(0, this.maxCollapse - this.headerOffset);
        this.measureAndFixHeaderHeight(); // recalcula maxCollapse y actualiza altura fija del contenedor
        const visibleDespues = Math.max(0, Math.min(visibleAntes, this.maxCollapse));
        this.headerOffset = Math.max(0, this.maxCollapse - visibleDespues);
        this.setHeaderOffsetVar(Math.round(this.headerOffset));
      });
      this.ro.observe(el);
    }
  }

  ngOnDestroy() {
    this.subs.forEach(s => s.unsubscribe());
    this.socketService.disconnect();
    if (this.ro) { try { this.ro.disconnect(); } catch {} this.ro = undefined; }
  }

  // ======== Scroll 1:1 — header acompaña al scroll sin umbrales ========
  onScroll(ev: any) {
    const y = ev?.detail?.scrollTop ?? 0;
    if (!this.maxCollapse) return;

    const dy = y - this.lastY;
    this.lastY = y;

    // Ocultar/mostrar a la misma velocidad del scroll, limitado al rango [0, maxCollapse]
    this.headerOffset = Math.max(0, Math.min(this.maxCollapse, this.headerOffset + dy));

    if (!this.ticking) {
      this.ticking = true;
      requestAnimationFrame(() => {
        const offset = Math.round(this.headerOffset);
        this.setHeaderOffsetVar(offset);
        this.ticking = false;
      });
    }
  }



  // ========== Utilidades de medición / estilo ==========
  private async waitForToolbarReady() {
    if ('customElements' in window && (customElements as any).whenDefined) {
      try { await (customElements as any).whenDefined('ion-toolbar'); } catch {}
    }
    const toolbar = this.collapsibleRef?.nativeElement?.querySelector('ion-toolbar') as any;
    if (toolbar?.componentOnReady) { try { await toolbar.componentOnReady(); } catch {} }
    await new Promise<void>(r => requestAnimationFrame(() => r()));
  }

private measureAndFixHeaderHeight() {
  const el = this.collapsibleRef?.nativeElement;
  if (!el) return;

  el.style.height = 'auto';
  let h = el.scrollHeight || el.getBoundingClientRect().height || 0;
  if (h < 1) h = 120;
  this.maxCollapse = Math.ceil(h);

  // altura FIJA del contenedor sticky
  el.style.height = `${this.maxCollapse}px`;
  // Clampear offset si la altura cambió
  this.headerOffset = Math.max(0, Math.min(this.headerOffset, this.maxCollapse));
}

  private setHeaderOffsetVar(px: number) {
    const el = this.collapsibleRef?.nativeElement;
    if (!el) return;
  el.style.setProperty('--header-offset', `${px}px`);
  }

  // ========= Lógica existente =========
  async selectCategoria(valor: string) {
    if (valor === 'Filtros') { await this.openFilters(); return; }
    const index = this.categoriasActivas.indexOf(valor);
    if (index > -1) this.categoriasActivas.splice(index, 1);
    else this.categoriasActivas.push(valor);

    this.filters = this.categoriasActivas.length === 0
      ? { ...this.filters, categorias: undefined }
      : { ...this.filters, categorias: [...this.categoriasActivas] };

    await Haptics.impact({ style: ImpactStyle.Light });
    this.reloadSalas();
  }

  async openFilters() {
    const modal = await this.modalCtrl.create({
      component: FiltersModalComponent,
      componentProps: { filtrosActuales: this.filters },
      showBackdrop: true,
      cssClass: 'filters-modal-sheet',
      breakpoints: [0, 0.5, 1],
      initialBreakpoint: 1
    });

    await modal.present();
    const { data } = await modal.onDidDismiss();
    if (data) {
      this.filters = { ...this.filters, ...data };
      this.categoriasActivas = this.filters.categorias ? [...this.filters.categorias] : [];
      this.reloadSalas();
    }
  }

  onCiudadSeleccionada(ciudad: string | null) {
    if (ciudad) {
      this.filters = { ...this.filters, ciudad };
    } else {
      const { ciudad: _c, distancia_km: _d, coordenadas: _coords, ...rest } = this.filters;
      this.filters = { ...rest };
    }
    this.reloadSalas();
  }

  aplicaFiltros(sala: any): boolean {
    const q = this.filters.query?.toLowerCase() || '';
    const nombre = sala.nombre?.toLowerCase() || '';
    const empresa = sala.empresa?.toLowerCase() || '';
    if (q && !nombre.includes(q) && !empresa.includes(q)) return false;
    if (this.filters.categorias?.length > 0) {
      const categorias = sala.categorias || [];
      const intersecta = categorias.some(c => this.filters.categorias.includes(c));
      if (!intersecta) return false;
    }
    return true;
  }

  private getFiltros(offset: number): any {
    const filtros = { ...this.filters, offset, limit: this.limit };
    if (!filtros.distancia_km) {
      delete filtros.lat; delete filtros.lng;
    } else {
      filtros.lat = this.latUsuario;
      filtros.lng = this.lngUsuario;
    }
    return filtros;
  }

  reloadSalas() {
    this.pageContent?.scrollToTop(0);

    // Reset visual del header (totalmente visible)
    this.headerOffset = 0;
    this.lastY = 0;
    this.setHeaderOffsetVar(0);

    this.offset = 0;
    this.todasCargadas = false;
    this.cargando = true;

    const filtros = this.getFiltros(0);
    this.store.dispatch(new GetSalas(filtros)).subscribe({
      next: () => { this.offset = this.limit; this.cargando = false; },
      error: (err) => { this.cargando = false; console.error('Error al cargar salas', err); }
    });
  }

  loadMore(event?: any) {
    if (this.cargando || this.todasCargadas) { event?.target?.complete(); return; }
    this.cargando = true;

    const filtros = this.getFiltros(this.offset);
    this.store.dispatch(new AppendSalas(filtros)).subscribe((res: any) => {
      const recibidas = res.sala?.cantidad || 0;
      this.offset += recibidas;
      if (recibidas === 0 || recibidas < this.limit) this.todasCargadas = true;
      event?.target?.complete();
      this.cargando = false;
    });
  }

  trackBySalaId(_i: number, sala: any): any { return sala.id_sala; }
  onMapaClick() { console.log('🗺️ Click en botón de mapa (a implementar)'); }
  onNotificacionesClick() { console.log('🔔 Notificaciones clickeadas'); }

  get filtrosActivos(): number {
    const { ciudad, query, ...rest } = this.filters;
    let total = 0;
    Object.values(rest).forEach(value => {
      if (Array.isArray(value)) total += value.length;
      else if (value !== undefined && value !== null && value !== '' && value !== false) total += 1;
    });
    return total;
  }
}




=== app/tab2/tab2-routing.module.ts ===
import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';
import { Tab2Page } from './tab2.page';

const routes: Routes = [
  {
    path: '',
    component: Tab2Page,
  }
];

@NgModule({
  imports: [RouterModule.forChild(routes)],
  exports: [RouterModule]
})
export class Tab2PageRoutingModule {}


=== app/tab2/tab2.module.ts ===
import { IonicModule } from '@ionic/angular';
import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { Tab2Page } from './tab2.page';
import { ExploreContainerComponentModule } from '../explore-container/explore-container.module';

import { Tab2PageRoutingModule } from './tab2-routing.module';

@NgModule({
  imports: [
    IonicModule,
    CommonModule,
    FormsModule,
    ExploreContainerComponentModule,
    Tab2PageRoutingModule
  ],
  declarations: [Tab2Page]
})
export class Tab2PageModule {}


=== app/tab2/tab2.page.html ===
<ion-header [translucent]="true">
  <ion-toolbar>
    <ion-title>
      Tab 2
    </ion-title>
  </ion-toolbar>
</ion-header>

<ion-content>
  <ion-header collapse="condense">
    <ion-toolbar>
      <ion-title size="large">Tab 2 Prueba2</ion-title>
    </ion-toolbar>
  </ion-header>

  <app-explore-container name="Tab 2 page Prueba2"></app-explore-container>
</ion-content>


=== app/tab2/tab2.page.scss ===


=== app/tab2/tab2.page.spec.ts ===
import { ComponentFixture, TestBed } from '@angular/core/testing';
import { IonicModule } from '@ionic/angular';

import { ExploreContainerComponentModule } from '../explore-container/explore-container.module';

import { Tab2Page } from './tab2.page';

describe('Tab2Page', () => {
  let component: Tab2Page;
  let fixture: ComponentFixture<Tab2Page>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      declarations: [Tab2Page],
      imports: [IonicModule.forRoot(), ExploreContainerComponentModule]
    }).compileComponents();

    fixture = TestBed.createComponent(Tab2Page);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});


=== app/tab2/tab2.page.ts ===
import { Component } from '@angular/core';

@Component({
  selector: 'app-tab2',
  templateUrl: 'tab2.page.html',
  styleUrls: ['tab2.page.scss'],
  standalone: false,
})
export class Tab2Page {

  constructor() {
    console.log("Pagina2")
  }

}


=== app/tab3/tab3-routing.module.ts ===
import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';
import { Tab3Page } from './tab3.page';

const routes: Routes = [
  {
    path: '',
    component: Tab3Page,
  }
];

@NgModule({
  imports: [RouterModule.forChild(routes)],
  exports: [RouterModule]
})
export class Tab3PageRoutingModule {}


=== app/tab3/tab3.module.ts ===
import { IonicModule } from '@ionic/angular';
import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { Tab3Page } from './tab3.page';
import { ExploreContainerComponentModule } from '../explore-container/explore-container.module';

import { Tab3PageRoutingModule } from './tab3-routing.module';

@NgModule({
  imports: [
    IonicModule,
    CommonModule,
    FormsModule,
    ExploreContainerComponentModule,
    Tab3PageRoutingModule
  ],
  declarations: [Tab3Page]
})
export class Tab3PageModule {}


=== app/tab3/tab3.page.html ===
<ion-header [translucent]="true">
  <ion-toolbar>
    <ion-title>
      Tab 3
    </ion-title>
  </ion-toolbar>
</ion-header>

<ion-content>
  <ion-header collapse="condense">
    <ion-toolbar>
      <ion-title size="large">Tab 3</ion-title>
    </ion-toolbar>
  </ion-header>

  <app-explore-container name="Tab 3 page"></app-explore-container>
</ion-content>


=== app/tab3/tab3.page.scss ===


=== app/tab3/tab3.page.spec.ts ===
import { ComponentFixture, TestBed } from '@angular/core/testing';
import { IonicModule } from '@ionic/angular';

import { ExploreContainerComponentModule } from '../explore-container/explore-container.module';

import { Tab3Page } from './tab3.page';

describe('Tab3Page', () => {
  let component: Tab3Page;
  let fixture: ComponentFixture<Tab3Page>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      declarations: [Tab3Page],
      imports: [IonicModule.forRoot(), ExploreContainerComponentModule]
    }).compileComponents();

    fixture = TestBed.createComponent(Tab3Page);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});


=== app/tab3/tab3.page.ts ===
import { Component } from '@angular/core';

@Component({
  selector: 'app-tab3',
  templateUrl: 'tab3.page.html',
  styleUrls: ['tab3.page.scss'],
  standalone: false,
})
export class Tab3Page {

  constructor() {
    console.log("Pagina3")
  }

}


=== app/tabs/tabs-routing.module.ts ===
import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';
import { TabsPage } from './tabs.page';

const routes: Routes = [
  {
    path: '',
    component: TabsPage,
    children: [
      {
        path: 'tab1',
        loadChildren: () => import('../tab1/tab1.module').then(m => m.Tab1PageModule)
      },
      {
        path: 'tab2',
        loadChildren: () => import('../tab2/tab2.module').then(m => m.Tab2PageModule)
      },
      {
        path: 'tab3',
        loadChildren: () => import('../tab3/tab3.module').then(m => m.Tab3PageModule)
      },
      {
        path: '',
        redirectTo: '/tabs/tab1',
        pathMatch: 'full'
      }
    ]
  },
  {
    path: '',
    redirectTo: '/tabs/tab1',
    pathMatch: 'full'
  }
];

@NgModule({
  imports: [RouterModule.forChild(routes)],
  exports: [RouterModule] // <--- FALTA ESTO
})
export class TabsPageRoutingModule {}


=== app/tabs/tabs.module.ts ===
import { IonicModule } from '@ionic/angular';
import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';

import { TabsPageRoutingModule } from './tabs-routing.module';

import { TabsPage } from './tabs.page';

@NgModule({
  imports: [
    IonicModule,
    CommonModule,
    FormsModule,
    TabsPageRoutingModule
  ],
  declarations: [TabsPage]
})
export class TabsPageModule {}


=== app/tabs/tabs.page.html ===
<ion-tabs>

  <ion-tab-bar slot="bottom">
    <ion-tab-button tab="tab1" href="/tabs/tab1">
      <ion-icon name="key-outline"></ion-icon>
      <ion-label>Salas</ion-label>
    </ion-tab-button>

    <ion-tab-button tab="tab2" href="/tabs/tab2">
      <ion-icon name="ellipse"></ion-icon>
      <ion-label>Tab 2</ion-label>
    </ion-tab-button>

    <ion-tab-button tab="tab3" href="/tabs/tab3">
      <ion-icon name="square"></ion-icon>
      <ion-label>Tab 3</ion-label>
    </ion-tab-button>
  </ion-tab-bar>
</ion-tabs>


=== app/tabs/tabs.page.scss ===



=== app/tabs/tabs.page.spec.ts ===
import { CUSTOM_ELEMENTS_SCHEMA } from '@angular/core';
import { ComponentFixture, TestBed } from '@angular/core/testing';

import { TabsPage } from './tabs.page';

describe('TabsPage', () => {
  let component: TabsPage;
  let fixture: ComponentFixture<TabsPage>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      declarations: [TabsPage],
      schemas: [CUSTOM_ELEMENTS_SCHEMA],
    }).compileComponents();
  });

  beforeEach(() => {
    fixture = TestBed.createComponent(TabsPage);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});


=== app/tabs/tabs.page.ts ===
import { Component } from '@angular/core';

@Component({
  selector: 'app-tabs',
  templateUrl: 'tabs.page.html',
  styleUrls: ['tabs.page.scss'],
  standalone: false,
})
export class TabsPage {

  constructor() {}

}


=== app/utils/sala.utils.ts ===
import { Sala } from '../models/sala.model';

/**
 * Enriches a Sala with a formatted jugadores string
 * combining jugadores_min and jugadores_max.
 */
export function enrichSala(sala: Sala): Sala {
  return {
    ...sala,
    jugadores: `${sala.jugadores_min} - ${sala.jugadores_max}`
  };
}

=== app/states/salas/salas.actions.ts ===
export class GetSalas {
  static readonly type = '[Sala] Get';
  constructor(public filters: any = {}) {}
}

=== app/states/salas/salas.state.ts ===
import { State, Action, StateContext, Selector } from '@ngxs/store';
import { Injectable } from '@angular/core';
import { SalaService } from 'src/app/services/sala.service';
import { Sala } from 'src/app/models/sala.model';
import { map, tap } from 'rxjs/operators';
import { enrichSala } from 'src/app/utils/sala.utils';

export class GetSalas {
  static readonly type = '[Sala] Get';
  constructor(public filtros?: any) {}
}

export class AppendSalas {
  static readonly type = '[Sala] Append';
  constructor(public filtros?: any) {}
}

export class UpdateSala {
  static readonly type = '[Sala] Update';
  constructor(public sala: Sala) {}
}

export interface SalaStateModel {
  salas: Sala[];
  cantidad: number;
}

@State<SalaStateModel>({
  name: 'sala',
  defaults: {
    salas: [],
    cantidad: 30
  }
})
@Injectable()
export class SalaState {
  constructor(private salaService: SalaService) {}

  @Selector()
  static salas(state: SalaStateModel) {
    return state.salas;
  }

  // 🔄 Acción normal: sobrescribe salas
@Action(GetSalas)
getSalas({ patchState }: StateContext<SalaStateModel>, { filtros }: GetSalas) {
  return this.salaService.getSalas(filtros).pipe(
    tap((salas) => {
      console.log('📥 GetSalas recibió del servicio:', salas.length);
       //console.log('Filros antes de backend  ' + filtros.jugadores) 
      patchState({ salas });
    }),
    map((salas) => {
      console.log('📤 Devolviendo desde GetSalas a componente:', salas.length);
      // console.log('Filros antes de backend  ' + filtros.jugadores) 
      return { salas };
    })
  );
}

  // ➕ Acción nueva: añade salas al final (scroll infinito)
@Action(AppendSalas)
appendSalas({ getState, patchState }: StateContext<SalaStateModel>, { filtros }: AppendSalas) {
  return this.salaService.getSalas(filtros).pipe(
    tap((salas) => {
      const state = getState();
      patchState({ salas: [...state.salas, ...salas], cantidad: salas.length  });
    }),
    map((salas) => {
      return { cantidad: getState().cantidad};
    })
  );
}

    
@Action(UpdateSala)
updateSala({ patchState, getState }: StateContext<SalaStateModel>, { sala }: UpdateSala) {
  const enriched = enrichSala(sala);
  const salas = getState().salas.map(s =>
    s.id_sala === enriched.id_sala ? enriched : s
  );
  patchState({ salas });
}
}


=== app/components/direccion-picker/direccion-picker.component.html ===
<div class="direccion-picker">
  <ion-item button lines="none" class="trigger" (click)="togglePanel()">
    <ion-label class="ubicacion-label">
      <div class="linea-ubicacion">
        <span class="ciudad" [class.seleccionada]="ciudadActual">{{ ciudadActual ? ciudadActual : 'Dirección' }}</span>
  <ng-container *ngIf="ciudadActual && !calleNumero">
          <span class="centro">(centro)</span>
        </ng-container>
        <ng-container *ngIf="calleNumero">
          <span class="sep">·</span>
          <span #direccionEl class="direccion" [class.compacta]="direccionCompacta">{{ calleNumero }}</span>
        </ng-container>
      </div>
    </ion-label>
    <ion-icon name="chevron-down-outline" slot="end"></ion-icon>
  </ion-item>

  <!-- Modal tipo hoja al 50% -->
  <ion-modal
    [isOpen]="abierto"
    [initialBreakpoint]="initialBreakpoint"
    [breakpoints]="breakpoints"
    (didDismiss)="onModalDismiss()">
    <ng-template>
      <ion-header class="modal-header">
        <div class="header-content">
          <h2>Seleccionar dirección</h2>
          <ion-icon name="close-outline" class="close-icon" (click)="togglePanel()"></ion-icon>
        </div>
      </ion-header>

      <ion-content class="modal-content">
        <div class="top-actions">
          <ion-button size="small" fill="solid" color="success" class="action-btn locate-btn" (click)="usarMiUbicacion()">
            <ion-icon name="locate" slot="start"></ion-icon>
            Usar mi ubicación
          </ion-button>
          <ion-button size="small" fill="outline" color="medium" class="action-btn clear-btn" (click)="borrar()">
            <ion-icon name="trash-outline" slot="start"></ion-icon>
            Borrar dirección
          </ion-button>
        </div>

        <ion-searchbar
          class="searchbar-custom"
          animated="true"
          showClearButton="focus"
          searchIcon="search-outline"
          enterkeyhint="search"
          inputmode="search"
          [(ngModel)]="query"
          (ionInput)="buscar()"
          showCancelButton="never"
          placeholder="Buscar ciudad o dirección">
        </ion-searchbar>

        <!-- Dirección completa seleccionada, centrada; se muestra solo cuando no hay autocompletados -->
        <div class="direccion-completa-wrapper" *ngIf="direccionActual && predicciones.length === 0">
          <div class="direccion-completa" role="note" aria-label="Ubicación actual seleccionada">
            <ion-badge color="success" class="badge-actual">
              <ion-icon name="checkmark-circle-outline"></ion-icon>
              <span>Ubicación actual</span>
            </ion-badge>
            <div class="direccion-completa-line">
              <ion-icon name="location-outline" class="direccion-completa-icon" aria-hidden="true"></ion-icon>
              <span class="direccion-completa-text">{{ direccionActual }}</span>
            </div>
          </div>
        </div>

        <div class="predicciones-panel">
          <ion-list *ngIf="predicciones.length > 0" class="predictions-list">
            <ion-item button lines="none" class="prediction-item" *ngFor="let p of predicciones" (click)="seleccionar(p)">
              <ion-icon name="location-outline" slot="start" class="prediction-icon"></ion-icon>
              <ion-label [innerHTML]="highlight(p)"></ion-label>
              <ion-icon name="chevron-forward-outline" slot="end" class="prediction-chevron"></ion-icon>
            </ion-item>
          </ion-list>
        </div>
      </ion-content>
    </ng-template>
  </ion-modal>
</div>


=== app/components/direccion-picker/direccion-picker.component.scss ===
.direccion-picker {
  position: relative;
}

.trigger {
  cursor: pointer;
  font-size: 16px;
  --background: transparent;
}

.ubicacion-label {
  display: flex;
  flex-direction: row;
  align-items: center;
  min-width: 0;
}

.linea-ubicacion {
  display: flex;
  align-items: baseline;
  gap: 6px;
  width: 100%;
  min-width: 0;
  white-space: nowrap;
}

.ciudad {
  font-weight: 600;
  color: var(--ion-text-color, #222);
  flex: 0 0 auto; /* ciudad no se encoge */
}

.ciudad.seleccionada {
  color: var(--ion-color-success);
}

.centro {
  color: var(--ion-color-medium);
  font-weight: 500;
}

.sep {
  color: var(--ion-color-medium);
  flex: 0 0 auto;
}

.direccion {
  font-size: 13px;
  color: var(--ion-color-medium);
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  flex: 1 1 auto; /* esta parte sí se encoge y elide */
}

.direccion.compacta {
  font-size: 12px;
}
.ciudad {
  font-weight: 600;
  color: var(--ion-text-color, #222);
}

.ciudad.seleccionada {
  color: var(--ion-color-success);
}

.direccion {
  font-size: 13px;
  color: var(--ion-color-medium);
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap; /* elipsis en una sola línea */
}

/* Estilos del modal tipo hoja */
.direccion-modal::part(content) {
  border-radius: 16px 16px 0 0;
}

.modal-header {
  padding: 8px 12px;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
  border-bottom: none;
  border-radius: 0 0 8px 8px;
  z-index: 10;
  position: relative;
}

.modal-header .header-content {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.modal-header .header-content h2 {
  font-size: 18px;
  font-weight: 600;
  margin: 0;
  color: #222;
}

.modal-header .header-content .close-icon {
  font-size: 24px;
  color: #555;
  cursor: pointer;
}

.modal-content {
  --padding-top: 12px;
  --padding-start: 16px;
  --padding-end: 16px;
  --padding-bottom: 24px;
}

.top-actions {
  display: grid;
  grid-template-columns: 1fr 1fr; /* dos columnas iguales siempre */
  gap: 8px;
  margin-bottom: 8px;
  width: 100%;
  align-items: stretch;
  justify-items: center;
}

/* Estética del buscador */
.searchbar-custom {
  --background: #f6f7f9;
  --color: #1f2937;
  --placeholder-color: #9aa3af;
  --icon-color: #6b7280;
  --box-shadow: 0 6px 16px rgba(0, 0, 0, 0.06);
  --border-radius: 14px;
  --cancel-button-color: var(--ion-color-medium);
  border-radius: 14px; /* asegura radio en host */
}

.searchbar-custom .searchbar-input-container {
  border-radius: 14px;
}

.searchbar-custom:focus-within {
  --background: #ffffff;
  --box-shadow: 0 10px 24px rgba(16, 185, 129, 0.15);
}

.searchbar-custom::part(container) {
  border-radius: 14px;
}

.searchbar-custom::part(input) {
  font-size: 16px;
  font-weight: 500;
}

/* Botones acción estilo pill */
.action-btn {
  --border-radius: 999px;
  --padding-start: 12px;
  --padding-end: 12px;
  --box-shadow: 0 4px 12px rgba(16, 185, 129, 0.18);
  width: 100%; /* ocupa toda la celda de la grid */
  justify-content: center;
  text-align: center;
  white-space: normal; /* permitir que el texto se parta en dos líneas si es necesario */
}

.clear-btn {
  --border-color: #e5e7eb;
  --color: #6b7280;
}

/* Lista de predicciones */
.predictions-list {
  margin-top: 6px;
}

.prediction-item {
  --background: #f8fafc;
  --inner-padding-end: 8px;
  --padding-start: 8px;
  border-radius: 12px;
  margin: 6px 0;
  box-shadow: 0 1px 0 rgba(0,0,0,0.02);
}

.prediction-item:hover {
  --background: #ffffff;
  box-shadow: 0 6px 16px rgba(0, 0, 0, 0.06);
}

.prediction-icon {
  color: var(--ion-color-success);
  font-size: 20px;
  margin-right: 6px;
}

.prediction-chevron {
  color: #94a3b8;
}

/* Resaltado del término */
.hl {
  background: rgba(16, 185, 129, 0.12);
  color: #065f46;
  padding: 0 2px;
  border-radius: 4px;
}

/* Dirección completa seleccionada (debajo del buscador) */
.direccion-completa-wrapper {
  display: flex;
  align-items: center;
  justify-content: center;
  margin-top: 10px;
  width: 100%;
}

.direccion-completa {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 8px;
  padding: 12px 14px;
  background: #f8fafc;
  border: 1px solid #e5e7eb;
  border-radius: 12px;
  max-width: 100%;
}

.direccion-completa-line {
  display: flex;
  align-items: flex-start;
  gap: 8px;
  max-width: 100%;
}

.direccion-completa-icon {
  color: var(--ion-color-success);
  font-size: 18px;
}

.direccion-completa-text {
  color: #374151;
  font-size: 14px;
  font-weight: 500;
  white-space: pre-wrap; /* permite saltos de línea */
  overflow-wrap: anywhere; /* permite cortes dentro de palabras largas */
  word-break: break-word;
  max-width: min(720px, 100%);
}

.badge-actual {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  font-weight: 600;
  --background: #e6f9f1;
  --color: #047857;
  padding: 6px 10px;
  border-radius: 999px;
}

:host { --kb-height: 0px; }

.predicciones-panel {
  padding-bottom: max(env(safe-area-inset-bottom), var(--kb-height));
  max-height: calc(100vh - var(--kb-height)); /* usa toda la altura disponible */
  overflow: auto;
}


=== app/components/direccion-picker/direccion-picker.component.spec.ts ===
import { ComponentFixture, TestBed, waitForAsync } from '@angular/core/testing';
import { IonicModule } from '@ionic/angular';

import { DireccionPickerComponent } from './direccion-picker.component';

describe('DireccionPickerComponent', () => {
  let component: DireccionPickerComponent;
  let fixture: ComponentFixture<DireccionPickerComponent>;

  beforeEach(waitForAsync(() => {
    TestBed.configureTestingModule({
      declarations: [ DireccionPickerComponent ],
      imports: [IonicModule.forRoot()]
    }).compileComponents();

    fixture = TestBed.createComponent(DireccionPickerComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  }));

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});


=== app/components/direccion-picker/direccion-picker.component.ts ===
// ==============================
// 🧭 DireccionPickerComponent.ts
// ==============================

import { Component, EventEmitter, OnDestroy, OnInit, Output, ViewChild, ElementRef } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { IonicModule, IonModal } from '@ionic/angular';
import { UbicacionService, UbicacionResultado } from 'src/app/services/ubicacion.service';
import { Geolocation } from '@capacitor/geolocation';
import { Subject, Subscription } from 'rxjs';
import { debounceTime, distinctUntilChanged } from 'rxjs/operators';
import { Store } from '@ngxs/store';
import { ClearUbicacionUsuario, SetUbicacionUsuario, UsuarioState } from 'src/app/states/usuario.state';
import { Keyboard } from '@capacitor/keyboard';
import { PluginListenerHandle } from '@capacitor/core';

@Component({
  selector: 'app-direccion-picker',
  templateUrl: './direccion-picker.component.html',
  styleUrls: ['./direccion-picker.component.scss'],
  standalone: true,
  imports: [CommonModule, FormsModule, IonicModule]
})
export class DireccionPickerComponent implements OnInit, OnDestroy {
  @Output() ciudadSeleccionada = new EventEmitter<string | null>();

  abierto = false;
  query = '';
  predicciones: string[] = [];
  ciudadActual: string | null = null;
  direccionActual: string | null = null;
  calleNumero: string | null = null; // lo que se pinta junto a la ciudad (vía+num) o "(Centro)"
  direccionCompacta = false;

  @ViewChild('direccionEl') direccionEl?: ElementRef<HTMLDivElement>;
  @ViewChild(IonModal) modal?: IonModal;

  breakpoints: number[] = [0, 0.5, 1];
  initialBreakpoint = 0.5;

  private queryChanged = new Subject<string>();
  private querySub?: Subscription;

  // Cambia a handles reales (no Promises)
  private kbShowSub?: PluginListenerHandle;
  private kbHideSub?: PluginListenerHandle;

  constructor(private ubicacionService: UbicacionService, private store: Store) {}

  ngOnInit() {
    const ubicacion = this.store.selectSnapshot(UsuarioState.ubicacion);
    if (ubicacion?.ciudad) {
      this.ciudadActual = ubicacion.ciudad;
    }

    if (ubicacion?.direccion) {
      this.direccionActual = ubicacion.direccion;
      this.updateCalleNumeroFromDireccion({
        direccion: ubicacion.direccion,
        ciudad: ubicacion.ciudad || null,
        lat: ubicacion.lat ?? null,
        lng: ubicacion.lng ?? null
      } as any as UbicacionResultado);
    } else if (this.ciudadActual) {
      this.calleNumero = '(Centro)';
    }

    setTimeout(() => this.ajustarTamanoDireccion(), 0);

    this.querySub = this.queryChanged
      .pipe(debounceTime(300), distinctUntilChanged())
      .subscribe((texto) => {
        if (!texto.trim()) {
          this.predicciones = [];
          return;
        }
        this.ubicacionService.autocomplete(texto.trim()).subscribe((res) => {
          this.predicciones = res || [];
        });
      });

    // Escuchar teclado y expandir al 100%
    Keyboard.addListener('keyboardDidShow', (e) => {
      document.documentElement.style.setProperty('--kb-height', `${e.keyboardHeight}px`);
      this.modal?.setCurrentBreakpoint(1); // 100%
    }).then(h => this.kbShowSub = h);

    Keyboard.addListener('keyboardDidHide', () => {
      document.documentElement.style.setProperty('--kb-height', `0px`);
      this.modal?.setCurrentBreakpoint(this.initialBreakpoint);
    }).then(h => this.kbHideSub = h);
  }

  ngOnDestroy() {
    this.querySub?.unsubscribe();
    // remove() devuelve Promise; no es necesario await aquí
    this.kbShowSub?.remove();
    this.kbHideSub?.remove();
  }

  togglePanel() {
    this.abierto = !this.abierto;
    if (this.abierto) {
      this.query = '';
      this.predicciones = [];
    } else {
      this.predicciones = [];
    }
  }

  onModalDismiss() {
    this.abierto = false;
    this.query = '';
    this.predicciones = [];
  }

  buscar() {
    this.queryChanged.next(this.query);
  }

  seleccionar(prediccion: string) {
    this.ubicacionService.geocode(prediccion).subscribe({
      next: (res: UbicacionResultado) => {
        this.direccionActual = res.direccion;
        this.ciudadActual = res.ciudad;
        this.query = res.direccion;
        this.abierto = false;
        this.predicciones = [];

        this.updateCalleNumeroFromDireccion(res);

        this.store.dispatch(new SetUbicacionUsuario({
          direccion: res.direccion,
          ciudad: res.ciudad,
          lat: res.lat,
          lng: res.lng
        }));
        this.ciudadSeleccionada.emit(res.ciudad);
      },
      error: (err) => {
        console.error('Error geocodificando:', err);
        alert('No se pudo obtener la ciudad desde la dirección.');
      }
    });
  }

  async usarMiUbicacion() {
    try {
      const perm = await Geolocation.requestPermissions();
      if (perm.location !== 'granted') {
        alert('Se necesita permiso de geolocalización para usar esta función.');
        return;
      }
      const pos = await Geolocation.getCurrentPosition();
      this.ubicacionService.reverseGeocode(pos.coords.latitude, pos.coords.longitude).subscribe({
        next: (res: UbicacionResultado) => {
          this.direccionActual = res.direccion;
          this.ciudadActual = res.ciudad;
          this.query = res.direccion;
          this.ciudadSeleccionada.emit(res.ciudad);
          this.abierto = false;
          this.predicciones = [];

          this.updateCalleNumeroFromDireccion(res);

          this.store.dispatch(new SetUbicacionUsuario({
            direccion: res.direccion,
            ciudad: res.ciudad,
            lat: res.lat,
            lng: res.lng
          }));
        },
        error: (err) => {
          console.error('Error geolocalización backend:', err);
          alert('No se pudo obtener la ciudad desde tu ubicación.');
        }
      });
    } catch (err) {
      console.error('Error obteniendo ubicación del dispositivo:', err);
      alert('No se pudo acceder al GPS. Verificá permisos.');
    }
  }

  borrar() {
    this.ciudadActual = null;
    this.direccionActual = null;
    this.query = '';
    this.predicciones = [];
    this.abierto = false;
    this.ciudadSeleccionada.emit(null);
    this.store.dispatch(new ClearUbicacionUsuario());
    this.calleNumero = null;
    this.direccionCompacta = false;
  }

  // ===== Autocomplete: SIN formateo =====
  highlight(texto: string): string {
    return texto; // exacto del backend
  }

  // =========================
  // 🔽 Formateo del “chip” (vía + número) con fallback "(Centro)" desde 'direccion'
  // =========================

  private normalizeBasic(s?: string | null): string {
    return (s || '')
      .toLowerCase()
      .normalize('NFD').replace(/[\u0300-\u036f]/g, '')
      .trim();
  }

  private segEsCiudad(seg?: string | null, ciudad?: string | null): boolean {
    if (!seg || !ciudad) return false;
    return this.normalizeBasic(seg) === this.normalizeBasic(ciudad);
  }

  private firstSegment(addr?: string | null): string | null {
    if (!addr) return null;
    const seg = addr.split(',')[0]?.trim() || '';
    return seg || null;
  }

  // Abreviador
  private normalizeToken(s: string): string {
    return (s || '')
      .toLowerCase()
      .normalize('NFD').replace(/[\u0300-\u036f]/g, '')
      .replace(/\./g, '')
      .replace(/\s+/g, '');
  }

  private abreviarToken(token: string): string {
    const k = this.normalizeToken(token);
    switch (k) {
      case 'calle': case 'c': case 'c/': return 'C/';
      case 'avenida': case 'avda': case 'av': return 'Avda.';
      case 'paseo': case 'pº': case 'ps': return 'Pº';
      case 'plaza': case 'pl': return 'Pl.';
      case 'camino': case 'cmno': return 'Cno.';
      case 'carretera': case 'ctra': return 'Ctra.';
      case 'ronda': return 'Rda.';
      case 'travesia': case 'trav': return 'Trva.';
      case 'bulevar': case 'boulevard': case 'blvr': return 'Blvr';
      case 'pasaje': case 'pje': return 'Pje.';
      case 'glorieta': case 'gta': return 'Gta.';
      case 'via': return 'Vía';
      case 'carrer': return 'C/';
      case 'passeig': case 'pg': return 'Pº';
      default:
        return token.charAt(0).toUpperCase() + token.slice(1);
    }
  }

  // Detecta el tipo de vía en el inicio y lo abrevia. Devuelve "C/ Pizarro" o null.
  private abreviarDesdeVia(viaCompleta: string): string | null {
    const re = /^\s*(c\/|c\.|calle|avenida|avda\.?|av\.?|paseo|pº|ps\.?|plaza|pl\.?|camino|carretera|ctra\.?|ronda|v[íi]a|traves[íi]a|trav\.?|bulevar|boulevard|blvr|carrer|passeig|pg|pasaje|pje\.?|glorieta|gta\.?)\s+(de\s+|del\s+|la\s+|los\s+|las\s+)?(.+)$/i;
    const m = viaCompleta.match(re);
    if (!m) return null;
    const token = m[1];
    const resto = m[3].trim();
    const abbr = this.abreviarToken(token);
    return `${abbr} ${resto}`.trim();
  }

  // Extrae número de la dirección (fin del primer tramo o inicio del segundo), evitando CP de 5 dígitos
  private extraerNumero(direccion?: string | null): string | null {
    if (!direccion) return null;
    const partes = direccion.split(',').map(p => p.trim()).filter(Boolean);
    const seg1 = partes[0] || '';
    const seg2 = partes[1] || '';

    // número al final del primer segmento
    const m1 = seg1.match(/(\d+[A-Za-zºª\-\/]?)\s*$/);
    if (m1) return m1[1];

    // número al inicio del segundo segmento (evitar CP 5 dígitos)
    const m2 = seg2.match(/^(\d+[A-Za-zºª\-\/]?)(?!\d)\b/);
    if (m2 && !/^\d{5}$/.test(m2[1])) return m2[1];

    return null;
  }

  // Construye "calle abreviada + número" o "(Centro)" desde res.direccion y res.ciudad
  private formatCalleNumero(res: UbicacionResultado): string {
    const seg = this.firstSegment(res.direccion);
    if (!seg) return '(Centro)';
    if (this.segEsCiudad(seg, res.ciudad)) return '(Centro)';

    const principal = this.abreviarDesdeVia(seg) || seg;
    const yaTieneNumero = /\b\d/.test(principal);
    const numero = this.extraerNumero(res.direccion);

    return (!yaTieneNumero && numero) ? `${principal} ${numero}`.trim() : principal;
  }

  // Aplica el formateo y actualiza el chip superior
  private updateCalleNumeroFromDireccion(res?: UbicacionResultado) {
    if (res) {
      this.calleNumero = this.formatCalleNumero(res) || '(Centro)';
    } else {
      const seg = this.firstSegment(this.direccionActual);
      this.calleNumero = this.segEsCiudad(seg, this.ciudadActual)
        ? '(Centro)'
        : (seg || (this.ciudadActual ? '(Centro)' : null));
    }
    setTimeout(() => this.ajustarTamanoDireccion(), 0);
  }

  private ajustarTamanoDireccion() {
    const el = this.direccionEl?.nativeElement;
    if (!el) { this.direccionCompacta = false; return; }
    const overflow = el.scrollWidth > el.clientWidth + 1;
    this.direccionCompacta = overflow;
  }
}


=== app/components/filter-modal/filters-modal.component.html ===
<ion-header class="modal-header">
  <div class="header-content">
<button
  type="button"
  class="reset-btn"
  [class.active]="hasActiveFilters"
  (click)="onResetClick($event)"
  aria-label="Borrar filtros"
>
  <ion-icon name="trash-outline" class="reset-btn__icon"></ion-icon>

  <!-- Anillo de realce (solo visible cuando hay filtros) -->
  <span class="reset-btn__ring" aria-hidden="true"></span>

  <!-- Chispas al clic -->
  <span class="reset-btn__sparkles" aria-hidden="true"></span>
    <!-- Badge con el número de filtros activos -->
  <span
    class="reset-btn__badge"
    *ngIf="activeFilterCount > 0"
    >{{ activeFilterCount }}</span
  >
</button>
    <h2>Filtros</h2>
    <ion-icon name="close-outline" class="close-icon" (click)="dismiss()"></ion-icon>
  </div>
</ion-header>

<ion-content class="modal-content">
<ion-item lines="none" class="filter-row jugadores-row">
  <ion-label class="filter-label">Jugadores</ion-label>
  <ion-select
    slot="end"
    interface="popover"
    [(ngModel)]="filtros.jugadores"
    placeholder="Todos"
    class="jugadores-select">
    <ion-select-option [value]="null">Todos</ion-select-option>
    <ion-select-option *ngFor="let num of jugadoresOpciones" [value]="num">
      {{ num === 10 ? '10 o más' : num }}
    </ion-select-option>
  </ion-select>
</ion-item>


  <div class="filtro-section">
  <label class="section-label">Precio por persona (€)</label>

  <div *ngIf="!filtros.jugadores">
    <ion-text color="medium" class="precio-info-text">
      <ion-icon name="information-circle-outline"></ion-icon>
      Seleccione el número de jugadores para mayor precisión
    </ion-text>
  </div>

  <ion-range
    min="0"
    max="100"
    step="5"
    snaps="true"
    [(ngModel)]="filtros.precio">
  </ion-range>

<div class="precio-limites-con-texto">
  <span>0 €</span>
  <span class="precio-label">
    {{ filtros.precio ? ('Hasta ' + filtros.precio + ' € por persona') : 'Sin definir' }}
  </span>
  <span>100+ €</span>
</div>
</div>

<div class="filtro-section">
  <label class="section-label">Distancia (km)</label>

  <div *ngIf="!_tieneUbicacion" class="ubicacion-warning">
    <ion-text color="warning">
      <ion-icon name="warning-outline"></ion-icon>
      Selecciona una ubicación para usar este filtro
    </ion-text>
  </div>

  <ion-range
    min="0"
    max="150"
    step="5"
    snaps="true"
    [(ngModel)]="filtros.distancia_km"
    [disabled]="!_tieneUbicacion"
    (ionChange)="onDistanciaChange($event)">
  </ion-range>

  <div *ngIf="_tieneUbicacion" class="precio-limites-con-texto">
    <span>0 KM</span>
    <span class="precio-label">
      {{
        filtros.distancia_km
          ? filtros.distancia_km + ' km de radio'
          : 'Todas las salas de ' + filtros.ciudad
      }}
    </span>
    <span>150 KM</span>
  </div>
</div>

  <div class="filtro-section">
    <label class="section-label">Dificultad</label>
    <div class="categorias-grid">
      <div
        class="categoria-btn"
        *ngFor="let dif of dificultadOpciones"
        [class.selected]="filtros.dificultad.includes(dif)"
        (click)="toggleDificultad(dif)">
        {{ dif }}
      </div>
    </div>
  </div>
  <div class="filtro-section">
    <label class="section-label">Categorías</label>
    <div class="categorias-grid">
      <div
        class="categoria-btn"
        *ngFor="let cat of categoriasOpciones"
        [class.selected]="filtros.categorias.includes(cat.valor)"
        (click)="toggleCategoria(cat.valor)">
        <img [src]="cat.icono" alt="{{cat.nombre}} icono" class="categoria-icon" />
        <span>{{ cat.nombre }}</span>
      </div>
    </div>
  </div>

<!-- ========================================
     NUEVOS FILTROS DE ACTORES E IDIOMA (EN LÍNEA)
     ======================================== -->
<!-- FILTROS DE ACTORES E IDIOMA (UNO DEBAJO DEL OTRO) -->
<!-- Con Actores -->
<ion-item lines="none" class="filter-row">
  <ion-label class="filter-label">Con Actores</ion-label>
  <ion-toggle slot="end" [(ngModel)]="filtros.actores" color="success"></ion-toggle>
</ion-item>

<!-- Idioma -->
<ion-item lines="none" class="filter-row">
  <ion-label class="filter-label">Idioma</ion-label>
  <ion-select
    slot="end"
    interface="popover"
    [(ngModel)]="filtros.idioma"
    placeholder="Cualquier idioma"
    class="idioma-select">
    <ion-select-option [value]="null">Cualquier idioma</ion-select-option>
    <ion-select-option *ngFor="let idioma of idiomaOpciones" [value]="idioma">
      {{ idioma }}
    </ion-select-option>
  </ion-select>
</ion-item>


<div class="filtro-section">
  <ion-item lines="none" (click)="toggleTipoSala()" detail="false" class="collapsible-header">
    <ion-label class="section-label">Tipo de sala</ion-label>
    <ion-icon [name]="isTipoSalaOpen ? 'chevron-up-outline' : 'chevron-down-outline'" slot="end"></ion-icon>
  </ion-item>

  <div *ngIf="isTipoSalaOpen" class="checkbox-grid">
    <ion-item *ngFor="let tipo of tiposSalaOpciones" lines="none" class="checkbox-item">
      <ion-checkbox slot="start"
                    [(ngModel)]="tipo.checked"
                    (ionChange)="onToggleTipo()"
                    class="modern-checkbox" 
                     color="success">
      </ion-checkbox>
      <ion-label>{{ tipo.nombre }}</ion-label>
    </ion-item>
  </div>
</div>

<!-- ========================================
     NUEVO FILTRO DE ACCESIBILIDAD
     ======================================== -->
<div class="filtro-section">
  <ion-item lines="none" (click)="toggleAccesibilidad()" detail="false" class="collapsible-header">
    <ion-label class="section-label">Accesibilidad</ion-label>
    <ion-icon [name]="isAccesibilidadOpen ? 'chevron-up-outline' : 'chevron-down-outline'" slot="end"></ion-icon>
  </ion-item>

  <div *ngIf="isAccesibilidadOpen" class="checkbox-list">
    <ion-item *ngFor="let opcion of accesibilidadOpciones" lines="none" class="checkbox-item">
      <ion-checkbox slot="start"
                    [(ngModel)]="opcion.checked"
                    (ionChange)="onToggleAccesibilidad()"
                    class="modern-checkbox"
                    color="success">
      </ion-checkbox>
      <ion-icon [name]="opcion.icono" slot="start" class="checkbox-icon"></ion-icon>
      <ion-label>{{ opcion.texto }}</ion-label>
    </ion-item>
  </div>
</div>

<!-- ========================================
     NUEVO FILTRO DE RESTRICCIONES
     ======================================== -->
<div class="filtro-section">
  <ion-item lines="none" (click)="toggleRestricciones()" detail="false" class="collapsible-header">
    <ion-label class="section-label">Restricciones</ion-label>
    <ion-icon [name]="isRestriccionesOpen ? 'chevron-up-outline' : 'chevron-down-outline'" slot="end"></ion-icon>
  </ion-item>

  <div *ngIf="isRestriccionesOpen" class="checkbox-list">
    <ion-item *ngFor="let opcion of restriccionesOpciones" lines="none" class="checkbox-item">
      <ion-checkbox slot="start"
                    [(ngModel)]="opcion.checked"
                    (ionChange)="onToggleRestricciones()"
                    class="modern-checkbox"
                    color="success">
      </ion-checkbox>
      <ion-icon [name]="opcion.icono" slot="start" class="checkbox-icon"></ion-icon>
      <ion-label>{{ opcion.texto }}</ion-label>
    </ion-item>
  </div>
</div>

<!-- ========================================
     NUEVO FILTRO DE PÚBLICO OBJETIVO
     ======================================== -->
<div class="filtro-section">
  <ion-item lines="none" (click)="togglePublicoObjetivo()" detail="false" class="collapsible-header">
    <ion-label class="section-label">Público objetivo</ion-label>
    <ion-icon [name]="isPublicoObjetivoOpen ? 'chevron-up-outline' : 'chevron-down-outline'" slot="end"></ion-icon>
  </ion-item>

  <div *ngIf="isPublicoObjetivoOpen" class="checkbox-grid">
    <ion-item *ngFor="let opcion of publicoObjetivoOpciones" lines="none" class="checkbox-item">
      <ion-checkbox slot="start"
                    [(ngModel)]="opcion.checked"
                    (ionChange)="onTogglePublicoObjetivo()"
                    class="modern-checkbox"
                    color="success">
      </ion-checkbox>
      <ion-label>{{ opcion.texto }}</ion-label>
    </ion-item>
  </div>
</div>

</ion-content>

<ion-footer class="modal-footer">
  <ion-button expand="block" class="apply-btn" (click)="aplicarFiltros()">Aplicar filtros</ion-button>
</ion-footer>


=== app/components/filter-modal/filters-modal.component.scss ===
.modal-header {
  padding: 5px 5px;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05); // 👈 Suavidad inferior
  border-bottom: none; // opcional: quita línea dura
  border-radius: 0 0 8px 8px; // 👈 Borde inferior curvado
  z-index: 10;
  position: relative;

  .header-content {
    display: flex;
    justify-content: space-between;
    align-items: center;

    h2 {
      font-size: 18px;
      font-weight: 600;
      margin: 0;
      color: #222;
    }

    .close-icon {
      font-size: 24px;
      color: #555;
      cursor: pointer;
    }
   .reset-icon {
      font-size: 22px;
      color: #a2e3b1;
      cursor: pointer;
      margin-right: 16px;
    }
  }
}

.modal-content {
 --padding-top: 12px;
  --padding-start: 16px;
  --padding-end: 16px;
  --padding-bottom: 24px;
  --background: #fafafa; // 👈 fondo ligeramente distinto
  

.filtro-section {
  margin-top: 20px;

  .section-label {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 8px;
    font-size: 16px;
    font-weight: 600;
    color: #444;

    .dropdown-icon {
      font-size: 18px;
      color: #666;
      margin-left: 8px;
    }
  }

  ion-range {
    --bar-background-active: var(--ion-color-success);
  }
}

// 👇 NUEVOS ESTILOS PARA FILTROS EN LÍNEA
.inline-filters-container {
  display: flex;
  gap: 16px; // Espacio entre los filtros
  align-items: flex-end; // Alinea los items en la parte inferior para que coincidan
}

.inline-filter-item {
  flex: 1; // Cada filtro ocupa el mismo espacio
}

// 👇 AÑADE ESTE NUEVO ESTILO PARA EL TOGGLE
.toggle-item {
  --background: transparent;
  --padding-start: 0;
  --inner-padding-end: 0;
  .section-label {
    margin-bottom: 0;
  }
}

  .categorias-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 10px;
    margin-top: 10px;

    .categoria-btn {
      padding: 8px;
      text-align: center;
      background: #f1f1f1;
      border-radius: 12px;
      font-size: 14px;
      color: #333;
      cursor: pointer;
      user-select: none;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .categoria-btn.selected {
      background: #a2e3b1;
      font-weight: bold;
    }
  }
  .jugadores-select {
  --padding-start: 12px;
  --padding-end: 12px;
  --border-radius: 12px;
  --background: #f1f1f1;
  margin-top: 4px;
}

.precio-info-text {
  font-size: 13px;
  opacity: 0.8;
  display: flex;
  align-items: center;
  gap: 6px;

  ion-icon {
    font-size: 16px;
  }
}

.precio-limites-con-texto {
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-size: 13px;
  color: #444;
  margin-top: 4px;
  padding: 0 2px;

  .precio-label {
    font-size: 13px;
    color: #666;
    text-align: center;
    flex: 1;
  }

  span:first-child,
  span:last-child {
    width: 50px;
    text-align: center;
  }
}


}

.modal-footer {
  /*padding: 16px;
  background: #fff;
  border-top: 1px solid #e0e0e0;*/
    border-top: none;
  border-radius: 16px 16px 0 0; // 👈 Borde superior curvado
  box-shadow: 0 -4px 8px rgba(0, 0, 0, 0.04); // 👈 Sombra superior suave
  background: #fff;
  z-index: 10;
  position: relative;
  padding: 5px;

  .apply-btn {
    --background: var(--ion-color-success);
    --border-radius: 12px;
    font-weight: 600;
  }

  
}

.categoria-icon {
  width: 1.5em;
  height: 1.5em;
  margin-right: 6px;
  vertical-align: middle;
  object-fit: contain;
}

.ubicacion-warning {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 8px;
  margin: 8px 0;
  background-color: rgba(255, 196, 9, 0.1);
  border-radius: 8px;
  font-size: 14px;

  ion-icon {
    font-size: 18px;
    color: var(--ion-color-warning);
  }
}

.collapsible-header {
  --background: transparent;
  --padding-start: 0;
  --inner-padding-end: 0;
  cursor: pointer;
  .section-label {
    margin-bottom: 0;
  }
}

// Para "Tipo de sala" (2 columnas)
.checkbox-grid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 8px;
  padding: 8px 0;
}

// NUEVO: Para "Accesibilidad" (1 columna)
.checkbox-list {
  display: flex;
  flex-direction: column;
  gap: 8px;
  padding: 8px 0;
}

.checkbox-item {
  --background: #f7f7f7;
  --inner-padding-end: 8px;
  --padding-start: 8px;
  border-radius: 12px;
  /* El 'gap' de la rejilla se encarga del espaciado vertical */
}

.checkbox-item ion-icon.checkbox-icon {
  margin-left: 8px;
  margin-right: 8px;
  font-size: 20px;
  color: #555;
}

ion-checkbox.modern-checkbox {
  --size: 28px;
  --border-radius: 8px;
  --border-color-checked: #a2e3b1;
  --background-checked: #a2e3b1;
  --checkmark-color: white;
}

/* Botón circular con glass + anillo de gradiente */
.reset-btn {
  position: relative;
  width: 38px;
  height: 38px;
  border: 0;
  border-radius: 50%;
  background: rgba(255, 255, 255, 0.55);
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
  box-shadow:
    inset 0 0 0 1px rgba(0,0,0,0.06),
    0 4px 14px rgba(0,0,0,0.10);
  display: inline-grid;
  place-items: center;
  cursor: pointer;
  transition: transform 140ms ease, box-shadow 140ms ease, background 140ms ease, opacity 140ms ease;
  margin-right: 10px; /* ajusta si lo necesitas */
  outline: none;
  opacity: 0.95;

  /* Hover suave */
  &:hover { transform: translateY(-1px); }

  /* Active (mientras pulsas) */
  &:active { transform: translateY(0); }

  /* Accesibilidad: respeta reduce motion */
  @media (prefers-reduced-motion: reduce) {
    transition: none;
    & * { animation: none !important; }
  }
}

.reset-btn__icon {
  font-size: 20px;
  color: var(--ion-text-color, #1d1d1f);
  transition: transform 160ms ease, color 160ms ease, opacity 160ms ease;
}

/* Anillo de gradiente (solo cuando hay filtros) */
.reset-btn__ring {
  position: absolute;
  inset: -3px;
  border-radius: 50%;
  pointer-events: none;
  opacity: 0;
  transition: opacity 220ms ease;
  background:
    conic-gradient(
      from 180deg,
      var(--ion-color-success) 0%,
      #7dd3fc 25%,
      #c084fc 50%,
      var(--ion-color-danger) 75%,
      var(--ion-color-success) 100%
    );
  filter: blur(0.6px) saturate(1.1);
  /* marco suave */
  mask:
    radial-gradient(circle at center, transparent 62%, black 63%);
}

/* Chispas (se animan al clic) */
.reset-btn__sparkles {
  --s-size: 8px;
  position: absolute;
  inset: 0;
  pointer-events: none;
}

.reset-btn__sparkles::before,
.reset-btn__sparkles::after {
  content: "";
  position: absolute;
  width: var(--s-size);
  height: var(--s-size);
  border-radius: 2px;
  background: currentColor;
  left: 50%; top: 50%;
  transform: translate(-50%, -50%) scale(0);
  opacity: 0;
}

/* Estado ACTIVO (hay filtros): color + pulso + anillo visible */
.reset-btn.active {
  background: rgba(255, 255, 255, 0.75);
  .reset-btn__icon {
    color: var(--ion-color-success);
    animation: resetBreath 1700ms ease-in-out infinite;
  }
  .reset-btn__ring { opacity: 1; animation: ringSpin 2600ms linear infinite; }
}

/* Animación al clic */
.reset-btn.reset-anim {
  .reset-btn__icon { animation: trashPop 360ms ease forwards; }
  .reset-btn__sparkles::before { animation: sparkA 420ms ease-out forwards; }
  .reset-btn__sparkles::after  { animation: sparkB 480ms ease-out forwards; }
}

/* --- Keyframes --- */

/* Pulso sutil del icono cuando hay filtros */
@keyframes resetBreath {
  0%   { transform: scale(1);   opacity: 1;   }
  50%  { transform: scale(1.06); opacity: 0.95; }
  100% { transform: scale(1);   opacity: 1;   }
}

/* Giro lentísimo del anillo (feedback continuo) */
@keyframes ringSpin {
  to { transform: rotate(360deg); }
}

/* Pop con inclinación de la papelera al clic */
@keyframes trashPop {
  0%   { transform: scale(1) rotate(0deg); }
  35%  { transform: scale(1.18) rotate(-10deg); }
  100% { transform: scale(1) rotate(0deg); }
}

/* Chispas que salen hacia arriba-dcha */
@keyframes sparkA {
  0%   { opacity: 0; transform: translate(-50%, -50%) scale(0.6) rotate(0deg); }
  25%  { opacity: 1; }
  100% { opacity: 0; transform: translate(8px, -18px) scale(0.1) rotate(160deg); }
}

/* Chispas hacia arriba-izda, más lentas */
@keyframes sparkB {
  0%   { opacity: 0; transform: translate(-50%, -50%) scale(0.6) rotate(0deg); }
  25%  { opacity: 1; }
  100% { opacity: 0; transform: translate(-10px, -22px) scale(0.1) rotate(-150deg); }
}

/* Modo oscuro: ajusta fondo e icono */
:host-context(.dark) .reset-btn {
  background: rgba(24, 24, 27, 0.55);
  box-shadow:
    inset 0 0 0 1px rgba(255,255,255,0.06),
    0 4px 14px rgba(0,0,0,0.35);
}

:host-context(.dark) .reset-btn__icon {
  color: #e5e7eb;
}

.reset-btn__badge {
  position: absolute;
  top: -4px;
  right: -4px;
  min-width: 18px;
  height: 18px;
  padding: 0 4px;
  border-radius: 999px;
  background: var(--ion-color-danger);
  color: #fff;
  font-size: 11px;
  font-weight: 600;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 2px 4px rgba(0,0,0,0.25);
  transform: scale(0);
  opacity: 0;
  transition: transform 180ms ease, opacity 180ms ease;
}

/* Aparece cuando hay filtros activos */
.reset-btn.active .reset-btn__badge {
  transform: scale(1);
  opacity: 1;
}


/* 👉 NUEVO ESTILO PARA FILTROS "Con Actores" e "Idioma" EN UNA LÍNEA */
.filter-row {
  --background: transparent;
  --padding-start: 0;
  --inner-padding-end: 0;
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-top: 10px;

  ion-label.filter-label {
    font-size: 16px;
    font-weight: 600;
    color: #444;
    flex-shrink: 0; /* Evita que la etiqueta se encoja */
    margin-right: 16px; /* Añade un espacio de seguridad */
  }

  ion-select.idioma-select {
    --background: #f1f1f1;
    --border-radius: 12px;
    --padding-start: 12px;
    --padding-end: 12px;
    font-size: 14px;
    min-width: 160px;
    text-align: right;
  }
}

.filter-row.jugadores-row {
  ion-select.jugadores-select {
    min-width: 0; // Permite que el select se encoja por debajo de su ancho base
    flex: 1;           // se expande si hay espacio
  }
}



=== app/components/filter-modal/filters-modal.component.ts ===
import { Component, Input, OnInit } from '@angular/core';
import { CommonModule } from '@angular/common';
import { IonicModule, ModalController } from '@ionic/angular';
import { FormsModule } from '@angular/forms';
import { Store } from '@ngxs/store';
import { CATEGORIAS } from '../../constants/categorias.const';
@Component({
  selector: 'app-filters-modal',
  standalone: true,
  imports: [CommonModule, IonicModule, FormsModule ],
  templateUrl: './filters-modal.component.html',
  styleUrls: ['./filters-modal.component.scss']
})
export class FiltersModalComponent implements OnInit {
  @Input() filtrosActuales: any = {};
 // distancia: number = 10;
  filtros: any = {
    jugadores: null,
    distancia_km: undefined,
    precio: null,
    tipo_sala: [],
    categorias: [],
    dificultad: [],
    accesibilidad: [],
    restricciones_aptas: [],
    publico_objetivo: [],
    actores: false, // 👈 Nuevo filtro para Actores
    idioma: null    // 👈 Nuevo filtro para Idioma
  };
jugadoresOpciones = [2, 3, 4, 5, 6, 7, 8, 9, 10];
tiposSalaOpciones: any[] = [ // 👈 CAMBIO: Especificar el tipo como any[]
  'Al aire libre',
  'Escape Room',
  'Experiencia',
  'Hall game',
  'Juego portátil',
  'Realidad Virtual'
];
dificultadOpciones = ['Fácil', 'Media', 'Alta'];
// 👇 Nuevas opciones para el desplegable de Idioma
idiomaOpciones: string[] = ['Español', 'Inglés', 'Catalán', 'Francés'];
accesibilidadOpciones: any[] = [
  { texto: 'Apto Discapacidad motora', valor: 'Apto Discapacidad motora', icono: 'accessibility-outline' },
  { texto: 'Apto Discapacidad visual', valor: 'Apto Discapacidad visual', icono: 'eye-off-outline' },
  { texto: 'Apto Discapacidad auditiva', valor: 'Apto Discapacidad auditiva', icono: 'ear-outline' }
];
// 👇 Nuevas opciones de restricciones
restriccionesOpciones: any[] = [
  { texto: 'Apto para embarazadas', valor: 'Mujeres embarazadas', icono: 'female-outline' },
  { texto: 'Apto para claustrofobia', valor: 'Claustrofobia', icono: 'lock-open-outline' }
];
// 👇 Nuevas opciones de público objetivo
publicoObjetivoOpciones: any[] = [
  { texto: 'Niños con adulto', valor: 'Niños con adulto', icono: 'people-circle-outline' },
  { texto: 'Niños con Monitor', valor: 'Niños con Monitor', icono: 'school-outline' },
  { texto: 'Empresas', valor: 'Empresas', icono: 'business-outline' },
  { texto: 'Grupos grandes', valor: 'Grupos grandes', icono: 'people-outline' },
  { texto: 'Estandar', valor: 'Estandar', icono: 'person-outline' },
  { texto: 'Familiar', valor: 'Familiar', icono: 'home-outline' },
  { texto: 'Niños', valor: 'Niños', icono: 'happy-outline' }
];
categoriasOpciones = CATEGORIAS.slice(1);
isTipoSalaOpen = false;
isAccesibilidadOpen = false;
isRestriccionesOpen = false;
isPublicoObjetivoOpen = false; // 👈 Nuevo: para controlar el desplegable
_tieneUbicacion: boolean = false;

  constructor(private modalCtrl: ModalController, private store: Store) {}

  ngOnInit() {
    this.filtros = {
      ...this.filtros,
      ...this.filtrosActuales,
      categorias: Array.isArray(this.filtrosActuales.categorias) ? [...this.filtrosActuales.categorias] : [],
      dificultad: Array.isArray(this.filtrosActuales.dificultad) ? [...this.filtrosActuales.dificultad] : [],
      tipo_sala: Array.isArray(this.filtrosActuales.tipo_sala) ? [...this.filtrosActuales.tipo_sala] : [],
      accesibilidad: Array.isArray(this.filtrosActuales.accesibilidad) ? [...this.filtrosActuales.accesibilidad] : [],
      restricciones_aptas: Array.isArray(this.filtrosActuales.restricciones_aptas) ? [...this.filtrosActuales.restricciones_aptas] : [],
      publico_objetivo: Array.isArray(this.filtrosActuales.publico_objetivo) ? [...this.filtrosActuales.publico_objetivo] : [],
      actores: this.filtrosActuales.actores === true,
     idioma: this.filtrosActuales.idioma || null,
      precio: this.filtrosActuales.precio ?? null,
      distancia_km: this.filtrosActuales.distancia_km ?? undefined
    };
    this._tieneUbicacion = !!this.filtrosActuales.ciudad;

    this.tiposSalaOpciones = this.tiposSalaOpciones.map(nombre => ({
      nombre,
      checked: this.filtros.tipo_sala.includes(nombre)
    }));
    this.accesibilidadOpciones = this.accesibilidadOpciones.map(opcion => ({
      ...opcion,
      checked: this.filtros.accesibilidad.includes(opcion.valor)
    }));
    this.restriccionesOpciones = this.restriccionesOpciones.map(opcion => ({
      ...opcion,
      checked: this.filtros.restricciones_aptas.includes(opcion.valor)
    }));
    this.publicoObjetivoOpciones = this.publicoObjetivoOpciones.map(opcion => ({
      ...opcion,
      checked: this.filtros.publico_objetivo.includes(opcion.valor)
    }));

    // 👇 Abrir automáticamente las secciones con selecciones previas
    this.isTipoSalaOpen = this.filtros.tipo_sala.length > 0;
    this.isAccesibilidadOpen = this.filtros.accesibilidad.length > 0;
    this.isRestriccionesOpen = this.filtros.restricciones_aptas.length > 0;
    this.isPublicoObjetivoOpen = this.filtros.publico_objetivo.length > 0;
  }

  dismiss() {
    this.modalCtrl.dismiss();
  }

aplicarFiltros() {
  const filtrosParaEnviar = { ...this.filtros };

  // Booleanos: si es false, que vaya como undefined
  if (!filtrosParaEnviar.actores) filtrosParaEnviar.actores = undefined;

  // Listas: si quedan vacías, NO delete -> undefined (pisa el valor anterior en el padre)
  if (!filtrosParaEnviar.categorias?.length) filtrosParaEnviar.categorias = undefined;
  if (!filtrosParaEnviar.dificultad?.length) filtrosParaEnviar.dificultad = undefined;
  if (!filtrosParaEnviar.tipo_sala?.length) filtrosParaEnviar.tipo_sala = undefined;
  if (!filtrosParaEnviar.accesibilidad?.length) filtrosParaEnviar.accesibilidad = undefined;
  if (!filtrosParaEnviar.restricciones_aptas?.length) filtrosParaEnviar.restricciones_aptas = undefined;
  if (!filtrosParaEnviar.publico_objetivo?.length) filtrosParaEnviar.publico_objetivo = undefined;
  if (!filtrosParaEnviar.idioma) filtrosParaEnviar.idioma = undefined;
  if (!filtrosParaEnviar.precio) filtrosParaEnviar.precio = undefined;
  if (!filtrosParaEnviar.distancia_km) filtrosParaEnviar.distancia_km = undefined;

  this.modalCtrl.dismiss(filtrosParaEnviar);
}
resetearFiltros() {
  const ciudad = this.filtros.ciudad;

  this.filtros = {
    ciudad,
    jugadores: null,
    distancia_km: null, // si quieres resetear también la distancia
    precio: null,
    tipo_sala: [],
    categorias: [],
    dificultad: [],
    accesibilidad: [],
    restricciones_aptas: [],
    publico_objetivo: [],
    actores: false,
    idioma: null
  };

  // Desmarcar visualmente todos los checkboxes (nuevas refs -> change detection)
  this.tiposSalaOpciones = this.tiposSalaOpciones.map(t => ({ ...t, checked: false }));
  this.accesibilidadOpciones = this.accesibilidadOpciones.map(o => ({ ...o, checked: false }));
  this.restriccionesOpciones = this.restriccionesOpciones.map(o => ({ ...o, checked: false }));
  this.publicoObjetivoOpciones = this.publicoObjetivoOpciones.map(o => ({ ...o, checked: false }));
}

toggleTipoSala() {
  this.isTipoSalaOpen = !this.isTipoSalaOpen;
}

toggleAccesibilidad() {
  this.isAccesibilidadOpen = !this.isAccesibilidadOpen;
}

toggleRestricciones() {
  this.isRestriccionesOpen = !this.isRestriccionesOpen;
}

// 👇 Nuevo: Abre y cierra el desplegable de público objetivo
togglePublicoObjetivo() {
  this.isPublicoObjetivoOpen = !this.isPublicoObjetivoOpen;
}

onToggleTipo() {
  this.filtros.tipo_sala = (this.tiposSalaOpciones as any[])
    .filter(t => t.checked)
    .map(t => t.nombre);
}

onToggleAccesibilidad() {
  this.filtros.accesibilidad = this.accesibilidadOpciones
    .filter(opcion => opcion.checked)
    .map(opcion => opcion.valor);
}

// 👇 Nuevo: Actualiza los filtros cuando un checkbox de restricciones cambia
onToggleRestricciones() {
  this.filtros.restricciones_aptas = this.restriccionesOpciones
    .filter(opcion => opcion.checked)
    .map(opcion => opcion.valor);
}

// 👇 Nuevo: Actualiza los filtros cuando un checkbox de público objetivo cambia
onTogglePublicoObjetivo() {
  this.filtros.publico_objetivo = this.publicoObjetivoOpciones
    .filter(opcion => opcion.checked)
    .map(opcion => opcion.valor);
}

toggleCategoria(cat: string) {
  const idx = this.filtros.categorias.indexOf(cat);
  if (idx > -1) {
    this.filtros.categorias.splice(idx, 1);
  } else {
    this.filtros.categorias.push(cat);
  }
}

toggleDificultad(dificultad: string) {
    const idx = this.filtros.dificultad.indexOf(dificultad);
    if (idx > -1) {
      this.filtros.dificultad.splice(idx, 1);
    } else {
      this.filtros.dificultad.push(dificultad);
    }
  }
onDistanciaChange(event: any) {
  const value = event.detail.value;
  this.filtros.distancia_km = value === 0 ? undefined : value;
}


  get hasActiveFilters(): boolean {
  const f = this.filtros || {};
  // ❌ No cuenta 'ciudad'
  return !!(
    f.jugadores ||
    f.precio ||
    f.distancia_km ||
    (Array.isArray(f.tipo_sala) && f.tipo_sala.length) ||
    (Array.isArray(f.categorias) && f.categorias.length) ||
    (Array.isArray(f.dificultad) && f.dificultad.length) ||
    (Array.isArray(f.accesibilidad) && f.accesibilidad.length) ||
    (Array.isArray(f.restricciones_aptas) && f.restricciones_aptas.length) ||
    (Array.isArray(f.publico_objetivo) && f.publico_objetivo.length) ||
    f.actores === true ||
    !!f.idioma
  );
}

get activeFilterCount(): number {
  const f = this.filtros || {};
  let count = 0;

  // Jugadores
  if (f.jugadores) count++;
  // Precio
  if (f.precio) count++;
  // Distancia
  if (f.distancia_km) count++;
  // Arrays
  const arrays = [
    f.tipo_sala,
    f.categorias,
    f.dificultad,
    f.accesibilidad,
    f.restricciones_aptas,
    f.publico_objetivo
  ];
  arrays.forEach(arr => {
    if (Array.isArray(arr) && arr.length) count += arr.length;
  });
  // Booleanos
  if (f.actores === true) count++;
  // Select idioma
  if (f.idioma) count++;

  return count;
}

onResetClick(ev: Event) {
  const el = ev.currentTarget as HTMLElement;
  el.classList.remove('reset-anim');
  // Reinicia animaciones si clicas varias veces
  void el.offsetWidth;
  el.classList.add('reset-anim');

  this.resetearFiltros();
}
}

=== app/components/sala-card/sala-card.component.html ===
<ion-card class="sala-card">
  <!-- Mostrar el contenido real solo cuando la imagen se ha cargado completamente -->
  <ng-container *ngIf="!loadingImage; else skeletonTemplate">
    
    <!-- Imagen principal de la sala -->
    <div class="img-wrapper">
      <div class="image-container">
        <img
          [src]="currentImage"
          [attr.loading]="'lazy'"
          (load)="onImageLoad()"
          (error)="onImageError()"
          [class.loaded]="!loadingImage"
          alt="Imagen de la sala"
        />
      </div>
      <!-- Icono de favorito (verde si activo) -->
      <ion-icon
        #favoriteIcon
        [name]="isFavorito ? 'heart' : 'heart-outline'"
        class="favorite-icon"
        (click)="toggleFavorito($event)">
      </ion-icon>
      <!-- Nombre de la sala y ciudad -->
  <div class="nombre-overlay">
    <h2>{{ sala.nombre }}</h2>
    <p class="empresa">{{ sala.empresa }} - <small>{{ sala.ciudad }}</small></p>
    </div>
  </div>
  <!-- Chips informativos agrupados en dos filas -->
  <div class="info-chips-container">
    <!-- Fila Superior: Jugadores, Dificultad, Categorías -->
    <div class="chip-row chip-row-top">
      <div class="chip">
        <ion-icon name="people-outline"></ion-icon>
        <span>{{ sala.jugadores_min }}-{{ sala.jugadores_max }}</span>
      </div>
      <div class="chip">
        <ion-icon name="extension-puzzle-outline"></ion-icon>
        <span>{{ sala.dificultad }}</span>
      </div>
      <div class="chip chip-categorias" *ngIf="sala.categorias && sala.categorias.length > 0">
        <ion-icon name="pricetag-outline"></ion-icon>
        <span>{{ sala.categorias.join(', ') }}</span>
      </div>
    </div>

    <!-- Fila Inferior: Precio y Distancia -->
    <div class="chip-row chip-row-bottom">
      <!-- Chip de Precio -->
      <div class="chip chip-precio" *ngIf="sala.precio_min_pp">
        <ion-icon name="cash-outline"></ion-icon>
        <span>Desde {{ sala.precio_min_pp }}€ por persona</span>
      </div>
      <!-- Chip de Distancia -->
      <div class="chip" *ngIf="sala.distancia_km !== null && sala.distancia_km !== undefined">
        <ion-icon name="navigate-circle-outline"></ion-icon>
        <span>{{ formatDistancia(sala.distancia_km) }}</span>
      </div>
    </div>
  </div>

  <!-- Contenido de la tarjeta -->
  <ion-card-content>
      <p class="descripcion-limitada">
        {{ sala.descripcion_corta || 'Sin descripción disponible.' }}
      </p>
    </ion-card-content>
  </ng-container>
  <!-- 💀 SKELETON (sólo se muestra mientras loadingImage === true) -->
  <ng-template #skeletonTemplate>
    <div class="skeleton-wrapper">
      <div class="skeleton-image shimmer"></div>
      <div class="skeleton-lines">
        <div class="shimmer skeleton-line short"></div>
        <div class="shimmer skeleton-line medium"></div>
        <div class="shimmer skeleton-line long"></div>
      </div>
    </div>
  </ng-template>
</ion-card>



=== app/components/sala-card/sala-card.component.scss ===
/* ========================================
   Estilos del componente SalaCard
   ======================================== */
.sala-card {
  border-radius: 16px;
  overflow: hidden;
  background: #fff;
  box-shadow: 0 4px 10px rgba(0, 0, 0, 0.06);
  margin-bottom: 16px;

  .img-wrapper {
    position: relative;
    border-radius: 12px;
    overflow: hidden;

    .image-container {
      width: 100%;
      height: 240px;
      position: relative;

      &::after {
        content: '';
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        height: 60%;
        background: linear-gradient(to top, rgba(0, 0, 0, 0.7) 0%, rgba(0, 0, 0, 0) 100%);
        z-index: 1;
        border-radius: 0 0 12px 12px;
      }
    }

    img {
      width: 100%;
      height: 240px;
      object-fit: cover;
      opacity: 0;
      transition: opacity 0.4s ease-in;
    }
    img.loaded {
      opacity: 1;
    }

    .favorite-icon {
      position: absolute;
      top: 10px;
      right: 10px;
      font-size: 30px;
      color: #32db64;
      z-index: 2;
      border-radius: 50%;
      padding: 4px;
      background: transparent;
      transition: transform 0.2s ease, opacity 0.2s ease;
    }
    .favorite-icon.pulse-animation {
      animation: pulse 0.3s ease;
    }
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.4); }
      100% { transform: scale(1); }
    }

    .nombre-overlay {
      position: absolute;
      bottom: 12px;
      left: 12px;
      right: 12px;
      color: white;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.6);
      z-index: 2;

      h2 {
        margin: 0;
        font-size: 18px;
        font-weight: 600;
        line-height: 1.2;
      }
      .empresa {
        font-size: 14px;
        margin: 0;
        opacity: 0.9;
      }
      small {
        font-size: 13px;
        opacity: 0.75;
      }
    }

    .info-overlay {
      display: none;
    }
  }

  .info-chips-container {
    display: flex;
    flex-direction: column;
    gap: 8px;
    padding: 12px 16px 0;
  }

  .chip-row {
    display: flex;
    align-items: center;
    gap: 8px;

    .chip {
      flex-grow: 1;
      flex-shrink: 1;
      flex-basis: auto;
      min-width: 0;
      justify-content: center;
      text-align: center;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
  }

  .chip-row-top {
    justify-content: space-between;

    .chip-categorias {
      flex-grow: 1.5;
    }
  }

  .chip-row-bottom {
    justify-content: center;

    &:has(> :nth-child(2)) {
      justify-content: space-between;
    }

    .chip-precio {
      flex-grow: 1.5;
    }
  }

  .chip {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 6px;
    font-size: 13px;
    padding: 6px 10px;
    border-radius: 16px;
    font-weight: 500;
    background: #f7f7f7;
    color: #333;
    border: 1px solid #e0e0e0;
    transition: background 0.2s ease;
    animation: chipFadeIn 0.3s ease;

    &:hover {
      background: #eeeeee;
    }

    ion-icon {
      font-size: 16px;
      flex-shrink: 0;
    }
  }

  .chip-row-top .chip:nth-child(1) {
    background: #e3f2fd;
    color: #0d47a1;
    border-color: #bbdefb;
  }

  .chip-row-top .chip:nth-child(2) {
    background: #fff3e0;
    color: #ef6c00;
    border-color: #ffe0b2;
  }

  .chip-categorias {
    background: #ede7f6;
    color: #5e35b1;
    border-color: #d1c4e9;
  }

  .chip-precio {
    background: #e8f5e9;
    color: #2e7d32;
    border-color: #c8e6c9;
  }

  .chip-row-bottom .chip:not(.chip-precio) {
    background: #fce4ec;
    color: #ad1457;
    border-color: #f8bbd0;
  }

  @keyframes chipFadeIn {
    from {
      opacity: 0;
      transform: scale(0.95);
    }
    to {
      opacity: 1;
      transform: scale(1);
    }
  }

  @media (max-width: 360px) {
    .chip-row-top .chip {
      font-size: 11px;
      padding: 5px 8px;

      ion-icon {
        font-size: 14px;
      }
    }
  }

  ion-card-content {
    padding: 12px 16px;
    .descripcion-limitada {
  font-size: 14px;
  color: #2e2e2e;
  line-height: 1.4;
  font-weight: 500;
  padding-top: 10px;
  margin-top: 10px;
  border-top: 1px solid #f0f0f0;

  display: -webkit-box;
  -webkit-line-clamp: 5;
  -webkit-box-orient: vertical;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: normal;

  /* animación sutil si se quiere mostrar con fade */
  animation: fadeInDescripcion 0.3s ease-in;
}

@keyframes fadeInDescripcion {
  from { opacity: 0; transform: translateY(4px); }
  to   { opacity: 1; transform: translateY(0); }
}
  }
}

/* ========================================
   Skeleton de carga
   ======================================== */
.skeleton-wrapper {
  padding: 16px;
}
.skeleton-image {
  width: 100%;
  height: 240px;
  background: #e0e0e0;
  border-radius: 12px;
  margin-bottom: 12px;
}
.skeleton-lines {
  display: flex;
  flex-direction: column;
  gap: 8px;
  .skeleton-line {
    height: 14px;
    background: #ddd;
    border-radius: 8px;
    &.short { width: 40%; }
    &.medium { width: 60%; }
    &.long { width: 80%; }
  }
}
.shimmer {
  background: linear-gradient(
    to right,
    #e0e0e0 0%,
    #f8f8f8 50%,
    #e0e0e0 100%
  );
  background-size: 200% 100%;
  animation: shimmer 1.2s infinite linear;
}
@keyframes shimmer {
  0% { background-position: -200% 0; }
  100% { background-position: 200% 0; }
}


=== app/components/sala-card/sala-card.component.spec.ts ===
import { ComponentFixture, TestBed, waitForAsync } from '@angular/core/testing';
import { IonicModule } from '@ionic/angular';

import { SalaCardComponent } from './sala-card.component';

describe('SalaCardComponent', () => {
  let component: SalaCardComponent;
  let fixture: ComponentFixture<SalaCardComponent>;

  beforeEach(waitForAsync(() => {
    TestBed.configureTestingModule({
      declarations: [ SalaCardComponent ],
      imports: [IonicModule.forRoot()]
    }).compileComponents();

    fixture = TestBed.createComponent(SalaCardComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  }));

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});


=== app/components/sala-card/sala-card.component.ts ===
import {
  Component,
  Input,
  ViewChild,
  ElementRef,
  ChangeDetectorRef,
  OnDestroy,
  OnInit,
  OnChanges,
  SimpleChanges
} from '@angular/core';
import { Sala } from 'src/app/models/sala.model';
import { CommonModule } from '@angular/common';
import { IonicModule } from '@ionic/angular';
import { Haptics, ImpactStyle } from '@capacitor/haptics';
import { FavoritosService } from 'src/app/services/favoritos.service';
import { Subscription } from 'rxjs';
import { environment } from 'src/environments/environment';

/**
 * SalaCardComponent
 *
 * Componente que representa visualmente una sala de escape.
 * Muestra skeleton mientras se carga la imagen, incluyendo retardo mínimo visual.
 * Resetea el estado visual cuando la sala cambia (Input muta sin destruir el componente).
 */
@Component({
  selector: 'app-sala-card',
  standalone: true,
  templateUrl: './sala-card.component.html',
  styleUrls: ['./sala-card.component.scss'],
  imports: [CommonModule, IonicModule]
})
export class SalaCardComponent implements OnInit, OnDestroy, OnChanges {
  @Input() sala!: Sala;
  @ViewChild('favoriteIcon') favoriteIconRef!: ElementRef;

  isFavorito = false;
  loadingImage = true;

  // Tiempo mínimo que el skeleton debe estar visible, en milisegundos.
  private skeletonDelay = 400;
  private imageLoadStart = 0;

  private favoritoSub?: Subscription;
  private animationFrameId: number | null = null;

  fallbackImage = 'assets/escapeImagen.png';
  currentImage = '';
  private urlImage = environment.imageURL;

  constructor(
    private favoritosService: FavoritosService,
    private cdr: ChangeDetectorRef
  ) {}

  /**
   * Se llama cuando el componente se inicializa por primera vez.
   */
  ngOnInit() {
    this.resetCard(); // inicialización de imagen y skeleton

    this.favoritoSub = this.favoritosService
      .getFavoritoStatusStream(this.sala.id_sala)
      .subscribe(isFav => {
        this.isFavorito = isFav;
        this.cdr.markForCheck();
      });
  }

  /**
   * Detecta cambios en el input `sala` (cuando Angular reutiliza la card).
   * Esto es necesario porque Angular NO destruye el componente si se usa `trackBy`.
   */
  ngOnChanges(changes: SimpleChanges): void {
    if (changes['sala'] && !changes['sala'].firstChange) {
      this.resetCard(); // reiniciar imagen y skeleton al recibir nueva sala
    }
  }

  ngOnDestroy() {
    this.favoritoSub?.unsubscribe();
    if (this.animationFrameId) cancelAnimationFrame(this.animationFrameId);
  }

  /**
   * Inicializa la imagen y fuerza la visualización del skeleton con retardo mínimo.
   */
  private resetCard() {
    this.loadingImage = true;
    this.imageLoadStart = performance.now();

    this.currentImage = this.sala.cover_url
      ? this.urlImage + this.sala.cover_url
      : this.fallbackImage;

    const img = new Image();
    img.src = this.currentImage;
    img.onload = () => this.onImageLoad();
    img.onerror = () => this.onImageError();
  }

  /**
   * Evento lanzado cuando la imagen se ha cargado (o el fallback).
   * Asegura un mínimo de tiempo para que el skeleton sea visible.
   */
  onImageLoad() {
    const elapsed = performance.now() - this.imageLoadStart;
    const remaining = Math.max(this.skeletonDelay - elapsed, 0);

    setTimeout(() => {
      this.loadingImage = false;
      this.cdr.markForCheck(); // forzar redibujo en caso de imagen rápida
    }, remaining);
  }

  /**
   * Si la imagen falla, se usa una imagen por defecto.
   * También se asegura que se dispare `onImageLoad()` aunque falle la carga original.
   */
  onImageError() {
    if (this.currentImage !== this.fallbackImage) {
      this.currentImage = this.fallbackImage;

      const fallback = new Image();
      fallback.src = this.fallbackImage;
      fallback.onload = () => this.onImageLoad();
    } else {
      this.loadingImage = false;
    }
  }

  /**
   * Marca o desmarca una sala como favorita, con feedback háptico y animación.
   */
  async toggleFavorito(event: Event) {
    event.stopPropagation();
    event.preventDefault();

    const target = event.target as HTMLElement;
    if (!target) return;

    target.style.transform = 'scale(1)';
    await Haptics.impact({ style: ImpactStyle.Light });

    this.animationFrameId = requestAnimationFrame(() => {
      target.classList.add('pulse-animation');
      this.favoritosService.toggleFavorito(this.sala.id_sala);
      setTimeout(() => {
        target.classList.remove('pulse-animation');
        this.animationFrameId = null;
      }, 300);
    });
  }

  /**
   * Formatea la distancia para mostrarla en la tarjeta de la sala.
   * Si la distancia es menor a 1 km, se muestra en metros.
   * Si es 1 km o más, se muestra con un decimal.
   */
  formatDistancia(km: number): string {
    if (km < 1) {
      return `${Math.round(km * 1000)} m`;
    }
    return `${km.toFixed(1)} km`;
  }

  // NUEVA FUNCIÓN para formatear el rango de precios
  formatPrecio(min?: number, max?: number): string {
    if (min && max) {
      if (min === max) {
        return `${min}€`;
      }
      return `${min}€ - ${max}€`;
    }
    if (min) {
      return `${min}€`;
    }
    if (max) {
      return `${max}€`;
    }
    return 'N/A';
  }
}


